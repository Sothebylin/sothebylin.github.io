
[{"content":"","date":"30 March 2025","externalUrl":null,"permalink":"/series/algorithm-learing/","section":"Series","summary":"","title":"Algorithm Learing","type":"series"},{"content":"","date":"30 March 2025","externalUrl":null,"permalink":"/categories/algorithm-problems/","section":"æ–‡ç« åˆ†ç±»","summary":"","title":"Algorithm Problems","type":"categories"},{"content":"","date":"30 March 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"30 March 2025","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"30 March 2025","externalUrl":null,"permalink":"/","section":"æ˜¥æ—¥æ±€","summary":"","title":"æ˜¥æ—¥æ±€","type":"page"},{"content":" å›¾è®º-2ï¼ˆDijkstra\u0026amp;\u0026amp;Floyd) # æœ¬ç³»åˆ—çš„å¤§éƒ¨åˆ†éƒ½æ˜¯å¯¹labuladongå’Œä»£ç éšæƒ³å½•ç½‘ç«™çš„é¢˜ç›®çš„ç»ƒæ‰‹æ±‡æ€»(éƒ¨åˆ†æ˜¯åšä¸»è‡ªå·±ç»“åˆleetcodeå’Œæ´›è°·é¢˜ç›®çš„è¡¥å……ï¼‰åˆè¡·æ˜¯åšä¸»è‡ªç”¨å­¦ä¹ å“’!\nè¯·æ‰€æœ‰é˜…è¯»è¿™ç³»åˆ—åšå®¢çš„å‹å‹å…ˆç§»æ­¥é˜…è§ˆä»–ä»¬çš„ç½‘ç«™ï¼Œæ²¡æœ‰è¿™äº›ä¼˜ç§€ç½‘ç«™çš„åˆ†äº«ä¸ä¼šæœ‰è¿™ç³»åˆ—çš„æ–‡ç« ï¼Œæˆ‘åªæ˜¯çŸ¥è¯†çš„æ¬è¿å·¥ï¼\nDijkstraä¸‰éƒ¨æ›²(ä»£ç éšæƒ³å½•) # ç¬¬ä¸€æ­¥ï¼Œé€‰æºç‚¹åˆ°å“ªä¸ªèŠ‚ç‚¹è¿‘ä¸”è¯¥èŠ‚ç‚¹æœªè¢«è®¿é—®è¿‡ ç¬¬äºŒæ­¥ï¼Œè¯¥æœ€è¿‘èŠ‚ç‚¹è¢«æ ‡è®°è®¿é—®è¿‡ ç¬¬ä¸‰æ­¥ï¼Œæ›´æ–°éè®¿é—®èŠ‚ç‚¹åˆ°æºç‚¹çš„è·ç¦»ï¼ˆå³æ›´æ–°minDistæ•°ç»„ï¼‰ minDistæ•°ç»„çš„å«ä¹‰ï¼šè®°å½•æ‰€æœ‰èŠ‚ç‚¹åˆ°èµ·å§‹ç‚¹çš„æœ€çŸ­è·¯å¾„\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;climits\u0026gt; using namespace std; int main() { int n, m, p1, p2, val; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; grid(n + 1, vector\u0026lt;int\u0026gt;(n + 1, INT_MAX)); //girdè®°å½•å„èŠ‚ç‚¹ä¹‹é—´çš„æƒå€¼ //åˆå§‹åŒ– for(int i = 0; i \u0026lt; m; i++){ cin \u0026gt;\u0026gt; p1 \u0026gt;\u0026gt; p2 \u0026gt;\u0026gt; val; grid[p1][p2] = val; } int start = 1; int end = n; // å­˜å‚¨ä»èµ·å§‹ç‚¹åˆ°æ¯ä¸ªèŠ‚ç‚¹çš„æœ€çŸ­è·ç¦» vector\u0026lt;int\u0026gt; minDist(n + 1, INT_MAX); // è®°å½•é¡¶ç‚¹æ˜¯å¦è¢«è®¿é—®è¿‡ vector\u0026lt;bool\u0026gt; visited(n + 1, false); minDist[start] = 0; // èµ·å§‹ç‚¹åˆ°è‡ªèº«çš„è·ç¦»ä¸º0 for (int i = 1; i \u0026lt;= n; i++) { // éå†æ‰€æœ‰èŠ‚ç‚¹ int minVal = INT_MAX; int cur = 1; //curè®°å½•å°†è¦é€‰å–çš„æœ€è¿‘çš„ç‚¹ // 1ã€é€‰è·ç¦»æºç‚¹æœ€è¿‘ä¸”æœªè®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œminvalç»´æŠ¤è¿™äº›èŠ‚ç‚¹ä¸­ä¸èµ·å§‹ç‚¹çš„æœ€å°æƒå€¼ for (int v = 1; v \u0026lt;= n; ++v) { if (!visited[v] \u0026amp;\u0026amp; minDist[v] \u0026lt; minVal) { minVal = minDist[v]; cur = v; } } visited[cur] = true; // 2ã€æ ‡è®°è¯¥èŠ‚ç‚¹å·²è¢«è®¿é—® // 3ã€ç¬¬ä¸‰æ­¥ï¼Œæ›´æ–°éè®¿é—®èŠ‚ç‚¹åˆ°æºç‚¹çš„è·ç¦»ï¼ˆå³æ›´æ–°minDistæ•°ç»„ï¼‰ for (int v = 1; v \u0026lt;= n; v++) { if (!visited[v] \u0026amp;\u0026amp; grid[cur][v] != INT_MAX \u0026amp;\u0026amp; minDist[cur] + grid[cur][v] \u0026lt; minDist[v]) { //éœ€è¦åˆ¤æ–­INT_MAX,å› ä¸ºå¦‚æœé åé¢æ˜¯å¦å°äºï¼Œç›¸åŠ ä¼šæº¢å‡º minDist[v] = minDist[cur] + grid[cur][v]; //æ¯æ‰¾åˆ°ä¸€ä¸ªç¦»èµ·å§‹ç‚¹æœ€è¿‘çš„ä¸”æœªè¢«è®¿é—®è¿‡çš„ç‚¹ï¼Œéƒ½è¦æ›´æ–°ä¸€ä¸‹ï¼Œä»¥æ£€æŸ¥è¿™ä¸ªç‚¹æ˜¯å¦ä¼šæˆä¸ºå…¶å®ƒç‚¹æœ€çŸ­è·¯å¾„çš„å…¶ä¸­ä¸€ä¸ªç‚¹ } } } if (minDist[end] == INT_MAX) cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; // ä¸èƒ½åˆ°è¾¾ç»ˆç‚¹ else cout \u0026lt;\u0026lt; minDist[end] \u0026lt;\u0026lt; endl; // åˆ°è¾¾ç»ˆç‚¹æœ€çŸ­è·¯å¾„ } å¦‚æœé¢˜ç›®è¦æ±‚æŠŠæœ€çŸ­è·¯çš„è·¯å¾„æ‰“å°å‡ºæ¥ï¼Œåˆ™éœ€è¦parentæ•°ç»„è®°å½•æ¯æ¬¡é€‰å–çš„curèŠ‚ç‚¹\nfor (int v = 1; v \u0026lt;= n; v++) { if (!visited[v] \u0026amp;\u0026amp; grid[cur][v] != INT_MAX \u0026amp;\u0026amp; minDist[cur] + grid[cur][v] \u0026lt; minDist[v]) { minDist[v] = minDist[cur] + grid[cur][v]; parent[v] = cur; // è®°å½•è¾¹ï¼Œåˆå§‹åŒ–ä¸º vector\u0026lt;int\u0026gt; parent(n + 1, -1); } } ç†è§£ï¼š\næ¯æ¬¡éƒ½åœ¨æ‰¾ç¦»èµ·å§‹ç‚¹æœ€è¿‘çš„æœªè¢«è®¿é—®ç‚¹ï¼Œä¸æ–­æ›´æ–°å…¶ä»–çš„ç‚¹ç¦»èµ·å§‹ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œå½“æ‰¾ä¸åˆ°æ‰¾ç¦»èµ·å§‹ç‚¹æœ€è¿‘çš„æœªè¢«è®¿é—®ç‚¹ï¼Œç¨‹åºç»“æŸã€‚\nå…¶ä¸primç®—æ³•çš„åŒºåˆ«æ˜¯ï¼šprimæ˜¯æ±‚ éè®¿é—®èŠ‚ç‚¹åˆ°æœ€å°ç”Ÿæˆæ ‘çš„æœ€å°è·ç¦»ï¼Œè€Œdijkstraæ˜¯æ±‚ éè®¿é—®èŠ‚ç‚¹åˆ°èµ·å§‹ç‚¹çš„æœ€å°è·ç¦»\nPrimç®—æ³•å’ŒDijkstraç®—æ³•çš„åŒºåˆ« # ç‰¹æ€§ Primç®—æ³• Dijkstraç®—æ³• ç›®æ ‡ æ‰¾åˆ°ä¸€ä¸ªå›¾çš„æœ€å°ç”Ÿæˆæ ‘ï¼ˆMinimum Spanning Tree, MSTï¼‰ æ‰¾åˆ°ä»ä¸€ä¸ªèµ·å§‹ç‚¹åˆ°å…¶ä»–æ‰€æœ‰ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼ˆShortest Pathï¼‰ é€‚ç”¨åœºæ™¯ é€‚ç”¨äºæ— å‘å›¾ï¼ˆé€šå¸¸ç”¨äºè¿é€šå›¾ï¼‰ é€‚ç”¨äºæœ‰å‘å›¾æˆ–æ— å‘å›¾ï¼ˆé€šå¸¸ç”¨äºå¸¦æƒå›¾ï¼‰ æƒå€¼å¤„ç† æƒå€¼å¯ä»¥æ˜¯ä»»æ„å€¼ï¼ˆåŒ…æ‹¬è´Ÿæƒå€¼ï¼‰ï¼Œå› ä¸ºåªå…³å¿ƒè¾¹çš„æ€»æƒé‡æœ€å° ä¸èƒ½å¤„ç†è´Ÿæƒè¾¹ï¼Œå¦åˆ™å¯èƒ½å¯¼è‡´é”™è¯¯ç»“æœ ç»“æœ ç”Ÿæˆä¸€æ£µæ ‘ï¼Œè¿æ¥æ‰€æœ‰èŠ‚ç‚¹ä¸”æ€»æƒé‡æœ€å° ç”Ÿæˆä¸€ä¸ªæœ€çŸ­è·¯å¾„æ ‘ï¼Œè¡¨ç¤ºä»èµ·ç‚¹åˆ°å…¶ä»–èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ Floyd(ä»£ç éšæƒ³å½•) # é¢˜ç›®æè¿°\nå°æ˜å–œæ¬¢å»å…¬å›­æ•£æ­¥ï¼Œå…¬å›­å†…å¸ƒç½®äº†è®¸å¤šçš„æ™¯ç‚¹ï¼Œç›¸äº’ä¹‹é—´é€šè¿‡å°è·¯è¿æ¥ï¼Œå°æ˜å¸Œæœ›åœ¨è§‚çœ‹æ™¯ç‚¹çš„åŒæ—¶ï¼Œèƒ½å¤ŸèŠ‚çœä½“åŠ›ï¼Œèµ°æœ€çŸ­çš„è·¯å¾„ã€‚\nç»™å®šä¸€ä¸ªå…¬å›­æ™¯ç‚¹å›¾ï¼Œå›¾ä¸­æœ‰ N ä¸ªæ™¯ç‚¹ï¼ˆç¼–å·ä¸º 1 åˆ° Nï¼‰ï¼Œä»¥åŠ M æ¡åŒå‘é“è·¯è¿æ¥ç€è¿™äº›æ™¯ç‚¹ã€‚æ¯æ¡é“è·¯ä¸Šè¡Œèµ°çš„è·ç¦»éƒ½æ˜¯å·²çŸ¥çš„ã€‚\nå°æ˜æœ‰ Q ä¸ªè§‚æ™¯è®¡åˆ’ï¼Œæ¯ä¸ªè®¡åˆ’éƒ½æœ‰ä¸€ä¸ªèµ·ç‚¹ start å’Œä¸€ä¸ªç»ˆç‚¹ endï¼Œè¡¨ç¤ºä»–æƒ³ä»æ™¯ç‚¹ start å‰å¾€æ™¯ç‚¹ endã€‚ç”±äºå°æ˜å¸Œæœ›èŠ‚çœä½“åŠ›ï¼Œä»–æƒ³çŸ¥é“æ¯ä¸ªè§‚æ™¯è®¡åˆ’ä¸­ä»èµ·ç‚¹åˆ°ç»ˆç‚¹çš„æœ€çŸ­è·¯å¾„é•¿åº¦ã€‚ è¯·ä½ å¸®åŠ©å°æ˜è®¡ç®—å‡ºæ¯ä¸ªè§‚æ™¯è®¡åˆ’çš„æœ€çŸ­è·¯å¾„é•¿åº¦ã€‚\nè¾“å…¥æè¿°\nç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° N, M, åˆ†åˆ«è¡¨ç¤ºæ™¯ç‚¹çš„æ•°é‡å’Œé“è·¯çš„æ•°é‡ã€‚\næ¥ä¸‹æ¥çš„ M è¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸‰ä¸ªæ•´æ•° u, v, wï¼Œè¡¨ç¤ºæ™¯ç‚¹ u å’Œæ™¯ç‚¹ v ä¹‹é—´æœ‰ä¸€æ¡é•¿åº¦ä¸º w çš„åŒå‘é“è·¯ã€‚\næ¥ä¸‹é‡Œçš„ä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•° Qï¼Œè¡¨ç¤ºè§‚æ™¯è®¡åˆ’çš„æ•°é‡ã€‚\næ¥ä¸‹æ¥çš„ Q è¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° start, endï¼Œè¡¨ç¤ºä¸€ä¸ªè§‚æ™¯è®¡åˆ’çš„èµ·ç‚¹å’Œç»ˆç‚¹ã€‚\nè¾“å‡ºæè¿°\nå¯¹äºæ¯ä¸ªè§‚æ™¯è®¡åˆ’ï¼Œè¾“å‡ºä¸€è¡Œè¡¨ç¤ºä»èµ·ç‚¹åˆ°ç»ˆç‚¹çš„æœ€çŸ­è·¯å¾„é•¿åº¦ã€‚å¦‚æœä¸¤ä¸ªæ™¯ç‚¹ä¹‹é—´ä¸å­˜åœ¨è·¯å¾„ï¼Œåˆ™è¾“å‡º -1ã€‚\nã€è¾“å…¥ç¤ºä¾‹ã€‘\n7 3\n1 2 4\n2 5 6\n3 6 8\n2\n1 2\n2 3\nã€è¾“å‡ºç¤ºä¾‹ã€‘\n4\n-1\nã€æç¤ºä¿¡æ¯ã€‘\nä» 1 åˆ° 2 çš„è·¯å¾„é•¿åº¦ä¸º 4ï¼Œ2 åˆ° 3 ä¹‹é—´å¹¶æ²¡æœ‰é“è·¯ã€‚\n1 \u0026lt;= N, M, Q \u0026lt;= 1000.\nå®è´¨ä¸Šæ˜¯åŠ¨æ€è§„åˆ’\ngrid[i][j][k] = mï¼Œè¡¨ç¤ºèŠ‚ç‚¹iåˆ°èŠ‚ç‚¹jä»¥[1...k] é›†åˆä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹ä¸ºä¸­é—´èŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»ä¸ºmã€‚\nçŠ¶æ€è½¬ç§»æ–¹ç¨‹åˆ†ä¸¤ç§æƒ…å†µï¼š\nèŠ‚ç‚¹iåˆ°èŠ‚ç‚¹jçš„æœ€çŸ­è·¯å¾„ç»è¿‡èŠ‚ç‚¹k èŠ‚ç‚¹i åˆ°èŠ‚ç‚¹jçš„æœ€çŸ­è·¯å¾„ä¸ç»è¿‡èŠ‚ç‚¹k ç¬¬ä¸€ç§æƒ…å†µï¼Œgrid[i][j][k] = grid[i][k][k - 1] + grid[k][j][k - 1]\nèŠ‚ç‚¹i åˆ° èŠ‚ç‚¹k çš„æœ€çŸ­è·ç¦» æ˜¯ä¸ç»è¿‡èŠ‚ç‚¹kï¼Œä¸­é—´èŠ‚ç‚¹é›†åˆä¸º[1\u0026hellip;k-1]ï¼Œæ‰€ä»¥ è¡¨ç¤ºä¸ºgrid[i][k][k - 1]\nèŠ‚ç‚¹k åˆ° èŠ‚ç‚¹j çš„æœ€çŸ­è·ç¦» ä¹Ÿæ˜¯ä¸ç»è¿‡èŠ‚ç‚¹kï¼Œä¸­é—´èŠ‚ç‚¹é›†åˆä¸º[1\u0026hellip;k-1]ï¼Œæ‰€ä»¥è¡¨ç¤ºä¸º grid[k][j][k - 1]\nç¬¬äºŒç§æƒ…å†µï¼Œgrid[i][j][k] = grid[i][j][k - 1]\nå¦‚æœèŠ‚ç‚¹i åˆ° èŠ‚ç‚¹jçš„æœ€çŸ­è·ç¦» ä¸ç»è¿‡èŠ‚ç‚¹kï¼Œé‚£ä¹ˆ ä¸­é—´èŠ‚ç‚¹é›†åˆ[1\u0026hellip;k-1]ï¼Œè¡¨ç¤ºä¸º grid[i][j][k - 1]\nå› ä¸ºæˆ‘ä»¬æ˜¯æ±‚æœ€çŸ­è·¯ï¼Œå¯¹äºè¿™ä¸¤ç§æƒ…å†µè‡ªç„¶æ˜¯å–æœ€å°å€¼ã€‚\nå³ï¼š grid[i][j][k] = min(grid[i][k][k - 1] + grid[k][j][k - 1]ï¼Œ grid[i][j][k - 1])\nå¯¹äºç†è§£è¿™ä¸ªåŠ¨æ€è½¬ç§»æ–¹ç¨‹ï¼Œå¯ä»¥æ‰‹ç®—æ¨æ¼”ä¸€ä¸‹ #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;list\u0026gt; using namespace std; int main() { int n, m, p1, p2, val; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; grid(n + 1, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(n + 1, vector\u0026lt;int\u0026gt;(n + 1, 10005))); // å› ä¸ºè¾¹çš„æœ€å¤§è·ç¦»æ˜¯10^4 for(int i = 0; i \u0026lt; m; i++){ cin \u0026gt;\u0026gt; p1 \u0026gt;\u0026gt; p2 \u0026gt;\u0026gt; val; grid[p1][p2][0] = val; grid[p2][p1][0] = val; // æ³¨æ„è¿™é‡Œæ˜¯åŒå‘å›¾ } // å¼€å§‹ floyd for (int k = 1; k \u0026lt;= n; k++) { for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { grid[i][j][k] = min(grid[i][j][k-1], grid[i][k][k-1] + grid[k][j][k-1]); } } } // è¾“å‡ºç»“æœ int z, start, end; cin \u0026gt;\u0026gt; z; while (z--) { cin \u0026gt;\u0026gt; start \u0026gt;\u0026gt; end; if (grid[start][end][n] == 10005) cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; grid[start][end][n] \u0026lt;\u0026lt; endl; } } ","date":"30 March 2025","externalUrl":null,"permalink":"/posts/algorithm/%E5%9B%BE%E8%AE%BA-2/","section":"Posts","summary":"","title":"å›¾è®º-2","type":"posts"},{"content":"","date":"30 March 2025","externalUrl":null,"permalink":"/categories/","section":"æ–‡ç« åˆ†ç±»","summary":"","title":"æ–‡ç« åˆ†ç±»","type":"categories"},{"content":" å›¾è®º-1ï¼ˆprim\u0026amp;kruskalï¼‰ # æœ¬ç³»åˆ—çš„å¤§éƒ¨åˆ†éƒ½æ˜¯å¯¹labuladongå’Œä»£ç éšæƒ³å½•ç½‘ç«™çš„é¢˜ç›®çš„ç»ƒæ‰‹æ±‡æ€»(éƒ¨åˆ†æ˜¯åšä¸»è‡ªå·±ç»“åˆleetcodeå’Œæ´›è°·é¢˜ç›®çš„è¡¥å……ï¼‰åˆè¡·æ˜¯åšä¸»è‡ªç”¨å­¦ä¹ å“’!\nè¯·æ‰€æœ‰é˜…è¯»è¿™ç³»åˆ—åšå®¢çš„å‹å‹å…ˆç§»æ­¥é˜…è§ˆä»–ä»¬çš„ç½‘ç«™ï¼Œæ²¡æœ‰è¿™äº›ä¼˜ç§€ç½‘ç«™çš„åˆ†äº«ä¸ä¼šæœ‰è¿™ç³»åˆ—çš„æ–‡ç« ï¼Œæˆ‘åªæ˜¯çŸ¥è¯†çš„æ¬è¿å·¥ï¼\nâ€œprim ç®—æ³•æ˜¯ç»´æŠ¤èŠ‚ç‚¹çš„é›†åˆï¼Œè€Œ Kruskal æ˜¯ç»´æŠ¤è¾¹çš„é›†åˆã€‚â€\nprimä¸‰éƒ¨æ›²(ä»£ç éšæƒ³å½•) # primç®—æ³•æ˜¯ä»èŠ‚ç‚¹çš„è§’åº¦é‡‡ç”¨è´ªå¿ƒçš„ç­–ç•¥æ¯æ¬¡å¯»æ‰¾è·ç¦»æœ€å°ç”Ÿæˆæ ‘æœ€è¿‘çš„èŠ‚ç‚¹å¹¶åŠ å…¥åˆ°æœ€å°ç”Ÿæˆæ ‘ä¸­ã€‚\nç¬¬ä¸€æ­¥ï¼Œé€‰è·ç¦»ç”Ÿæˆæ ‘æœ€è¿‘èŠ‚ç‚¹ ï¼ˆè¿™é‡Œçš„ç”Ÿæˆæ ‘èŠ‚ç‚¹éšä¾¿å“ªä¸ªèŠ‚ç‚¹éƒ½è¡Œï¼‰ ç¬¬äºŒæ­¥ï¼Œæœ€è¿‘èŠ‚ç‚¹åŠ å…¥ç”Ÿæˆæ ‘ ç¬¬ä¸‰æ­¥ï¼Œæ›´æ–°éç”Ÿæˆæ ‘èŠ‚ç‚¹åˆ°ç”Ÿæˆæ ‘çš„è·ç¦»ï¼ˆå³æ›´æ–°minDistæ•°ç»„ï¼‰ minDistæ•°ç»„ç”¨æ¥è®°å½•æ¯ä¸€ä¸ªèŠ‚ç‚¹è·ç¦»æœ€å°ç”Ÿæˆæ ‘çš„æœ€è¿‘è·ç¦»\nä¾‹é¢˜\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include \u0026lt;climits\u0026gt; using namespace std; int main() { int v, e; int x, y, k; cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; e; // å¡«ä¸€ä¸ªé»˜è®¤æœ€å¤§å€¼ï¼Œé¢˜ç›®æè¿°valæœ€å¤§ä¸º10000 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; grid(v + 1, vector\u0026lt;int\u0026gt;(v + 1, 10001)); while (e--) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; k; // å› ä¸ºæ˜¯åŒå‘å›¾ï¼Œæ‰€ä»¥ä¸¤ä¸ªæ–¹å‘éƒ½è¦å¡«ä¸Š grid[x][y] = k; grid[y][x] = k; } // æ‰€æœ‰èŠ‚ç‚¹åˆ°æœ€å°ç”Ÿæˆæ ‘çš„æœ€å°è·ç¦» vector\u0026lt;int\u0026gt; minDist(v + 1, 10001); // è¿™ä¸ªèŠ‚ç‚¹æ˜¯å¦åœ¨æ ‘é‡Œ vector\u0026lt;bool\u0026gt; isInTree(v + 1, false); // æˆ‘ä»¬åªéœ€è¦å¾ªç¯ n-1æ¬¡ï¼Œå»ºç«‹ n - 1æ¡è¾¹ï¼Œå°±å¯ä»¥æŠŠnä¸ªèŠ‚ç‚¹çš„å›¾è¿åœ¨ä¸€èµ· for (int i = 1; i \u0026lt; v; i++) { // 1ã€primä¸‰éƒ¨æ›²ï¼Œç¬¬ä¸€æ­¥ï¼šé€‰è·ç¦»ç”Ÿæˆæ ‘æœ€è¿‘èŠ‚ç‚¹ int cur = -1; // é€‰ä¸­å“ªä¸ªèŠ‚ç‚¹ åŠ å…¥æœ€å°ç”Ÿæˆæ ‘ int minVal = INT_MAX; for (int j = 1; j \u0026lt;= v; j++) { // é€‰å–æœ€å°ç”Ÿæˆæ ‘èŠ‚ç‚¹çš„æ¡ä»¶ï¼š // ï¼ˆ1ï¼‰ä¸åœ¨æœ€å°ç”Ÿæˆæ ‘é‡Œ // ï¼ˆ2ï¼‰è·ç¦»æœ€å°ç”Ÿæˆæ ‘æœ€è¿‘çš„èŠ‚ç‚¹ if (!isInTree[j] \u0026amp;\u0026amp; minDist[j] \u0026lt; minVal) {//éå†éç”Ÿæˆæ ‘çš„å›¾ï¼ŒminValç»´æŠ¤æœ€å°æƒå€¼ minVal = minDist[j]; cur = j; } } // 2ã€primä¸‰éƒ¨æ›²ï¼Œç¬¬äºŒæ­¥ï¼šæœ€è¿‘èŠ‚ç‚¹ï¼ˆcurï¼‰åŠ å…¥ç”Ÿæˆæ ‘ isInTree[cur] = true; // 3ã€primä¸‰éƒ¨æ›²ï¼Œç¬¬ä¸‰æ­¥ï¼šæ›´æ–°éç”Ÿæˆæ ‘èŠ‚ç‚¹åˆ°ç”Ÿæˆæ ‘çš„è·ç¦»ï¼ˆå³æ›´æ–°minDistæ•°ç»„ï¼‰ // ç”±äºcurèŠ‚ç‚¹æ˜¯æ–°åŠ å…¥åˆ°æœ€å°ç”Ÿæˆæ ‘ï¼Œé‚£ä¹ˆåªéœ€è¦å…³å¿ƒä¸ cur ç›¸è¿çš„ éç”Ÿæˆæ ‘èŠ‚ç‚¹ çš„è·ç¦» æ˜¯å¦æ¯” åŸæ¥ éç”Ÿæˆæ ‘èŠ‚ç‚¹åˆ°ç”Ÿæˆæ ‘èŠ‚ç‚¹çš„è·ç¦»æ›´å°å°±èƒ½å§‹ç»ˆç»´æŠ¤éç”Ÿæˆæ ‘èŠ‚ç‚¹åˆ°æ ‘çš„æœ€å°è·ç¦» for (int j = 1; j \u0026lt;= v; j++) { if (!isInTree[j] \u0026amp;\u0026amp; grid[cur][j] \u0026lt; minDist[j]) {//æ³¨æ„ç†è§£ï¼Œgrid[cur][j] \u0026lt; minDist[j]ï¼Œcurçš„åŠ å…¥æ˜¯å¦æ”¹å˜äº†jåˆ°æ ‘çš„æœ€å°è·ç¦»ï¼Œè‹¥æœ‰åˆ™æ›´æ–°ã€‚ minDist[j] = grid[cur][j]; } } } // ç»Ÿè®¡ç»“æœ int result = 0; for (int i = 2; i \u0026lt;= v; i++) { // ä¸è®¡ç¬¬ä¸€ä¸ªé¡¶ç‚¹ï¼Œå› ä¸ºç»Ÿè®¡çš„æ˜¯è¾¹çš„æƒå€¼ï¼Œvä¸ªèŠ‚ç‚¹æœ‰ v-1æ¡è¾¹ result += minDist[i]; } cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; } kruskalæ€è·¯ï¼ˆä»£ç éšæƒ³å½•ï¼‰ # è¾¹çš„æƒå€¼æ’åºï¼Œå› ä¸ºè¦ä¼˜å…ˆé€‰æœ€å°çš„è¾¹åŠ å…¥åˆ°ç”Ÿæˆæ ‘é‡Œ\néå†æ’åºåçš„è¾¹\nå¦‚æœè¾¹é¦–å°¾çš„ä¸¤ä¸ªèŠ‚ç‚¹åœ¨åŒä¸€ä¸ªé›†åˆï¼Œè¯´æ˜å¦‚æœè¿ä¸Šè¿™æ¡è¾¹å›¾ä¸­ä¼šå‡ºç°ç¯\nå¦‚æœè¾¹é¦–å°¾çš„ä¸¤ä¸ªèŠ‚ç‚¹ä¸åœ¨åŒä¸€ä¸ªé›†åˆï¼ŒåŠ å…¥åˆ°æœ€å°ç”Ÿæˆæ ‘ï¼Œå¹¶æŠŠä¸¤ä¸ªèŠ‚ç‚¹åŠ å…¥åŒä¸€ä¸ªé›†åˆ\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; // l,rä¸º è¾¹ä¸¤è¾¹çš„èŠ‚ç‚¹ï¼Œvalä¸ºè¾¹çš„æ•°å€¼ struct Edge { int l, r, val; }; // èŠ‚ç‚¹æ•°é‡ int n = 10001; // å¹¶æŸ¥é›†æ ‡è®°èŠ‚ç‚¹å…³ç³»çš„æ•°ç»„ vector\u0026lt;int\u0026gt; father(n, -1); // èŠ‚ç‚¹ç¼–å·æ˜¯ä»1å¼€å§‹çš„ï¼Œnè¦å¤§ä¸€äº› // å¹¶æŸ¥é›†åˆå§‹åŒ– void init() { for (int i = 0; i \u0026lt; n; ++i) { father[i] = i; } } // å¹¶æŸ¥é›†çš„æŸ¥æ‰¾æ“ä½œ int find(int u) { return u == father[u] ? u : father[u] = find(father[u]); // è·¯å¾„å‹ç¼© } // å¹¶æŸ¥é›†çš„åŠ å…¥é›†åˆ void join(int u, int v) { u = find(u); // å¯»æ‰¾uçš„æ ¹ v = find(v); // å¯»æ‰¾vçš„æ ¹ if (u == v) return ; // å¦‚æœå‘ç°æ ¹ç›¸åŒï¼Œåˆ™è¯´æ˜åœ¨ä¸€ä¸ªé›†åˆï¼Œä¸ç”¨ä¸¤ä¸ªèŠ‚ç‚¹ç›¸è¿ç›´æ¥è¿”å› father[v] = u; } int main() { int v, e; int v1, v2, val; vector\u0026lt;Edge\u0026gt; edges; //ä¸åŒç‚¹ int result_val = 0; cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; e; while (e--) { cin \u0026gt;\u0026gt; v1 \u0026gt;\u0026gt; v2 \u0026gt;\u0026gt; val; edges.push_back({v1, v2, val}); } // æ‰§è¡ŒKruskalç®—æ³• // æŒ‰è¾¹çš„æƒå€¼å¯¹è¾¹è¿›è¡Œä»å°åˆ°å¤§æ’åº sort(edges.begin(), edges.end(), [](const Edge\u0026amp; a, const Edge\u0026amp; b) { return a.val \u0026lt; b.val; }//åŒ¿åå‡½æ•° //ä½¿ç”¨å¼•ç”¨ï¼ˆ\u0026amp;ï¼‰å¯ä»¥é¿å…æ‹·è´ï¼Œç›´æ¥æ“ä½œåŸå§‹å¯¹è±¡ã€‚ //ä½¿ç”¨consté˜²æ­¢æ„å¤–ä¿®æ”¹ ); // å¹¶æŸ¥é›†åˆå§‹åŒ– init(); // ä»å¤´å¼€å§‹éå†è¾¹ for (Edge edge : edges) { // å¹¶æŸ¥é›†ï¼Œæœå‡ºä¸¤ä¸ªèŠ‚ç‚¹çš„ç¥–å…ˆ int x = find(edge.l); int y = find(edge.r); // å¦‚æœç¥–å…ˆä¸åŒï¼Œåˆ™ä¸åœ¨åŒä¸€ä¸ªé›†åˆ if (x != y) { result_val += edge.val; // è¿™æ¡è¾¹å¯ä»¥ä½œä¸ºç”Ÿæˆæ ‘çš„è¾¹ join(x, y); // ä¸¤ä¸ªèŠ‚ç‚¹åŠ å…¥åˆ°åŒä¸€ä¸ªé›†åˆ } } cout \u0026lt;\u0026lt; result_val \u0026lt;\u0026lt; endl; return 0; } ","date":"30 March 2025","externalUrl":null,"permalink":"/posts/algorithm/%E5%9B%BE%E8%AE%BA-1/","section":"Posts","summary":"","title":"å›¾è®º-1","type":"posts"},{"content":" 54461. æœ€å¤§åŒºé—´ # é—®é¢˜æè¿° # ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º nçš„åºåˆ— Aiï¼Œæ±‚ L,R ä½¿ (Râˆ’L+1)â‹…minâ¡(AL,AL+1,â€¦,AR) å°½å¯èƒ½å¤§ï¼Œå…¶ä¸­ minâ¡ è¡¨ç¤ºæœ€å°å€¼ã€‚\nä½ åªéœ€è¦è¾“å‡ºæœ€å¤§çš„å€¼å³å¯ï¼Œä¸éœ€è¦è¾“å‡ºå…·ä½“çš„ L,Rã€‚\nè¾“å…¥æ ¼å¼ # è¾“å…¥çš„ç¬¬ä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•° nã€‚\nç¬¬äºŒè¡ŒåŒ…å« nä¸ªæ•´æ•°ï¼Œåˆ†åˆ«è¡¨ç¤º A1,A2,â€¦,Anç›¸é‚»ä¸¤ä¸ªæ•´æ•°ä¹‹é—´ä½¿ç”¨ä¸€ä¸ªç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡ºæ ¼å¼ # è¾“å‡ºä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•°è¡¨ç¤ºç­”æ¡ˆã€‚\næ ·ä¾‹è¾“å…¥ # 5 1 1 3 3 1 æ ·ä¾‹è¾“å‡º # 6 å¯¹äº 40%è¯„æµ‹ç”¨ä¾‹ï¼Œ1â‰¤nâ‰¤5000ï¼Œ1â‰¤Aiâ‰¤5000ï¼›\nå¯¹äºæ‰€æœ‰è¯„æµ‹ç”¨ä¾‹ï¼Œ1â‰¤nâ‰¤3Ã—10^5ï¼Œ 1â‰¤Aiâ‰¤10^9ã€‚\nACä»£ç  # #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; int main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; nums(n, 0); for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; stack\u0026lt;ll\u0026gt; st; vector\u0026lt;ll\u0026gt; left(n, -1); // å·¦è¾¹ç¬¬ä¸€ä¸ªæ¯”å®ƒå°çš„å…ƒç´ çš„ä½ç½® vector\u0026lt;ll\u0026gt; right(n, n); // å³è¾¹ç¬¬ä¸€ä¸ªæ¯”å®ƒå°çš„å…ƒç´ çš„ä½ç½® // è®¡ç®— left for (int i = 0; i \u0026lt; n; i++) { while (!st.empty() \u0026amp;\u0026amp; nums[i] \u0026lt; nums[st.top()]) { right[st.top()] = i; st.pop(); } left[i] = st.empty() ? -1 : st.top(); //å› ä¸ºæ­¤æ—¶topåœåœ¨çš„åœ°æ–¹å°±æ˜¯å·¦è¾¹ç¦»nums[i]æœ€è¿‘çš„å¤§äºç­‰äºå…¶çš„ç´¢å¼• st.push(i); } // è®¡ç®— maxlen vector\u0026lt;ll\u0026gt; maxlen(n, 1); for (int i = 0; i \u0026lt; n; i++) { maxlen[i] = right[i] - left[i] - 1; } // è®¡ç®—ç»“æœ ll res = 0; for (int i = 0; i \u0026lt; n; i++) { res = max(res, maxlen[i] * nums[i]); } cout \u0026lt;\u0026lt; res; return 0; } 48976.å¹¶çŸ³å­ # é—®é¢˜æè¿° # åœ¨æ¡Œé¢ä»å·¦è‡³å³æ¨ªå‘æ‘†æ”¾ç€ Nå †çŸ³å­ã€‚æ¯ä¸€å †çŸ³å­éƒ½æœ‰ç€ç›¸åŒçš„é¢œè‰²ï¼Œé¢œè‰²å¯èƒ½æ˜¯é¢œè‰² 0ï¼Œé¢œè‰² 1 æˆ–è€…é¢œè‰² 2 ä¸­çš„å…¶ä¸­ä¸€ç§ã€‚\nç°åœ¨è¦å¯¹çŸ³å­è¿›è¡Œåˆå¹¶ï¼Œè§„å®šæ¯æ¬¡åªèƒ½é€‰æ‹©ä½ç½®ç›¸é‚»å¹¶ä¸”é¢œè‰²ç›¸åŒçš„ä¸¤å †çŸ³å­è¿›è¡Œåˆå¹¶ã€‚åˆå¹¶åæ–°å †çš„ç›¸å¯¹ä½ç½®ä¿æŒä¸å˜ï¼Œæ–°å †çš„çŸ³å­æ•°ç›®ä¸ºæ‰€é€‰æ‹©çš„ä¸¤å †çŸ³å­æ•°ç›®ä¹‹å’Œï¼Œå¹¶ä¸”æ–°å †çŸ³å­çš„é¢œè‰²ä¹Ÿä¼šå‘ç”Ÿå¾ªç¯å¼çš„å˜åŒ–ã€‚\nå…·ä½“æ¥è¯´ï¼šä¸¤å †é¢œè‰² 0çš„çŸ³å­åˆå¹¶åçš„çŸ³å­å †ä¸ºé¢œè‰² 1ï¼Œä¸¤å †é¢œè‰² 1çš„çŸ³å­åˆå¹¶åçš„çŸ³å­å †ä¸ºé¢œè‰² 2ï¼Œä¸¤å †é¢œè‰² 2çš„çŸ³å­åˆå¹¶åçš„çŸ³å­å †ä¸ºé¢œè‰² 0ã€‚æœ¬æ¬¡åˆå¹¶çš„èŠ±è´¹ä¸ºæ‰€é€‰æ‹©çš„ä¸¤å †çŸ³å­çš„æ•°ç›®ä¹‹å’Œã€‚\nç»™å‡ºNå †çŸ³å­ä»¥åŠä»–ä»¬çš„åˆå§‹é¢œè‰²ï¼Œè¯·é—®æœ€å°‘å¯ä»¥å°†å®ƒä»¬åˆå¹¶ä¸ºå¤šå°‘å †çŸ³å­ï¼Ÿå¦‚æœæœ‰å¤šç§ç­”æ¡ˆï¼Œé€‰æ‹©å…¶ä¸­åˆå¹¶æ€»èŠ±è´¹æœ€å°çš„ä¸€ç§ï¼Œåˆå¹¶æ€»èŠ±è´¹æŒ‡çš„æ˜¯åœ¨æ‰€æœ‰çš„åˆå¹¶æ“ä½œä¸­äº§ç”Ÿçš„åˆå¹¶èŠ±è´¹çš„æ€»å’Œã€‚\nè¾“å…¥æ ¼å¼ # ç¬¬ä¸€è¡Œä¸€ä¸ªæ­£æ•´æ•°Nè¡¨ç¤ºçŸ³å­å †æ•°ã€‚\nç¬¬äºŒè¡ŒåŒ…å«Nä¸ªç”¨ç©ºæ ¼åˆ†éš”çš„æ­£æ•´æ•°ï¼Œè¡¨ç¤ºä»å·¦è‡³å³æ¯ä¸€å †çŸ³å­çš„æ•°ç›®ã€‚\nç¬¬ä¸‰è¡ŒåŒ…å« Nä¸ªå€¼ä¸º 0 æˆ– 1 æˆ– 2 çš„æ•´æ•°è¡¨ç¤ºæ¯å †çŸ³å¤´çš„é¢œè‰²ã€‚\nè¾“å‡ºæ ¼å¼ # ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•°ï¼Œç”¨ç©ºæ ¼åˆ†éš”ã€‚å…¶ä¸­ç¬¬ä¸€ä¸ªæ•´æ•°è¡¨ç¤ºåˆå¹¶åæ•°ç›®æœ€å°‘çš„çŸ³å¤´å †æ•°ï¼Œç¬¬äºŒä¸ªæ•´æ•°è¡¨ç¤ºå¯¹åº”çš„æœ€å°èŠ±è´¹ã€‚\næ ·ä¾‹è¾“å…¥ # 5 5 10 1 8 6 1 1 0 2 2 æ ·ä¾‹è¾“å‡º # 2 44 æ ·ä¾‹è¯´æ˜ # ä¸Šå›¾æ˜¾ç¤ºäº†ä¸¤ç§ä¸åŒçš„åˆå¹¶æ–¹å¼ã€‚å…¶ä¸­èŠ‚ç‚¹ä¸­æ ‡æ˜äº†æ¯ä¸€å †çš„çŸ³å­æ•°ç›®ï¼Œ åœ¨æ–¹æ‹¬å·ä¸­æ ‡æ³¨äº†å½“å‰å †çŸ³å­çš„é¢œè‰²å±æ€§ã€‚å·¦å›¾çš„è¿™ç§åˆå¹¶æ–¹å¼æœ€ç»ˆå‰©ä¸‹äº†ä¸¤å †çŸ³å­ï¼Œæ‰€äº§ç”Ÿçš„åˆå¹¶æ€»èŠ±è´¹ä¸º 15+14+15=44ï¼›å³å›¾çš„è¿™ç§åˆå¹¶æ–¹å¼æœ€ç»ˆä¹Ÿå‰©ä¸‹äº†ä¸¤å †çŸ³å­ï¼Œä½†äº§ç”Ÿçš„åˆå¹¶æ€»èŠ±è´¹ä¸º 14+15+25=54ã€‚ç»¼ä¸Šæ‰€è¿°ï¼Œæˆ‘ä»¬é€‰æ‹©åˆå¹¶èŠ±è´¹ä¸º 44 çš„è¿™ç§æ–¹å¼ä½œä¸ºç­”æ¡ˆã€‚\nå¯¹äº 30% çš„è¯„æµ‹ç”¨ä¾‹ï¼Œ1â‰¤Nâ‰¤10ã€‚\nå¯¹äº 50% çš„è¯„æµ‹ç”¨ä¾‹ï¼Œ1â‰¤Nâ‰¤50ã€‚\nå¯¹äº 100% çš„è¯„æµ‹ç”¨ä¾‹ï¼Œ1â‰¤Nâ‰¤300,1â‰¤ æ¯å †çŸ³å­çš„æ•°ç›® â‰¤1000ã€‚\nå®˜æ–¹é¢˜è§£ # //cpp #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 303; const int inf = 1e9 + 5; int n, ans, dp[maxn][maxn][3], num[maxn][maxn], a[maxn], sum[maxn], c[maxn], cost[maxn][maxn]; int read() { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); return x; } void solve() { n = read(); for (int i = 1; i \u0026lt;= n; i++) { for (int j = i; j \u0026lt;= n; j++) { num[i][j] = j - i + 1; for (int k = 0; k \u0026lt; 3; k++) { dp[i][j][k] = inf; } } } for (int i = 1; i \u0026lt;= n; i++) { a[i] = read(); sum[i] = a[i] + sum[i - 1]; } for (int i = 1; i \u0026lt;= n; i++) { c[i] = read(); dp[i][i][c[i]] = 0; } for (int len = 1; len \u0026lt;= n; len++) { for (int i = 1; i + len - 1 \u0026lt;= n; i++) { int j = i + len - 1; for (int col = 0; col \u0026lt; 3; col++) { int minn = inf; for (int k = i; k \u0026lt; j; k++) { if (dp[i][k][col] != inf \u0026amp;\u0026amp; dp[k + 1][j][col] != inf) { minn = min(minn, dp[i][k][col] + dp[k + 1][j][col]); } } if (minn == inf) { continue; } num[i][j] = 1; dp[i][j][(col + 1) % 3] = min(dp[i][j][(col + 1) % 3], minn + sum[j] - sum[i - 1]); } } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = i; j \u0026lt;= n; j++) { if (num[i][j] == 1) { cost[i][j] = min(dp[i][j][0], min(dp[i][j][1], dp[i][j][2])); } } } for (int k = 1; k \u0026lt;= n; k++) { for (int i = 1; i \u0026lt;= k; i++) { for (int j = k + 1; j \u0026lt;= n; j++) { if (num[i][j] \u0026gt; num[i][k] + num[k + 1][j]) { num[i][j] = num[i][k] + num[k + 1][j]; cost[i][j] = cost[i][k] + cost[k + 1][j]; } else if (num[i][j] == num[i][k] + num[k + 1][j]) { cost[i][j] = min(cost[i][j], cost[i][k] + cost[k + 1][j]); } } } } printf(\u0026#34;%d %d\\n\u0026#34;, num[1][n], cost[1][n]); } int main() { solve(); return 0; } 48978.é­”æ³•é˜µ # é—®é¢˜æè¿° # æ ·ä¾‹è¾“å…¥ # 1 4 2 3 0 1 2 1 2 1 2 3 4\næ ·ä¾‹è¾“å‡º # 1 2\næ ·ä¾‹è¾“å…¥ # 2 2 5 1 0 1 1\næ ·ä¾‹è¾“å‡º # 2 0\næ ·ä¾‹è¯´æ˜ # æ ·ä¾‹ 1ï¼Œå­˜åœ¨è·¯å¾„ï¼š0â†’1â†’2â†’3ï¼Œğ¾=2ï¼Œå¦‚æœåœ¨ 0â†’1â†’2 ä¸Šä½¿ç”¨é­”æ³•ï¼Œé‚£ä¹ˆç­”æ¡ˆå°±æ˜¯ 0+0+4=4ï¼›å¦‚æœåœ¨ 1â†’2â†’3 ä¸Šä½¿ç”¨é­”æ³•ï¼Œé‚£ä¹ˆç­”æ¡ˆå°±æ˜¯ 2+0+0=2ã€‚å†ä¹Ÿæ‰¾ä¸åˆ°æ¯” 2 è¿˜å°çš„ç­”æ¡ˆäº†ï¼Œæ‰€ä»¥ç­”æ¡ˆå°±æ˜¯ 2ã€‚\næ ·ä¾‹ 2ï¼Œå­˜åœ¨è·¯å¾„ï¼š0â†’1â†’0â†’1â†’0â†’1ï¼Œğ¾=5ï¼Œè¿™æ¡è·¯å¾„æ€»è®¡æ°å¥½èµ°äº† 5 æ¡è¾¹ï¼Œæ‰€ä»¥æ­£å¥½å¯ä»¥ç”¨é­”æ³•æ¶ˆé™¤æ‰€æœ‰ä¼¤å®³ï¼Œç­”æ¡ˆæ˜¯ 0ã€‚\nè¯„æµ‹ç”¨ä¾‹è§„æ¨¡ä¸çº¦å®š :\nå¯¹äº 30% çš„è¯„æµ‹ç”¨ä¾‹ï¼Œ1â‰¤ğ‘â‰¤20ã€‚\nå¯¹äº 50% çš„è¯„æµ‹ç”¨ä¾‹ï¼Œ1â‰¤ğ‘â‰¤100ã€‚\nå¯¹äº 100% çš„è¯„æµ‹ç”¨ä¾‹ï¼Œ1â‰¤ğ‘â‰¤1000ï¼Œ1â‰¤ğ‘€â‰¤ğ‘Ã—(ğ‘âˆ’1)2ï¼Œ1â‰¤ğ¾â‰¤10ï¼Œ0â‰¤ğ‘¢,ğ‘£â‰¤ğ‘âˆ’1ï¼Œ1â‰¤ğ‘¤â‰¤1000ã€‚\nACä»£ç  # æ€è·¯æ˜¯BFS+åŠ¨æ€è§„åˆ’+Dijskra+ä¼˜å…ˆé˜Ÿåˆ—\ngï¼šé‚»æ¥è¡¨å­˜å‚¨å›¾ï¼ˆg[u] å­˜å‚¨ u çš„æ‰€æœ‰é‚»æ¥è¾¹ (v, w)ï¼‰ã€‚ d[i][j]ï¼šè¡¨ç¤ºä» 0 èµ°åˆ° i æ—¶ï¼Œå·²ç»è¿ç»­å…é™¤äº† j æ¡è¾¹ä¼¤å®³çš„æœ€å°æ€»ä¼¤å®³ã€‚ j = 0ï¼šè¡¨ç¤ºæœªä½¿ç”¨é­”æ³•ã€‚ j = 1ï¼šè¡¨ç¤ºå·²ç»è¿ç»­å…é™¤äº† 1 æ¡è¾¹çš„ä¼¤å®³ï¼ˆæ­£åœ¨ç§¯ç´¯ K æ¡è¾¹ï¼‰ã€‚ j = Kï¼šè¡¨ç¤ºå·²ç»æˆåŠŸä½¿ç”¨é­”æ³•ï¼ˆå…é™¤äº† K æ¡è¾¹çš„ä¼¤å®³ï¼‰ã€‚\n#include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int INF = 1e9; int main() { int n, k, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k \u0026gt;\u0026gt; m; vector\u0026lt;vector\u0026lt;PII\u0026gt;\u0026gt; graph(n); while (m--) { int u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; graph[u].push_back({v, w}); graph[v].push_back({u, w}); } // dist[i][j]: åˆ°èŠ‚ç‚¹iæ—¶ï¼Œå·²è¿ç»­å…é™¤jæ¡è¾¹çš„æœ€å°ä¼¤å®³ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dist(n, vector\u0026lt;int\u0026gt;(k + 1, INF)); dist[0][0] = 0; // èµ·ç‚¹0ï¼Œæœªä½¿ç”¨é­”æ³• // ä¼˜å…ˆé˜Ÿåˆ—ï¼šæŒ‰å½“å‰ä¼¤å®³å‡åºæ’åˆ—ï¼Œè¿™é‡Œçš„intå€¼å°±æ˜¯ç°åœ¨å—åˆ°çš„ä¼¤å®³æ•° priority_queue\u0026lt;pair\u0026lt;int, PII\u0026gt;, vector\u0026lt;pair\u0026lt;int, PII\u0026gt;\u0026gt;, greater\u0026lt;pair\u0026lt;int, PII\u0026gt;\u0026gt;\u0026gt; pq; pq.push({0, {0, 0}}); // {å½“å‰æ€»ä¼¤å®³, {èŠ‚ç‚¹, å·²å…é™¤çš„è¾¹æ•°}} while (!pq.empty()) { auto current = pq.top(); int total = current.first; int u = current.second.first; int j = current.second.second; pq.pop(); if (total \u0026gt; dist[u][j]) continue; // å·²å­˜åœ¨æ›´ä¼˜è§£ï¼Œè·³è¿‡ for (auto edge : graph[u]) { int v = edge.first; // ç›®æ ‡èŠ‚ç‚¹ int w = edge.second; // è¾¹ä¼¤å®³ // æƒ…å†µ1ï¼šä¸ä½¿ç”¨é­”æ³•ï¼ˆjä¿æŒ0ï¼‰ if (j == 0 \u0026amp;\u0026amp; dist[v][0] \u0026gt; total + w) { dist[v][0] = total + w; pq.push({dist[v][0], {v, 0}}); } // æƒ…å†µ2ï¼šæ­£åœ¨ç§¯ç´¯é­”æ³•ï¼ˆj \u0026lt; kï¼‰ if (j \u0026lt; k \u0026amp;\u0026amp; dist[v][j + 1] \u0026gt; total) { // å…é™¤å½“å‰è¾¹çš„ä¼¤å®³ dist[v][j + 1] = total; pq.push({dist[v][j + 1], {v, j + 1}}); } // æƒ…å†µ3ï¼šé­”æ³•å·²ç”¨å®Œï¼ˆj == kï¼‰ if (j == k \u0026amp;\u0026amp; dist[v][k] \u0026gt; total + w) { dist[v][k] = total + w; pq.push({dist[v][k], {v, k}}); } } } // è¾“å‡ºæœ€å°ä¼¤å®³ï¼šå¯èƒ½æœªä½¿ç”¨é­”æ³•æˆ–å·²ä½¿ç”¨é­”æ³• cout \u0026lt;\u0026lt; min(dist[n-1][0], dist[n-1][k]) \u0026lt;\u0026lt; endl; return 0; } ä¸ºä»€ä¹ˆç”¨ BFS + DPï¼Ÿ\n(1) æ™®é€š BFS çš„é—®é¢˜\nBFS é€šå¸¸ç”¨äºæ— æƒå›¾çš„æœ€çŸ­è·¯å¾„ï¼ˆæ‰€æœ‰è¾¹æƒé‡ç›¸åŒï¼‰ã€‚ ä½†æœ¬é¢˜è¾¹æœ‰ä¼¤å®³å€¼ï¼ˆæƒé‡ï¼‰ï¼Œæ‰€ä»¥è¦ç”¨ Dijkstraï¼ˆä¼˜å…ˆé˜Ÿåˆ— BFSï¼‰ æ¥ä¿è¯æ¯æ¬¡å–æœ€å°ä¼¤å®³çš„è·¯å¾„ã€‚ (2) ä¸ºä»€ä¹ˆè¿˜è¦ DPï¼Ÿ\nå¯ä»¥é€‰æ‹© å…é™¤æŸäº›è¾¹çš„ä¼¤å®³ï¼Œä½†æœ€å¤šè¿ç»­å… K æ¡ã€‚ è¿™æ„å‘³ç€ åˆ°è¾¾åŒä¸€ä¸ªèŠ‚ç‚¹æ—¶ï¼Œå¯èƒ½å¤„äºä¸åŒçš„â€œé­”æ³•çŠ¶æ€â€ï¼ˆæ¯”å¦‚å·²ç»å…äº† 0 æ¡ã€1 æ¡ã€\u0026hellip;ã€K æ¡ï¼‰ã€‚ å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦ é¢å¤–ç»´åº¦ j æ¥è®°å½•å½“å‰å…é™¤äº†å¤šå°‘æ¡è¾¹ã€‚ è¿™é‡Œåšä¸»è®¾ç½®ä¸€ä¸ªç®€å•çš„ä¾‹å­æ¥çœ‹çœ‹ä»£ç çš„é€»è¾‘\n","date":"29 March 2025","externalUrl":null,"permalink":"/posts/lanqiaocup/lanqiaocup2023-2/","section":"Posts","summary":"","title":"Lanqiaocup2023-2","type":"posts"},{"content":"","date":"29 March 2025","externalUrl":null,"permalink":"/series/%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%A2%98%E5%BA%93/","section":"Series","summary":"","title":"è“æ¡¥æ¯é¢˜åº“","type":"series"},{"content":" å•è°ƒæ ˆ # æœ¬ç³»åˆ—çš„å¤§éƒ¨åˆ†éƒ½æ˜¯å¯¹labuladongå’Œä»£ç éšæƒ³å½•ç½‘ç«™çš„é¢˜ç›®çš„ç»ƒæ‰‹æ±‡æ€»(éƒ¨åˆ†æ˜¯åšä¸»è‡ªå·±ç»“åˆleetcodeå’Œæ´›è°·é¢˜ç›®çš„è¡¥å……ï¼‰åˆè¡·æ˜¯åšä¸»è‡ªç”¨å­¦ä¹ å“’!\nè¯·æ‰€æœ‰é˜…è¯»è¿™ç³»åˆ—åšå®¢çš„å‹å‹å…ˆç§»æ­¥é˜…è§ˆä»–ä»¬çš„ç½‘ç«™ï¼Œæ²¡æœ‰è¿™äº›ä¼˜ç§€ç½‘ç«™çš„åˆ†äº«ä¸ä¼šæœ‰è¿™ç³»åˆ—çš„æ–‡ç« ï¼Œæˆ‘åªæ˜¯çŸ¥è¯†çš„æ¬è¿å·¥ï¼\nâ€œä¸€ç»´æ•°ç»„ï¼Œè¦å¯»æ‰¾ä»»ä¸€ä¸ªå…ƒç´ çš„å³è¾¹æˆ–è€…å·¦è¾¹ç¬¬ä¸€ä¸ªæ¯”è‡ªå·±å¤§æˆ–è€…å°çš„å…ƒç´ çš„ä½ç½®ï¼Œå°±å¯ä»¥è€ƒè™‘ä½¿ç”¨å•è°ƒæ ˆâ€œâ€”â€”ä»£ç éšæƒ³å½•\nï¼ˆäºŒåˆ†ä¹Ÿèƒ½å®ç°ï¼Œä½†æ˜¯äºŒåˆ†çš„å‰ææ˜¯æœ‰åºæ•°ç»„\nã€Leetcodeã€‘ä¾‹é¢˜â€”739æ¯æ—¥æ¸©åº¦ # ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ temperatures ï¼Œè¡¨ç¤ºæ¯å¤©çš„æ¸©åº¦ï¼Œè¿”å›ä¸€ä¸ªæ•°ç»„ answer ï¼Œå…¶ä¸­ answer[i] æ˜¯æŒ‡å¯¹äºç¬¬ i å¤©ï¼Œä¸‹ä¸€ä¸ªæ›´é«˜æ¸©åº¦å‡ºç°åœ¨å‡ å¤©åã€‚å¦‚æœæ°”æ¸©åœ¨è¿™ä¹‹åéƒ½ä¸ä¼šå‡é«˜ï¼Œè¯·åœ¨è¯¥ä½ç½®ç”¨ 0 æ¥ä»£æ›¿ã€‚\nç¤ºä¾‹ 1:\nè¾“å…¥: temperatures = [73,74,75,71,69,72,76,73] è¾“å‡º: [1,1,4,2,1,1,0,0] è¿‡ç¨‹åˆ†æ # æ¨¡æ¿ä»£ç  # æ¬è¿çš„ä»£ç éšæƒ³å½•çš„æ¨¡æ¿\n// ç‰ˆæœ¬ä¸€ class Solution { public: vector\u0026lt;int\u0026gt; dailyTemperatures(vector\u0026lt;int\u0026gt;\u0026amp; T) { // é€’å¢æ ˆ stack\u0026lt;int\u0026gt; st; vector\u0026lt;int\u0026gt; result(T.size(), 0); st.push(0); for (int i = 1; i \u0026lt; T.size(); i++) { if (T[i] \u0026lt; T[st.top()]) { // æƒ…å†µä¸€ st.push(i); } else if (T[i] == T[st.top()]) { // æƒ…å†µäºŒ st.push(i); } else { while (!st.empty() \u0026amp;\u0026amp; T[i] \u0026gt; T[st.top()]) { // æƒ…å†µä¸‰ result[st.top()] = i - st.top(); st.pop(); } st.push(i); } } return result; } }; ç²¾ç®€ä»£ç å¦‚ä¸‹ï¼š\n// ç‰ˆæœ¬äºŒ class Solution { public: vector\u0026lt;int\u0026gt; dailyTemperatures(vector\u0026lt;int\u0026gt;\u0026amp; T) { stack\u0026lt;int\u0026gt; st; // é€’å¢æ ˆ vector\u0026lt;int\u0026gt; result(T.size(), 0); for (int i = 0; i \u0026lt; T.size(); i++) { while (!st.empty() \u0026amp;\u0026amp; T[i] \u0026gt; T[st.top()]) { // æ³¨æ„æ ˆä¸èƒ½ä¸ºç©º result[st.top()] = i - st.top(); st.pop(); } st.push(i); } return result; } }; ã€è“æ¡¥æ¯é¢˜åº“ã€‘54461. æœ€å¤§åŒºé—´ # é—®é¢˜æè¿° # ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º nçš„åºåˆ— Aiï¼Œæ±‚ L,R ä½¿ (Râˆ’L+1)â‹…minâ¡(AL,AL+1,â€¦,AR) å°½å¯èƒ½å¤§ï¼Œå…¶ä¸­ minâ¡ è¡¨ç¤ºæœ€å°å€¼ã€‚\nä½ åªéœ€è¦è¾“å‡ºæœ€å¤§çš„å€¼å³å¯ï¼Œä¸éœ€è¦è¾“å‡ºå…·ä½“çš„ L,Rã€‚\nè¾“å…¥æ ¼å¼ # è¾“å…¥çš„ç¬¬ä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•° nã€‚\nç¬¬äºŒè¡ŒåŒ…å« nä¸ªæ•´æ•°ï¼Œåˆ†åˆ«è¡¨ç¤º A1,A2,â€¦,Anç›¸é‚»ä¸¤ä¸ªæ•´æ•°ä¹‹é—´ä½¿ç”¨ä¸€ä¸ªç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡ºæ ¼å¼ # è¾“å‡ºä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•°è¡¨ç¤ºç­”æ¡ˆã€‚\næ ·ä¾‹è¾“å…¥ # 5 1 1 3 3 1 æ ·ä¾‹è¾“å‡º # 6 å¯¹äº 40%è¯„æµ‹ç”¨ä¾‹ï¼Œ1â‰¤nâ‰¤5000ï¼Œ1â‰¤Aiâ‰¤5000ï¼›\nå¯¹äºæ‰€æœ‰è¯„æµ‹ç”¨ä¾‹ï¼Œ1â‰¤nâ‰¤3Ã—10^5ï¼Œ 1â‰¤Aiâ‰¤10^9ã€‚\né”™è¯¯æ€è·¯ # ä¸€å¼€å§‹å°±æ˜¯ç®€å•çš„æƒ³å»å¥—æ¨¡æ¿ï¼Œä½†æ˜¯è¿™ä¸æ¨¡æ¿é¢˜ä¸åŒçš„æ˜¯ï¼Œå…¶å®å¹¶ä¸æ˜¯çº¯ç²¹çš„å•è°ƒï¼Œæ¯æ¬¡å…¥æ ˆå…¶å®æ˜¯å’Œæ ˆåº•æ¯”ã€‚ï¼ˆé‚£è¿™æ ·è¿˜ä¸å¦‚ç”¨æ»‘åŠ¨çª—å£äº†æ„Ÿè§‰\u0026hellip;\n#include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; int main() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt;nums(n,0); for(int i=0;i\u0026lt;n;i++)cin\u0026gt;\u0026gt;nums[i]; stack\u0026lt;ll\u0026gt;st; vector\u0026lt;ll\u0026gt;maxlen(n,n); for(int i=0;i\u0026lt;n;i++) { while(!st.empty()\u0026amp;\u0026amp;nums[i]\u0026lt;st.top()) { maxlen[st.top()]=i-st.top(); st.pop(); } st.push(i); } ll res=0; for(int i=0;i\u0026lt;n;i++) { res=max(res,maxlen[i]*nums[i]); } cout\u0026lt;\u0026lt;res; return 0; } ACä»£ç  # #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; int main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; nums(n, 0); for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; nums[i]; stack\u0026lt;ll\u0026gt; st; vector\u0026lt;ll\u0026gt; left(n, -1); // å·¦è¾¹ç¬¬ä¸€ä¸ªæ¯”å®ƒå°çš„å…ƒç´ çš„ä½ç½® vector\u0026lt;ll\u0026gt; right(n, n); // å³è¾¹ç¬¬ä¸€ä¸ªæ¯”å®ƒå°çš„å…ƒç´ çš„ä½ç½® // è®¡ç®— left for (int i = 0; i \u0026lt; n; i++) { while (!st.empty() \u0026amp;\u0026amp; nums[i] \u0026lt; nums[st.top()]) { right[st.top()] = i; st.pop(); } left[i] = st.empty() ? -1 : st.top(); //å› ä¸ºæ­¤æ—¶topåœåœ¨çš„åœ°æ–¹å°±æ˜¯å·¦è¾¹ç¦»nums[i]æœ€è¿‘çš„å¤§äºç­‰äºå…¶çš„ç´¢å¼• st.push(i); } // è®¡ç®— maxlen vector\u0026lt;ll\u0026gt; maxlen(n, 1); for (int i = 0; i \u0026lt; n; i++) { maxlen[i] = right[i] - left[i] - 1; } // è®¡ç®—ç»“æœ ll res = 0; for (int i = 0; i \u0026lt; n; i++) { res = max(res, maxlen[i] * nums[i]); } cout \u0026lt;\u0026lt; res; return 0; } å®˜æ–¹é¢˜è§£\nè“æ¡¥æ¯å®˜æ–¹æ˜¯ç”¨çš„å•è°ƒé˜Ÿåˆ—ï¼ˆä½†æ˜¯å®ƒtagä¸ºä»€ä¹ˆæ˜¯å•è°ƒæ ˆ:(\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long LL; int n; void solve() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;LL\u0026gt; a(n), l(n, -1), r(n, n); for (int i = 0; i \u0026lt; n; ++i) { cin \u0026gt;\u0026gt; a[i]; } deque\u0026lt;int\u0026gt; s; for (int i = 0; i \u0026lt; n; ++i) { while (s.size() \u0026amp;\u0026amp; a[s.back()] \u0026gt;= a[i]) { s.pop_back(); } if (s.size()) l[i] = s.back(); s.push_back(i); } s.clear(); for (int i = n - 1; i \u0026gt;= 0; --i) { while (s.size() \u0026amp;\u0026amp; a[s.back()] \u0026gt;= a[i]) { s.pop_back(); } if (s.size()) r[i] = s.back(); s.push_back(i); } LL ans = 0; for (int i = 0; i \u0026lt; n; ++i) { ans = max(ans, 1LL * (r[i] - l[i] - 1) * a[i]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { ios_base ::sync_with_stdio(false); cin.tie(0); cout \u0026lt;\u0026lt; setiosflags(ios::fixed) \u0026lt;\u0026lt; setprecision(2); int t = 1; while (t--) { solve(); } return 0; } ","date":"29 March 2025","externalUrl":null,"permalink":"/posts/algorithm/%E5%8D%95%E8%B0%83%E6%A0%88/","section":"Posts","summary":"","title":"å•è°ƒæ ˆ\u0026å•è°ƒé˜Ÿåˆ—","type":"posts"},{"content":"","date":"28 March 2025","externalUrl":null,"permalink":"/categories/deeplearning/","section":"æ–‡ç« åˆ†ç±»","summary":"","title":"DeepLearning","type":"categories"},{"content":"","date":"28 March 2025","externalUrl":null,"permalink":"/series/fastai-course-learning-/","section":"Series","summary":"","title":"Fastai Course Learning ","type":"series"},{"content":" Learning pytorch based Collaborative Filtering # æœ¬æ–‡å¤ç°çš„æ˜¯fastaiçš„å®˜æ–¹è§†é¢‘æ•™ç¨‹ ç‚¹å‡»æ­¤å¤„è·³è½¬\nå…¶å®˜æ–¹kaggleç¬”è®°æœ¬ ç‚¹å‡»æ­¤å¤„è·³è½¬\næœ¬æ–‡åŸºäºMovieLensçš„ç”µå½±è¯„åˆ†æ•°æ®é›†ï¼Œå€ŸåŠ©fastaiçš„é«˜çº§APIï¼Œå­¦ä¹ åŸºäºpytorchçš„ç¥ç»ç½‘ç»œå»ºç«‹\nåˆ›å»ºDataLoaders # from fastai.collab import * from fastai.tabular.all import * set_seed(42) å› ä¸ºåšä¸»æ˜¯é€šè¿‡fastaiè¿™ä¸ªpytorchçš„é«˜çº§APIè¿›è¡Œå­¦ä¹ çš„ï¼Œå› æ­¤è·å–æ•°æ®å¯ä»¥ç›´æ¥ä»fastaié‡Œè·å–\npath = untar_data(URLs.ML_100k) movies = pd.read_csv( path/\u0026#39;u.item\u0026#39;, delimiter=\u0026#39;|\u0026#39;, encoding=\u0026#39;latin-1\u0026#39;, usecols=(0,1), names=(\u0026#39;movies\u0026#39;,\u0026#39;title\u0026#39;), header=None ) movies.head() movies title 0 1 Toy Story (1995) 1 2 GoldenEye (1995) 2 3 Four Rooms (1995) 3 4 Get Shorty (1995) 4 5 Copycat (1995) ratings = pd.read_csv( path/\u0026#39;u.data\u0026#39;, delimiter=\u0026#39;\\t\u0026#39;, header = None, names=[\u0026#39;user\u0026#39;,\u0026#39;movies\u0026#39;,\u0026#39;rating\u0026#39;,\u0026#39;timestamp\u0026#39;] ) ratings.head() user movies rating timestamp 0 196 242 3 881250949 1 186 302 3 891717742 2 22 377 1 878887116 3 244 51 2 880606923 4 166 346 1 886397596 ä¸‹é¢æ„å»ºç”¨æˆ·-ç”µå½±è¯„åˆ†çŸ©é˜µ ratings = ratings.merge(movies) ratings.head() user movies rating timestamp title 0 196 242 3 881250949 Kolya (1996) 1 186 302 3 891717742 L.A. Confidential (1997) 2 22 377 1 878887116 Heavyweights (1994) 3 244 51 2 880606923 Legends of the Fall (1994) 4 166 346 1 886397596 Jackie Brown (1997) ratings = ratings.drop(\u0026#39;timestamp\u0026#39;, axis=1) ratings.head() user movies rating title 0 196 242 3 Kolya (1996) 1 186 302 3 L.A. Confidential (1997) 2 22 377 1 Heavyweights (1994) 3 244 51 2 Legends of the Fall (1994) 4 166 346 1 Jackie Brown (1997) dls = CollabDataLoaders.from_df(ratings,item_name=\u0026#39;title\u0026#39;,bs=64) item_name='title'æŒ‡å®šDataFrameä¸­è¡¨ç¤ºâ€œé¡¹ç›®â€ï¼ˆitemï¼‰çš„åˆ—åã€‚\u0026rsquo;title\u0026rsquo; æ˜¯ç”µå½±çš„æ ‡é¢˜åˆ—ã€‚\nbs=64æŒ‡å®šæ¯ä¸ªæ‰¹æ¬¡ï¼ˆbatchï¼‰çš„å¤§å°ä¸º 64ã€‚\ndls.show_batch() user title rating 0 782 Starship Troopers (1997) 2 1 943 Judge Dredd (1995) 3 2 758 Mission: Impossible (1996) 4 3 94 Farewell My Concubine (1993) 5 4 23 Psycho (1960) 4 5 296 Secrets \u0026amp; Lies (1996) 5 6 940 American President, The (1995) 4 7 334 Star Trek VI: The Undiscovered Country (1991) 1 8 380 Braveheart (1995) 4 9 690 So I Married an Axe Murderer (1993) 1 latent factoræ½œåœ¨å› å­ # Latent factorï¼ˆæ½œåœ¨å› å­ï¼‰æ˜¯ä¸€ç§åœ¨æœºå™¨å­¦ä¹ å’Œç»Ÿè®¡å­¦ä¸­å¹¿æ³›ä½¿ç”¨çš„æ¦‚å¿µï¼Œå°¤å…¶æ˜¯åœ¨ ååŒè¿‡æ»¤ï¼ˆCollaborative Filteringï¼‰ å’Œ é™ç»´ï¼ˆDimensionality Reductionï¼‰ é¢†åŸŸã€‚\nå®ƒæŒ‡çš„æ˜¯éšè—åœ¨æ•°æ®èƒŒåã€ç”¨äºè§£é‡Šæ•°æ®ç»“æ„çš„ä¸å¯è§‚æµ‹çš„ç‰¹å¾æˆ–å˜é‡ã€‚\nç”¨æˆ·æ½œåœ¨å› å­ï¼ˆUser Latent Factorsï¼‰ï¼šæ¯ä¸ªç”¨æˆ·å¯ä»¥ç”¨ä¸€ä¸ªå‘é‡è¡¨ç¤ºï¼Œè¿™ä¸ªå‘é‡æ•æ‰äº†ç”¨æˆ·çš„åå¥½ç‰¹å¾ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªå–œæ¬¢ç§‘å¹»ç”µå½±çš„ç”¨æˆ·å¯èƒ½ä¼šåœ¨â€œç§‘å¹»â€ç»´åº¦ä¸Šæœ‰è¾ƒé«˜çš„å€¼ã€‚ ç‰©å“æ½œåœ¨å› å­ï¼ˆItem Latent Factorsï¼‰ï¼šæ¯ä¸ªç‰©å“ï¼ˆå¦‚ç”µå½±ã€å•†å“ç­‰ï¼‰ä¹Ÿå¯ä»¥ç”¨ä¸€ä¸ªå‘é‡è¡¨ç¤ºï¼Œè¿™ä¸ªå‘é‡æ•æ‰äº†ç‰©å“çš„ç‰¹å¾ã€‚ä¾‹å¦‚ï¼Œä¸€éƒ¨ç§‘å¹»ç”µå½±åœ¨â€œç§‘å¹»â€ç»´åº¦ä¸Šä¼šæœ‰è¾ƒé«˜çš„å€¼ã€‚ é€šè¿‡è¿™äº›æ½œåœ¨å› å­ï¼Œæ¨¡å‹å¯ä»¥é¢„æµ‹ç”¨æˆ·å¯¹ç‰©å“çš„è¯„åˆ†æˆ–åå¥½ã€‚ç”¨æˆ·æ½œåœ¨å› å­å’Œç‰©å“æ½œåœ¨å› å­çš„å†…ç§¯å¯ä»¥ç”¨æ¥é¢„æµ‹ç”¨æˆ·å¯¹ç‰©å“çš„è¯„åˆ†ã€‚\nn_users = len(dls.classes[\u0026#39;user\u0026#39;]) n_movies = len(dls.classes[\u0026#39;title\u0026#39;]) n_factors = 5 #æ˜¾å¼å®šä¹‰æ½œåœ¨å› å­çš„æ•°é‡ #å…ˆä½¿ç”¨torchçš„randomåˆå§‹åŒ– user_factors = torch.randn(n_users, n_factors) movie_factors = torch.randn(n_movies, n_factors) è¿™æ ·å°±åˆ›å»ºäº†æ½œåœ¨å› å­çŸ©é˜µ\nåŸºäºtorch.nn.moudelè‡ªå®šä¹‰é¢„æµ‹æ¨¡å— # åˆ›å»ºä¸€ä¸ªæ–°çš„æ¨¡å—ç±»æ—¶ï¼Œéœ€è¦ç»§æ‰¿torch.nn.Moduleã€‚å¹¶ä¸”åœ¨æ¨¡å—ç±»ä¸­å®ç° forwardæ–¹æ³•ï¼Œå®šä¹‰æ¨¡å—çš„å‰å‘ä¼ æ’­é€»è¾‘ã€‚\nå½“è°ƒç”¨æ¨¡å—æ—¶ä¼šè‡ªåŠ¨è°ƒç”¨forwardï¼Œå¹¶å°†è°ƒç”¨ä¸­çš„å‚æ•°ä¼ é€’ç»™å®ƒã€‚\ntip:åœ¨FastAIä¸­ï¼ŒModuleæ˜¯ä¸€ä¸ªå°è£…äº† PyTorch çš„ torch.nn.Module çš„ç±»ï¼Œå› æ­¤å¯ä»¥ç›´æ¥ç»§æ‰¿ Module æ¥å®šä¹‰è‡ªå·±çš„æ¨¡å‹ã€‚\nclass DotProduct(Module): def __init__(self,n_users,n_movies,n_factors): self.user_factors = Embedding(n_users,n_factors) self.movie_factors = Embedding(n_movies, n_factors) def forward(self,x): users = self.user_factors(x[:,0]) movies = self.movie_factors(x[:,1]) return (users * movies).sum(dim=1) #å‘é‡çš„é€å…ƒç´ ç›¸ä¹˜åæ±‚å’Œ åµŒå…¥å±‚Embeddingæ˜¯ä¸€ç§å°†é«˜ç»´ç¨€ç–çš„ç‹¬çƒ­ç¼–ç å‘é‡æ˜ å°„åˆ°ä½ç»´å¯†é›†å‘é‡çš„æ–¹æ³•ã€‚å®ƒé€šè¿‡å­¦ä¹ ä¸€ä¸ªåµŒå…¥çŸ©é˜µEmbedding Matrixï¼Œå°†æ¯ä¸ªç±»åˆ«æ˜ å°„åˆ°ä¸€ä¸ªä½ç»´ç©ºé—´ä¸­çš„å‘é‡ã€‚\nåµŒå…¥å±‚çš„å·¥ä½œæ–¹å¼æ˜¯é€šè¿‡çŸ©é˜µä¹˜æ³•æ¥è¾¾åˆ°æŸ¥æ‰¾åµŒå…¥çŸ©é˜µEä¸­çš„è¡Œæ¥è·å–åµŒå…¥å‘é‡çš„æ•ˆæœ,è¿™é‡Œåˆ›å»ºä¸¤ä¸ªåµŒå…¥çŸ©é˜µuser_factors å’Œ movie_factorsåˆ†åˆ«è¡¨ç¤ºç”¨æˆ·å’Œç”µå½±çš„æ½œåœ¨ç‰¹å¾latent factors\nå…³äºembeddingæ˜¯å¦‚ä½•å¯¹åº”åˆ°ç´¢å¼•çš„ï¼Œåšä¸»ä¸¾ä¾‹ç”»å›¾æ¥ç†è§£\nx,y = dls.one_batch() x.shape #output:\ntorch.Size([64, 2])\nåˆ›å»ºå­¦ä¹ æ¨¡å‹ # model=DotProduct(n_users,n_movies,50) #è¿™é‡Œå®šä¹‰æ½œåœ¨å› å­ä¸º50 learn = Learner(dls,model,loss_func=MSELossFlat()) Learneræ˜¯FastAIä¸­çš„æ ¸å¿ƒç±»ï¼Œç”¨äºå°è£…æ¨¡å‹è®­ç»ƒå’Œè¯„ä¼°çš„é€»è¾‘ã€‚\nè®­ç»ƒæ¨¡å‹ï¼šlearn.fit_one_cycle æˆ– learn.fitã€‚ è¯„ä¼°æ¨¡å‹ï¼šlearn.validate æˆ– learn.show_resultsã€‚ è°ƒæ•´å­¦ä¹ ç‡ï¼šlearn.lr_findã€‚ ä¿å­˜å’ŒåŠ è½½æ¨¡å‹ï¼šlearn.save å’Œ learn.loadã€‚ MSELossFlat()æ˜¯FastAIæä¾›çš„ä¸€ä¸ªå°è£…çš„å‡æ–¹è¯¯å·®æŸå¤±å‡½æ•°ã€‚å®ƒåœ¨å†…éƒ¨å¤„ç†äº†å¼ é‡çš„å±•å¹³flatteningï¼Œä½¿å¾—æŸå¤±å‡½æ•°å¯ä»¥ç›´æ¥åº”ç”¨äºå¤šç»´å¼ é‡çš„è¾“å‡ºã€‚\nå¼€å§‹è®­ç»ƒ # learn.fit_one_cycle(5, 5e-3) epoch train_loss valid_loss time 0 1.323817 1.340935 00:09 1 1.017078 1.092095 00:09 2 0.873056 0.974699 00:09 3 0.762055 0.897630 00:09 4 0.719645 0.874279 00:09 åŠ å…¥biasåå·®ã€sigmoidå‡½æ•° # class DotProductBias(Module): def __init__(self, n_users, n_movies, n_factors, y_range=(0,5.5)): self.user_factors = Embedding(n_users, n_factors) self.user_bias = Embedding(n_users, 1) self.movie_factors = Embedding(n_movies, n_factors) self.movie_bias = Embedding(n_movies, 1) self.y_range = y_range def forward(self, x): users = self.user_factors(x[:,0]) movies = self.movie_factors(x[:,1]) res = (users * movies).sum(dim=1, keepdim=True) res += self.user_bias(x[:,0]) + self.movie_bias(x[:,1]) return sigmoid_range(res, *self.y_range) è¿™é‡Œå°†y_rangeè®¾ç½®çš„æ˜¯æ¯”5ç¨å¾®å¤§ä¸€ç‚¹ï¼Œå› ä¸ºsigmoidå‡½æ•°æ˜¯æ²¡æœ‰åˆ°1çš„ï¼Œè€Œæˆ‘ä»¬çŸ¥é“ratingæ˜¯å¯ä»¥åˆ°5çš„\nmodel = DotProductBias(n_users, n_movies, 50) learn = Learner(dls, model, loss_func=MSELossFlat()) learn.fit_one_cycle(5, 5e-3) epoch train_loss valid_loss time 0 0.873342 0.933685 00:10 1 0.580043 0.916336 00:10 2 0.412618 0.954554 00:09 3 0.312082 0.964509 00:10 4 0.309014 0.965015 00:10 è®­ç»ƒæ•ˆæœå¹¶æ²¡æœ‰æ›´å¥½åè€Œåœ¨éªŒè¯é›†ä¸Šçš„è¡¨ç°æ•ˆæœæ›´ç³Ÿäº†ï¼Œæ³¨æ„åˆ°åœ¨éªŒè¯é›†çš„æŸå¤±ä¸€å¼€å§‹å‡å°‘åé¢åˆå¢åŠ äº†ï¼ŒçŒœæµ‹æ˜¯è¿‡æ‹Ÿåˆçš„åŸå› ï¼Œä¸‹é¢å¼•å…¥æƒé‡è¡°å‡æ”¹è¿›\nåŠ å…¥Weight Decayæƒé‡è¡°å‡è¿›è¡Œè®­ç»ƒ # æƒé‡è¡°å‡Weight decayåˆç§°ä¸ºL2æ­£åˆ™åŒ–L2 regularizationã€‚\nå®ƒå°†æ‰€æœ‰æƒé‡å¹³æ–¹å’Œæ·»åŠ åˆ°æŸå¤±å‡½æ•°ä¸­ã€‚å½“æˆ‘ä»¬è®¡ç®—æ¢¯åº¦æ—¶ï¼Œå®ƒä¼šä¸ºä¿ƒä½¿æƒé‡å°½å¯èƒ½å°ã€‚é™åˆ¶æƒé‡å¢é•¿è¿‡å¿«ä¼šé˜»ç¢æ¨¡å‹çš„è®­ç»ƒï¼Œä½†ä¼šä½¿å…¶æ³›åŒ–èƒ½åŠ›æ›´å¼ºã€‚\nå°†æƒé‡è¡°å‡wdæ·»åŠ åˆ°æŸå¤±å‡½æ•°ä¸­å¦‚ä¸‹ï¼š\nloss_with_wd = loss + wd * (parameters**2).sum()\nä½†å®é™…ä¸Šï¼Œè®¡ç®—è¿™ä¹ˆå¤§çš„æ•°é¢å¹¶å°†å…¶æ·»åŠ åˆ°æŸå¤±ä¸­æ˜¯éå¸¸ä½æ•ˆçš„ï¼Œè€Œå¦‚æœåœ¨è®¡ç®—æ¢¯åº¦æ—¶åŠ ä¸Šå°±ä¼šé«˜æ•ˆå¾ˆå¤š\nparameters.grad += wd * 2 * parameters\nè€Œåœ¨FastAiä¸­ï¼Œå¯ä»¥é€šè¿‡è®¾ç½®wdæ¥å®ç°æ·»åŠ æƒé‡è¡°å‡\nmodel = DotProductBias(n_users, n_movies, 50) learn = Learner(dls, model, loss_func=MSELossFlat()) learn.fit_one_cycle(5, 5e-3, wd=0.1) epoch train_loss valid_loss time 0 0.872865 0.944298 00:10 1 0.652497 0.890864 00:09 2 0.537503 0.877970 00:10 3 0.453741 0.863453 00:09 4 0.442338 0.859985 00:09 åœ¨éªŒè¯é›†ä¸Šçš„è¡¨ç°å¥½å¾ˆå¤šäº†ï¼\nåŸºäºtorch.nn.moudelè‡ªå®šä¹‰åµŒå…¥å±‚ # tipï¼šModuleä¸­è‹¥æƒ³è¦å°†å¼ é‡è§†ä¸ºå‚æ•°ï¼Œæˆ‘ä»¬å¿…é¡»å°†å…¶åŒ…è£…åœ¨ nn.Parameter ç±»ä¸­ã€‚\ndef create_params(size): return nn.Parameter(torch.zeros(*size).normal_(0, 0.01)) class DotProductBias(Module): def __init__(self, n_users, n_movies, n_factors, y_range=(0,5.5)): self.user_factors = create_params([n_users, n_factors]) self.user_bias = create_params([n_users]) self.movie_factors = create_params([n_movies, n_factors]) self.movie_bias = create_params([n_movies]) self.y_range = y_range def forward(self, x): users = self.user_factors[x[:,0]] movies = self.movie_factors[x[:,1]] res = (users*movies).sum(dim=1) res += self.user_bias[x[:,0]] + self.movie_bias[x[:,1]] return sigmoid_range(res, *self.y_range) x æ˜¯ä¸€ä¸ªäºŒç»´å¼ é‡ï¼Œå½¢çŠ¶ä¸º (batch_size, 2)ï¼Œå…¶ä¸­æ¯ä¸€è¡ŒåŒ…å«ä¸€ä¸ªç”¨æˆ· ID å’Œä¸€ä¸ªç”µå½± IDã€‚\nself.user_factors[x[:, 0]] å’Œ self.movie_factors[x[:, 1]] åˆ†åˆ«è·å–ç”¨æˆ·å’Œç”µå½±çš„æ½œåœ¨ç‰¹å¾å‘é‡ã€‚self.user_factors[x[:, 0]] ä¼šæ ¹æ®x[:, 0]ä» self.user_factors ä¸­æå–å¯¹åº”çš„åµŒå…¥å‘é‡ã€‚ç»“æœæ˜¯ä¸€ä¸ªäºŒç»´å¼ é‡ï¼Œå½¢çŠ¶ä¸º [batch_size, n_factors]ã€‚\n(users * movies).sum(dim=1) è®¡ç®—ç”¨æˆ·å’Œç”µå½±æ½œåœ¨ç‰¹å¾å‘é‡çš„ç‚¹ç§¯ã€‚\nself.user_bias[x[:, 0]] å’Œ self.movie_bias[x[:, 1]] åˆ†åˆ«è·å–ç”¨æˆ·å’Œç”µå½±çš„åç½®é¡¹ã€‚\nres += self.user_bias[x[:, 0]] + self.movie_bias[x[:, 1]] å°†åç½®é¡¹åŠ åˆ°ç‚¹ç§¯ç»“æœä¸Šã€‚\nsigmoid_range(res, *self.y_range) å°†ç»“æœæ˜ å°„åˆ°æŒ‡å®šçš„èŒƒå›´å†…ã€‚\nmodel = DotProductBias(n_users, n_movies, 50) learn = Learner(dls, model, loss_func=MSELossFlat()) learn.fit_one_cycle(5, 5e-3, wd=0.1) epoch train_loss valid_loss time 0 0.889919 0.940679 00:10 1 0.666765 0.891549 00:09 2 0.534145 0.872604 00:09 3 0.447389 0.854790 00:09 4 0.429244 0.850999 00:09 å’Œä½¿ç”¨Embeddingå±‚çš„æ•ˆæœå·®ä¸å¤š\nåå·®çš„å«ä¹‰ # movie_bias = learn.model.movie_bias.squeeze() idxs = movie_bias.argsort()[:5] [dls.classes[\u0026#39;title\u0026#39;][i] for i in idxs] squeeze() æ˜¯ PyTorch çš„ä¸€ä¸ªæ“ä½œï¼Œç”¨äºå»æ‰å¼ é‡ä¸­å¤§å°ä¸º 1 çš„ç»´åº¦ã€‚å¦‚æœ movie_bias çš„å½¢çŠ¶æ˜¯ [n_movies, 1]ï¼Œsqueeze() ä¼šå°†å…¶å˜ä¸ºä¸€ç»´å¼ é‡ [n_movies]ã€‚ï¼ˆä½†è¿™å¥½åƒä¸æ˜¯å¿…è¦çš„ï¼Œcreate_paramsåˆ›å»ºçš„å°±æ˜¯ä¸€ç»´çš„\nargsort() æ˜¯ PyTorch çš„ä¸€ä¸ªæ“ä½œï¼Œè¿”å›å¼ é‡ä¸­å…ƒç´ æŒ‰å€¼å‡åºæ’åˆ—çš„ç´¢å¼•ã€‚\n['Bio-Dome (1996)', 'Grease 2 (1982)', 'Showgirls (1995)', 'Spice World (1997)', 'Home Alone 3 (1997)'] åœ¨è¿™é‡Œå±•ç¤ºçš„ç”µå½±è¡¨ç¤ºå°½ç®¡ç”µå½±å¾ˆç¬¦åˆç”¨æˆ·çš„æ½œåœ¨å› å­ï¼Œä½†ç”¨æˆ·ä¹Ÿå¯èƒ½ä¸å–œæ¬¢ã€‚\nidxs = movie_bias.argsort(descending=True)[:5] [dls.classes[\u0026#39;title\u0026#39;][i] for i in idxs] ['Titanic (1997)', 'Shawshank Redemption, The (1994)', \u0026quot;Schindler's List (1993)\u0026quot;, 'Rear Window (1954)', 'L.A. Confidential (1997)'] åœ¨è¿™é‡Œå±•ç¤ºçš„ç”µå½±è¡¨ç¤ºå°½ç®¡ç”µå½± ä¸ç¬¦åˆç”¨æˆ·çš„æ½œåœ¨å› å­ï¼Œç”¨æˆ·ä¹Ÿå¯èƒ½å–œæ¬¢\nï¼ˆtitanicç»å…¸ç”µå½±æ˜¯æœ‰åŸå› çš„ï¼\nä½¿ç”¨PCAè§£é‡ŠåµŒå…¥çŸ©é˜µ # ä¸»æˆåˆ†åˆ†æ (PCA)èƒ½æå–åµŒå…¥çŸ©é˜µä¸­æœ€é‡è¦çš„æ½œåœ¨æ–¹å‘ï¼Œå¯¹ç”µå½±åµŒå…¥å‘é‡è¿›è¡ŒPCAé™ç»´ï¼Œå¹¶å°†é™ç»´åçš„ç»“æœå¯è§†åŒ–:\ng = ratings.groupby(\u0026#39;title\u0026#39;)[\u0026#39;rating\u0026#39;].count() top_movies = g.sort_values(ascending=False).index.values[:1000] top_idxs = tensor([learn.dls.classes[\u0026#39;title\u0026#39;].o2i[m] for m in top_movies]) movie_w = learn.model.movie_factors[top_idxs].cpu().detach() movie_pca = movie_w.pca(3) fac0,fac1,fac2 = movie_pca.t() idxs = list(range(50)) X = fac0[idxs] Y = fac2[idxs] plt.figure(figsize=(12,12)) plt.scatter(X, Y) for i, x, y in zip(top_movies[idxs], X, Y): plt.text(x,y,i, color=np.random.rand(3)*0.7, fontsize=11) plt.show() ç‚¹çš„ä½ç½®è¡¨ç¤ºç”µå½±åœ¨ä¸»æˆåˆ†ä¸Šçš„å€¼ã€‚ç‚¹è¶Šé è¿‘æŸä¸ªæ–¹å‘ï¼Œè¡¨ç¤ºè¯¥ç”µå½±åœ¨è¯¥ä¸»æˆåˆ†ä¸Šçš„å€¼è¶Šå¤§ã€‚ å¦‚æœæŸäº›ç‚¹èšé›†åœ¨ä¸€èµ·ï¼Œè¡¨ç¤ºè¿™äº›ç”µå½±åœ¨ä¸»æˆåˆ†ä¸Šçš„å€¼ç›¸ä¼¼ï¼Œå¯èƒ½å…·æœ‰ç›¸ä¼¼çš„ç‰¹å¾(å¥½åƒæŒºåˆ†æ•£çš„ ä½¿ç”¨fast.aiå®ç° # learn = collab_learner(dls, n_factors=50, y_range=(0, 5.5)) learn.fit_one_cycle(5, 5e-3, wd=0.1) å‚æ•°é¡ºåºåˆ†åˆ«æ˜¯ï¼šepochs å‚æ•°ã€lr_max å‚æ•°ä»¥åŠwdæƒé‡è¡°å‡çš„ç¼©æ”¾å› å­\nepoch train_loss valid_loss time 0 0.888463 0.945857 00:09 1 0.684889 0.887451 00:09 2 0.521428 0.868976 00:10 3 0.458419 0.854433 00:09 4 0.441765 0.849997 00:09 å±•ç¤ºæ¨¡å‹æ¯å±‚çš„è¯¦ç»†ç³»æ•° learn.model EmbeddingDotBias(\n(u_weight): Embedding(944, 50)\n(i_weight): Embedding(1665, 50)\n(u_bias): Embedding(944, 1)\n(i_bias): Embedding(1665, 1) )\næ·±åº¦å­¦ä¹ å®ç°ååŒè¿‡æ»¤ # embs = get_emb_sz(dls) embs [(944, 74), (1665, 102)]\nfast.aiçš„get_emb_szé€šè¿‡å¯å‘å¼æœç´¢èƒ½è¿”å›æ¨èè®¾ç½®çš„åµŒå…¥å±‚å¤§å°\nclass CollabNN(Module): def __init__(self, user_sz, item_sz, y_range=(0,5.5), n_act=100): self.user_factors = Embedding(*user_sz) self.item_factors = Embedding(*item_sz) self.layers = nn.Sequential( nn.Linear(user_sz[1]+item_sz[1], n_act), nn.ReLU(), nn.Linear(n_act, 1)) self.y_range = y_range def forward(self, x): embs = self.user_factors(x[:,0]),self.item_factors(x[:,1]) x = self.layers(torch.cat(embs, dim=1))#å°†åµŒå…¥ä¸æ¿€æ´»è¿æ¥åœ¨ä¸€èµ· return sigmoid_range(x, *self.y_range) model = CollabNN(*embs) learn = Learner(dls, model, loss_func=MSELossFlat()) learn.fit_one_cycle(5, 5e-3, wd=0.01) epoch train_loss valid_loss time 0 0.881015 0.971740 00:11 1 0.860780 0.892812 00:11 2 0.825322 0.880496 00:11 3 0.760412 0.866387 00:12 4 0.757029 0.866201 00:11 é€šè¿‡è®¾ç½®use_nnä¸ºtrueå‚æ•°èƒ½è½»æ¾åˆ›å»ºæ›´å¤šå±‚ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥åœ¨è¿™é‡Œåˆ†åˆ«åˆ›å»ºä¸¤ä¸ªå¤§å°ä¸º 100 å’Œ 50 çš„éšè—å±‚\nlearn = collab_learner(dls, use_nn=True, y_range=(0, 5.5), layers=[100,50]) learn.fit_one_cycle(5, 5e-3, wd=0.1) epoch train_loss valid_loss time 0 0.966844 0.984823 00:13 1 0.905129 0.915699 00:13 2 0.831309 0.894061 00:13 3 0.808309 0.867972 00:13 4 0.741418 0.864273 00:13 ","date":"28 March 2025","externalUrl":null,"permalink":"/posts/deeplearning/learning-pytorch-based-collaborative-filtering/","section":"Posts","summary":"","title":"Learning Pytorch Based Collaborative Filtering","type":"posts"},{"content":" Learning neural network further # æœ¬æ–‡å¤ç°çš„æ˜¯fastaiçš„å®˜æ–¹è§†é¢‘æ•™ç¨‹ ç‚¹å‡»æ­¤å¤„è·³è½¬\nå…¶å®˜æ–¹kaggleç¬”è®°æœ¬ ç‚¹å‡»æ­¤å¤„è·³è½¬\næœ¬ç¯‡åšå®¢æ˜¯åœ¨fastaiè¯¾ç¨‹åŸºç¡€ä¸Šè¿›è¡Œæ€»ç»“ï¼ŒåŸºäºkaggleä¸Šçš„paddy disease classificatinæ¯”èµ›ï¼Œä½¿ç”¨äº†Resnetæ¡†æ¶å’ŒConvnextæ¡†æ¶å®ç°å¯¹ç–¾ç—…çš„åˆ†ç±»ï¼Œç»“æœå‘ç°Convnextæ¯”Resnextæ•ˆæœæ›´å¥½ï¼Œå¹¶ä¸”ä½¿ç”¨äº†æµ‹è¯•æ—¶é—´å¢å¼ºï¼ˆTTAï¼‰ã€æ‰©å¤§è®­ç»ƒè§„æ¨¡ã€å¯¹å›¾åƒè¿›è¡Œå¡«å……ç­‰æ–¹å¼æ¢ç©¶é™ä½è¯¯å·®çš„æ•ˆæœï¼Œæœ€åè¿˜æ„å»ºäº†å¤šè¾“å‡ºæ¨¡å‹ï¼Œè¾“å‡ºç–¾ç—…ä»¥åŠç§ç±»ã€‚\nå‡†å¤‡é˜¶æ®µ # !pip install -Uq fastkaggle from fastai import * from fastkaggle import * comp = \u0026#39;paddy-disease-classification\u0026#39; path = setup_comp(comp, install=\u0026#39;fastai \u0026#34;timm\u0026gt;=0.6.2.dev0\u0026#34;\u0026#39;) path.ls() (#4) [Path(\u0026rsquo;../input/paddy-disease-classification/sample_submission.csv\u0026rsquo;),Path(\u0026rsquo;../input/paddy-disease-classification/train_images\u0026rsquo;),Path(\u0026rsquo;../input/paddy-disease-classification/train.csv\u0026rsquo;),Path(\u0026rsquo;../input/paddy-disease-classification/test_images\u0026rsquo;)]\nfrom fastai.vision.all import * trn_path = path/\u0026#39;train_images\u0026#39; imgfiles = get_image_files(trn_path) img = PILImage.create(imgfiles[0]) print(img.size) img.to_thumb(128) (480, 640)\nä¸è¿‡è¦æ³¨æ„çš„æ˜¯PILå±•ç¤ºçš„å›¾åƒå°ºå¯¸æ ¼å¼\nåº“/æ–¹æ³• å°ºå¯¸æ ¼å¼ å¤‡æ³¨ PIL / PILImage (å®½åº¦, é«˜åº¦) ç›´æ¥å¯¹åº”å›¾åƒçš„å®é™…åƒç´ å°ºå¯¸ OpenCV (é«˜åº¦, å®½åº¦) OpenCV ä½¿ç”¨ (h, w) çš„ NumPy é£æ ¼ matplotlib (å®½åº¦, é«˜åº¦) ä¸ PIL ä¸€è‡´ PyTorch (é€šé“, é«˜åº¦, å®½åº¦) å¼ é‡æ ¼å¼ï¼ˆéœ€é¢å¤–æ³¨æ„ï¼‰ ä¸ºæ£€æŸ¥æ‰€æœ‰å›¾åƒçš„å°ºå¯¸é‡‡ç”¨fastcoreä¸­çš„parallelæ¨¡å—å¹¶è¡Œå¤„ç†\nfrom fastcore.parallel import * def f(o): return PILImage.create(o).size sizes = parallel(f, imgfiles, n_workers=8) pd.Series(sizes).value_counts() (480, 640) 10403 (640, 480) 4 Name: count, dtype: int64\ndls = ImageDataLoaders.from_folder( trn_path, valid_pct=0.2, #å½“æœªåˆ’åˆ†è®­ç»ƒé›†å’ŒéªŒè¯é›†æ—¶éœ€è¦ä¼ é€’valid_pctå‚æ•° seed=42, item_tfms=Resize(480,method=\u0026#39;squish\u0026#39;), batch_tfms=aug_transforms(size=128,min_scale=0.75) ) item_tfms æ˜¯ ImageDataLoaders.from_folder() æ–¹æ³•çš„ä¸€ä¸ªå‚æ•°åï¼Œå…¨ç§°ä¸º â€‹item transformationsâ€‹ï¼ˆå•æ ·æœ¬å˜æ¢ï¼‰ã€‚å®ƒç”¨äºå®šä¹‰åœ¨æ•°æ®åŠ è½½æ—¶å¯¹å•ä¸ªå›¾åƒï¼ˆitemï¼‰åº”ç”¨çš„é¢„å¤„ç†æˆ–å¢å¼ºæ“ä½œã€‚\ndls.show_batch(max_n=6) fastai çš„ from_folder æ–¹å¼èƒ½ä»å­æ–‡ä»¶å¤¹åè‡ªåŠ¨æå–ç±»åˆ«ã€‚\né‡‡ç”¨Resnet26dè®­ç»ƒ # å®šä¹‰å­¦ä¹ æ¨¡å‹å¹¶æŸ¥æ‰¾å­¦ä¹ ç‡ # learn = vision_learner( dls, \u0026#39;resnet26d\u0026#39;, metrics=error_rate, path=\u0026#39;.\u0026#39;).to_fp16() model.safetensors: 0%| | 0.00/64.2M [00:00\u0026lt;?, ?B/s]\nå‚æ•° ä½œç”¨ ç¤ºä¾‹å€¼/ç±»å‹ è¡¥å……è¯´æ˜ dls æ•°æ®åŠ è½½å™¨ï¼ŒåŒ…å«è®­ç»ƒé›†å’ŒéªŒè¯é›† ImageDataLoaderså¯¹è±¡ éœ€é€šè¿‡ DataBlock æˆ–å·¥å‚å‡½æ•°ï¼ˆå¦‚ ImageDataLoaders.from_folderï¼‰ç”Ÿæˆ 'resnet26d' æ¨¡å‹æ¶æ„ï¼ˆResNetçš„å˜ä½“ï¼Œå¹³è¡¡é€Ÿåº¦å’Œç²¾åº¦ï¼‰ å­—ç¬¦ä¸²æˆ–nn.Module å…¶ä»–é€‰é¡¹ï¼š'resnet34', 'efficientnet_b0', 'convnext_tiny' ç­‰ metrics è®­ç»ƒæ—¶è®¡ç®—çš„è¯„ä¼°æŒ‡æ ‡ï¼ˆæ”¯æŒå•æŒ‡æ ‡æˆ–åˆ—è¡¨ï¼‰ error_rate å¸¸ç”¨æŒ‡æ ‡ï¼š\nâ€¢ accuracy\nâ€¢ Precision\nâ€¢ Recall\nâ€¢ F1Score\nâ€¢ RocAucï¼ˆäºŒåˆ†ç±»ï¼‰\nâ€¢ Perplexityï¼ˆè¯­è¨€æ¨¡å‹ï¼‰ path æ¨¡å‹å’Œæ—¥å¿—çš„ä¿å­˜ç›®å½•ï¼ˆ.è¡¨ç¤ºå½“å‰ç›®å½•ï¼‰ å­—ç¬¦ä¸²æˆ–Pathå¯¹è±¡ ä¿å­˜å†…å®¹åŒ…æ‹¬ï¼š\nâ€¢ æ¨¡å‹å‚æ•°ï¼ˆ.pthï¼‰\nâ€¢ è®­ç»ƒæ—¥å¿—ï¼ˆhistory.csvï¼‰ .to_fp16() å¯ç”¨æ··åˆç²¾åº¦è®­ç»ƒï¼ˆFP16ï¼‰ï¼ŒåŠ é€Ÿè®­ç»ƒå¹¶å‡å°‘æ˜¾å­˜å ç”¨ æ–¹æ³•è°ƒç”¨ éœ€GPUæ”¯æŒï¼ˆå¦‚NVIDIA Volta+æ¶æ„ï¼‰\nå¯ç”¨ .to_fp32() å¼ºåˆ¶ç¦ç”¨ æŸ¥æ‰¾ä¸€ä¸‹æœ€ä½³çš„å­¦ä¹ ç‡\nlearn.lr_find(suggest_funcs=(valley,slide)) SuggestedLRs(valley=0.0010000000474974513, slide=0.0020892962347716093)\nsuggest_funcs å‚æ•°ï¼šæŒ‡å®šå­¦ä¹ ç‡æ¨èç­–ç•¥\nvalleyï¼šé€‰æ‹©æŸå¤±ä¸‹é™æœ€é™¡å³­çš„ç‚¹ï¼ˆé¿å…è¿‡å¤§çš„å­¦ä¹ ç‡ï¼‰ã€‚\nslideï¼šé€‰æ‹©æŸå¤±å¼€å§‹å¹³ç¨³ä¸Šå‡çš„ç‚¹ï¼ˆä¿å®ˆä½†ç¨³å®šï¼‰ã€‚\nResnet26dæ¨¡å‹è®­ç»ƒ # learn.fine_tune(3,0.01) epoch train_loss valid_loss error_rate time 0 1.783480 1.293824 0.423835 00:42 epoch train_loss valid_loss error_rate time 0 1.128158 0.715136 0.238827 00:42 1 0.802069 0.490330 0.160980 00:42 2 0.569914 0.385769 0.135992 00:42 fine_tune() æ˜¯ fastai æä¾›çš„å¾®è°ƒæ–¹æ³•ï¼Œåˆ†ä¸¤é˜¶æ®µè‡ªåŠ¨è®­ç»ƒï¼š\n1)å†»ç»“é˜¶æ®µï¼ˆFreezeï¼‰â€‹\nä»…è®­ç»ƒæ–°å¢çš„å¤´éƒ¨å±‚â€‹ï¼ˆæ›¿æ¢åçš„æœ€åä¸€å±‚ï¼‰ï¼Œé¢„è®­ç»ƒä¸»å¹²å±‚ä¿æŒå†»ç»“ã€‚ é»˜è®¤1è½®â€‹ï¼ˆå¯é€šè¿‡ freeze_epochs ä¿®æ”¹ï¼‰ã€‚ å­¦ä¹ ç‡è‡ªåŠ¨è®¾ä¸º base_lr/10ï¼ˆè‹¥æœªæŒ‡å®š base_lrï¼Œåˆ™ç”¨ä¼ å…¥çš„ 0.01ï¼‰ã€‚\n2)è§£å†»é˜¶æ®µï¼ˆUnfreezeï¼‰â€‹\nè§£å†»æ‰€æœ‰å±‚ï¼Œå…¨éƒ¨å‚ä¸è®­ç»ƒã€‚ è®­ç»ƒå‰©ä½™è½®æ•°â€‹ï¼ˆæ­¤å¤„ 3 - 1 = 2 è½®ï¼‰ã€‚ ä½¿ç”¨ä¼ å…¥çš„å­¦ä¹ ç‡ 0.01ï¼ˆæˆ–é€šè¿‡ lr_find() ä¼˜åŒ–çš„å€¼ã€‚\nfastai çš„ vision_learner ä¼šè‡ªåŠ¨ä»æ•°æ®åŠ è½½å™¨ (dls) ä¸­æ¨æ–­è¾“å‡ºç»´åº¦\næ–°å¢çš„å¤´éƒ¨å±‚ï¼ˆNew Head Layersï¼‰â€‹ æ˜¯æŒ‡å½“ä½¿ç”¨é¢„è®­ç»ƒæ¨¡å‹ï¼ˆå¦‚ResNetã€EfficientNetç­‰ï¼‰è¿›è¡Œè¿ç§»å­¦ä¹ æ—¶ï¼Œâ€‹æ›¿æ¢æˆ–æ·»åŠ çš„æœ€åä¸€å±‚ï¼ˆæˆ–å‡ å±‚ï¼‰ç½‘ç»œç»“æ„ï¼Œç”¨äºé€‚é…å½“å‰ä»»åŠ¡çš„è¾“å‡ºéœ€æ±‚\nå°†è®­ç»ƒå¥½çš„Resnet26dåº”ç”¨åˆ°æµ‹è¯•é›†ä¸Š # tst_files = get_image_files(path/\u0026#39;test_images\u0026#39;).sorted() tst_dl = dls.test_dl(tst_files) test_dl() æ˜¯ â€‹fastai åº“ä¸­ DataLoaders å¯¹è±¡çš„ä¸€ä¸ªæ–¹æ³•ï¼Œä¸“é—¨ç”¨äºä¸ºæµ‹è¯•é›†ï¼ˆæˆ–æ¨ç†æ•°æ®ï¼‰â€‹åˆ›å»ºä¸€ä¸ªä¸è®­ç»ƒæ—¶æ•°æ®é¢„å¤„ç†ä¸€è‡´çš„æ•°æ®åŠ è½½å™¨\nprobs,_,idxs = learn.get_preds(dl=tst_dl, with_decoded=True) idxs tensor([7, 8, 4, \u0026hellip;, 8, 1, 5])\nmapping = dict(enumerate(dls.vocab)) results = pd.Series(idxs.numpy(), name=\u0026#34;idxs\u0026#34;).map(mapping) results 0 hispa\n1 normal\n2 brown_spot\n3 blast\n4 blast\nâ€‹ \u0026hellip; 3464 dead_heart\n3465 hispa\n3466 normal\n3467 bacterial_leaf_streak\n3468 dead_heart\nName: idxs, Length: 3469, dtype: object\nss = pd.read_csv(path/\u0026#39;sample_submission.csv\u0026#39;) ss[\u0026#39;label\u0026#39;] = results ss.to_csv(\u0026#39;subm.csv\u0026#39;, index=False) !head subm.csv image_id, label\n200001.jpg, hispa\n200002.jpg, normal\n200003.jpg, brown_spot\n200004.jpg, blast\n200005.jpg, blast\n200006.jpg, brown_spot\n200007.jpg, dead_heart\n200008.jpg, brown_spot\n200009.jpg, hispa\næ”¹è¿›ä¸€ä¸‹Resnet26d # ä¸ºäº†è®©æ¨¡å‹è®­ç»ƒçš„æ›´å¿«ï¼Œæˆ‘ä»¬å¯ä»¥å°†å›¾åƒçš„å¤§å°ç¼©å°ï¼ˆè®©åƒç´ æ•°é‡å‡å°‘4å€ï¼‰\ntrn_path = Path(\u0026#39;sml\u0026#39;) resize_images(path/\u0026#39;train_images\u0026#39;, dest=trn_path, max_size=256, recurse=True) fastai æœ‰ä¸€ä¸ªå‡½æ•°å¯ä»¥åšåˆ°è¿™ä¸€ç‚¹ï¼ŒåŒæ—¶ä¿æŒæ•°æ®çš„æ–‡ä»¶å¤¹ç»“æ„å³resize_images\ndls = ImageDataLoaders.from_folder(trn_path, valid_pct=0.2, seed=42, item_tfms=Resize((256,192))) dls.show_batch(max_n=3) å°†ä¹‹å‰è®­ç»ƒçš„æ­¥éª¤å°è£…èµ·æ¥\ndef train(arch, item, batch, epochs=5): dls = ImageDataLoaders.from_folder(trn_path, seed=42, valid_pct=0.2, item_tfms=item, batch_tfms=batch) learn = vision_learner(dls, arch, metrics=error_rate).to_fp16() learn.fine_tune(epochs, 0.01) return learn learn = train(\u0026#39;resnet26d\u0026#39;, item=Resize(192), batch=aug_transforms(size=128, min_scale=0.75)) epoch train_loss valid_loss error_rate time 0 1.942248 1.426470 0.463239 00:17 epoch train_loss valid_loss error_rate time 0 1.289961 0.999535 0.333974 00:19 1 1.018504 0.688591 0.216242 00:18 2 0.740462 0.482486 0.160019 00:18 3 0.529927 0.406155 0.124459 00:18 4 0.435775 0.372298 0.116771 00:18 å¯ä»¥çœ‹åˆ°å‡†ç¡®ç‡æ˜¯æœ‰äº†æå‡\nä½¿ç”¨ConNeXt_smallæ¨¡å‹ # å®šä¹‰convnext_small_in22kå­¦ä¹ æ¨¡å‹ # arch = \u0026#39;convnext_small_in22k\u0026#39; learn = train(arch, item=Resize(192, method=\u0026#39;squish\u0026#39;), batch=aug_transforms(size=128, min_scale=0.75)) epoch train_loss valid_loss error_rate time 0 1.245993 0.795927 0.255166 00:55 epoch train_loss valid_loss error_rate time 0 0.647190 0.434121 0.148967 00:53 1 0.477503 0.379062 0.119654 00:53 2 0.300822 0.191345 0.060548 00:52 3 0.192040 0.134807 0.039404 00:52 4 0.127018 0.125794 0.036521 00:52 æŸå¤±é™ä½äº†å¾ˆå¤šï¼ŒConvnextæ¨¡å‹åœ¨è¿™ä¸ªæ•°æ®é›†ä¸Šçš„æ•ˆæœè¦æ¯”Resnetå¥½\nå¯¹å›¾åƒè¿›è¡Œå¡«å……å¤„ç† # dls = ImageDataLoaders.from_folder(trn_path, valid_pct=0.2, seed=42, item_tfms=Resize(192, method=ResizeMethod.Pad, pad_mode=PadMode.Zeros)) dls.show_batch(max_n=3) å†æ¬¡è¿›è¡Œè®­ç»ƒ # learn = train(arch, item=Resize((256,192), method=ResizeMethod.Pad, pad_mode=PadMode.Zeros), batch=aug_transforms(size=(171,128), min_scale=0.75)) epoch train_loss valid_loss error_rate time 0 1.225350 0.838977 0.261413 00:44 epoch train_loss valid_loss error_rate time 0 0.647279 0.475882 0.153292 00:51 1 0.532679 0.375510 0.116290 00:51 2 0.348923 0.203416 0.067275 00:50 3 0.207750 0.132006 0.037001 00:50 4 0.140231 0.124632 0.035079 00:50 å¥½åƒæ•ˆæœä¹Ÿæ²¡å¾ˆå¤§çš„æå‡:(\nåº”ç”¨æµ‹è¯•æ—¶é—´å¢å¼ºTest time augmentationï¼ˆTTAï¼‰ # During inference or validation, creating multiple versions of each image, using data augmentation, and then taking the average or maximum of the predictions for each augmented version of the image. åœ¨æ¨ç†æˆ–éªŒè¯æœŸé—´ï¼Œä½¿ç”¨æ•°æ®å¢å¼ºåˆ›å»ºæ¯ä¸ªå›¾åƒçš„å¤šä¸ªç‰ˆæœ¬ï¼Œç„¶åå¯¹å›¾åƒçš„æ¯ä¸ªå¢å¼ºç‰ˆæœ¬å–é¢„æµ‹çš„å¹³å‡å€¼æˆ–æœ€å¤§å€¼ã€‚\nç”±ä¸Šé¢çš„è®­ç»ƒå¯çŸ¥åœ¨æ²¡æœ‰TTAçš„æƒ…å†µä¸‹é”™è¯¯ç‡æ˜¯ï¼š\nvalid = learn.dls.valid preds,targs = learn.get_preds(dl=valid) error_rate(preds, targs) TensorBase(0.0351)\ntta_preds,_ = learn.tta(dl=valid) error_rate(tta_preds, targs) TensorBase(0.0332)\né”™è¯¯ç‡æœ‰é™ä½ï¼\nå°†ConvNextåº”ç”¨çš„è§„æ¨¡æ‰©å¤§ # trn_path = path/\u0026#39;train_images\u0026#39; learn = train(arch, epochs=12, item=Resize((480, 360), method=ResizeMethod.Pad, pad_mode=PadMode.Zeros), batch=aug_transforms(size=(256,192), min_scale=0.75)) epoch train_loss valid_loss error_rate time 0 1.097865 0.666030 0.218645 01:10 epoch train_loss valid_loss error_rate time 0 0.530017 0.320848 0.103316 01:27 1 0.399917 0.254228 0.077367 01:28 2 0.354157 0.281102 0.087938 01:27 3 0.306803 0.235106 0.074003 01:27 4 0.222612 0.154293 0.043248 01:28 5 0.158987 0.174899 0.046612 01:27 6 0.127389 0.122164 0.035079 01:28 7 0.089526 0.120237 0.030754 01:27 8 0.070281 0.117129 0.032196 01:28 9 0.052415 0.094729 0.024507 01:27 10 0.044216 0.091565 0.024027 01:28 11 0.034039 0.091716 0.023546 01:28 åº”ç”¨tta\ntta_preds,targs = learn.tta(dl=learn.dls.valid) error_rate(tta_preds, targs) TensorBase(0.0226)\nå¯ä»¥çœ‹åˆ°æ˜¯é™ä½äº†æŸå¤±ç‡çš„\nå°†ConvNextåº”ç”¨åˆ°æµ‹è¯•é›†ä¸Š # tst_files = get_image_files(path/\u0026#39;test_images\u0026#39;).sorted() tst_dl = learn.dls.test_dl(tst_files) preds,_ = learn.tta(dl=tst_dl) idxs = preds.argmax(dim=1) ä½¿ç”¨PyTorch ä¸­çš„ argmaxæ¥é€‰å–å‡ºæœ€å¤§æ¦‚ç‡æ‰€åœ¨çš„æ ‡ç­¾ï¼Œdim=1å³æ²¿ç±»åˆ«ç»´åº¦ï¼ˆæ¯è¡Œï¼‰è®¡ç®—ï¼Œè¿”å›æ¯ä¸ªæ ·æœ¬é¢„æµ‹æ¦‚ç‡æœ€é«˜çš„ç±»åˆ«ç´¢å¼•\nvocab = np.array(learn.dls.vocab) # ä½¿ç”¨vocabæ˜ å°„ results = pd.Series(vocab[idxs], name=\u0026#34;idxs\u0026#34;) åœ¨ fastai ä¸­ï¼Œlearn.dls.vocab æ˜¯æ•°æ®åŠ è½½å™¨ (DataLoaders) çš„ç±»åˆ«æ ‡ç­¾åˆ—è¡¨ï¼Œç”¨äºå°†æ¨¡å‹è¾“å‡ºçš„é¢„æµ‹ç´¢å¼•ï¼ˆæ•°å­—ï¼‰æ˜ å°„å›å¯è¯»çš„ç±»åˆ«åç§°ï¼ˆå¦‚å­—ç¬¦ä¸²ï¼‰\nss = pd.read_csv(path/\u0026#39;sample_submission.csv\u0026#39;) ss[\u0026#39;label\u0026#39;] = results ss.to_csv(\u0026#39;subm2.csv\u0026#39;, index=False) !head subm2.csv image_id,label 200001.jpg,hispa 200002.jpg,normal 200003.jpg,blast 200004.jpg,blast 200005.jpg,blast 200006.jpg,brown_spot 200007.jpg,dead_heart 200008.jpg,brown_spot 200009.jpg,hispa\nåˆ›å»ºå¤šè¾“å‡ºçš„æ¨¡å‹ # åˆ›å»ºæ¨¡å‹å‡†å¤‡ # df = pd.read_csv(path/\u0026#39;train.csv\u0026#39;, index_col=\u0026#39;image_id\u0026#39;) df.head() label variety age image_id 100330.jpg bacterial_leaf_blight ADT45 45 100365.jpg bacterial_leaf_blight ADT45 45 100382.jpg bacterial_leaf_blight ADT45 45 100632.jpg bacterial_leaf_blight ADT45 45 101918.jpg bacterial_leaf_blight ADT45 45 æˆ‘ä»¬è®©image_idä½œä¸ºç´¢å¼•ï¼Œæ–¹ä¾¿æŸ¥æ‰¾\nDataBlockä½¿ç”¨ get_image_files æ¥è·å–è®­ç»ƒå›¾åƒåˆ—è¡¨ï¼Œè¯¥åˆ—è¡¨è¿”å› Path å¯¹è±¡ï¼Œè€Œå¦‚æœè¦æŸ¥æ‰¾æŸä¸ªé¡¹ç›®ä»¥è·å–å…¶ç§ç±»ï¼Œæˆ‘ä»¬éœ€è¦ä¼ é€’å…¶ name ã€‚è¿™æ˜¯ä¸€ä¸ªæ‰§è¡Œæ­¤æ“ä½œçš„å‡½æ•°ï¼š\ndef get_variety(p): return df.loc[p.name, \u0026#39;variety\u0026#39;] dls = DataBlock( blocks=(ImageBlock,CategoryBlock,CategoryBlock), n_inp=1, get_items=get_image_files, get_y = [parent_label,get_variety], splitter=RandomSplitter(0.2, seed=42), item_tfms=Resize(192, method=\u0026#39;squish\u0026#39;), batch_tfms=aug_transforms(size=128, min_scale=0.75) ).dataloaders(trn_path) ä½¿ç”¨ DataBlock APIï¼Œè¿™æ˜¯ä¸€ç§çµæ´»ä¸”æ–¹ä¾¿çš„æ–¹å¼ï¼Œå¯ä»¥å°†æ•°æ®å¤„ç†ç®¡é“çš„å„ä¸ªéƒ¨åˆ†è¿æ¥åœ¨ä¸€èµ· DataBlock å°†ä»æ¯ä¸ªæ–‡ä»¶ä¸­åˆ›å»º 3 ä¸ªå†…å®¹ï¼šä¸€ä¸ªå›¾åƒï¼ˆæ–‡ä»¶çš„å†…å®¹ï¼‰å’Œ 2 ä¸ªåˆ†ç±»å˜é‡ï¼ˆç–¾ç—…å’Œå“ç§ï¼‰ã€‚\ndls.show_batch(max_n=6) å®šä¹‰å¤šè¾“å‡ºçš„å­¦ä¹ æ¨¡å‹ # å¤šè¾“å‡ºçš„å…³é”®çš„åŒºåˆ«åœ¨äºï¼Œæˆ‘ä»¬çš„æŒ‡æ ‡å’ŒæŸå¤±ç°åœ¨å°†æ¥æ”¶ä¸‰ä¸ªä¸œè¥¿è€Œä¸æ˜¯ä¸¤ä¸ªï¼šæ¨¡å‹è¾“å‡ºï¼ˆå³æŒ‡æ ‡å’ŒæŸå¤±å‡½æ•°è¾“å…¥ï¼‰å’Œä¸¤ä¸ªç›®æ ‡ï¼ˆç–¾ç—…å’Œå¤šæ ·æ€§ï¼‰ã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦é‡æ–°å®šä¹‰æŒ‡æ ‡ï¼ˆ error_rate ï¼‰å’ŒæŸå¤±å‡½æ•°ï¼ˆ cross_entropy ï¼‰ï¼Œä»¥ä¼ é€’ disease ç›®æ ‡ï¼š\narch = \u0026#39;convnext_small_in22k\u0026#39; lr = 0.01 ä¸ºäº†é¢„æµ‹æ¯ç§ç–¾ç—…å’Œæ¯ç§ç–¾ç—…çš„æ¦‚ç‡ï¼Œæˆ‘ä»¬ç°åœ¨éœ€è¦æ¨¡å‹è¾“å‡ºä¸€ä¸ªé•¿åº¦ä¸º 20 çš„å¼ é‡ï¼Œå› ä¸ºæœ‰ 10 ç§å¯èƒ½çš„ç–¾ç—…å’Œ 10 ç§å¯èƒ½çš„ç–¾ç—…ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡è®¾ç½® n_out=20\nlearn = vision_learner(dls, arch, n_out=20).to_fp16() å› ä¸ºè¦é¢„æµ‹ä¸¤ä¸ªè¾“å‡ºäº†ï¼Œä¹‹å‰çš„æŸå¤±å‡½æ•°æ˜¯åªé’ˆå¯¹ç–¾ç—…çš„ï¼Œåœ¨è¿™é‡ŒæŸå¤±å‡½æ•°ä½¿ç”¨çš„æ˜¯cross_entropyå³äº¤å‰ç†µæŸå¤±å‡½æ•°\ndef disease_loss(inp,disease,variety): return F.cross_entropy(inp[:,:10],disease) def variety_loss(inp,disease,variety): return F.cross_entropy(inp[:,10:],variety) def combine_loss(inp,disease,variety):return disease_loss(inp,disease,variety)+variety_loss(inp,disease,variety) def disease_err(inp,disease,variety): return error_rate(inp[:,:10],disease) def variety_err(inp,disease,variety): return error_rate(inp[:,10:],variety) err_metrics = (disease_err,variety_err) all_metrics = err_metrics+(disease_loss,variety_loss) å¤šè¾“å‡ºæ¨¡å‹è®­ç»ƒ # learn = vision_learner(dls, arch, loss_func=combine_loss, metrics=all_metrics, n_out=20).to_fp16() learn.fine_tune(5, lr) epoch train_loss valid_loss disease_err variety_err disease_loss variety_loss time 0 2.276296 1.189668 0.257088 0.128304 0.783521 0.406147 00:51 epoch train_loss valid_loss disease_err variety_err disease_loss variety_loss time 0 1.005188 0.580068 0.127823 0.059106 0.387363 0.192705 00:54 1 0.757706 0.387292 0.094666 0.036040 0.280007 0.107285 00:53 2 0.477868 0.262185 0.061509 0.022585 0.193384 0.068801 00:54 3 0.269435 0.171966 0.040846 0.009611 0.134649 0.037317 00:54 4 0.200365 0.163008 0.037963 0.009130 0.124750 0.038258 00:53 æ·»åŠ softmaxå¹¶æŸ¥çœ‹è¾“å‡ºç»“æœ # # è·å–éªŒè¯é›†çš„é¢„æµ‹ preds, targs = learn.get_preds(dl=learn.dls.valid) print(learn.dls.vocab) print(len(learn.dls.vocab)) [[\u0026lsquo;bacterial_leaf_blight\u0026rsquo;, \u0026lsquo;bacterial_leaf_streak\u0026rsquo;, \u0026lsquo;bacterial_panicle_blight\u0026rsquo;, \u0026lsquo;blast\u0026rsquo;, \u0026lsquo;brown_spot\u0026rsquo;, \u0026lsquo;dead_heart\u0026rsquo;, \u0026lsquo;downy_mildew\u0026rsquo;, \u0026lsquo;hispa\u0026rsquo;, \u0026rsquo;normal\u0026rsquo;, \u0026rsquo;tungro\u0026rsquo;], [\u0026lsquo;ADT45\u0026rsquo;, \u0026lsquo;AndraPonni\u0026rsquo;, \u0026lsquo;AtchayaPonni\u0026rsquo;, \u0026lsquo;IR20\u0026rsquo;, \u0026lsquo;KarnatakaPonni\u0026rsquo;, \u0026lsquo;Onthanel\u0026rsquo;, \u0026lsquo;Ponni\u0026rsquo;, \u0026lsquo;RR\u0026rsquo;, \u0026lsquo;Surya\u0026rsquo;, \u0026lsquo;Zonal\u0026rsquo;]] 2\n# ç–¾ç—…ç±»åˆ«æœ‰10ä¸ªï¼Œå“ç§ç±»åˆ«ä¹Ÿæœ‰10ä¸ª num_classes_disease = len(learn.dls.vocab[0]) # 10 num_classes_variety = len(learn.dls.vocab[1]) # 10 # è·å–éªŒè¯é›†çš„é¢„æµ‹ preds, targs = learn.get_preds(dl=learn.dls.valid) # åˆ’åˆ†ç–¾ç—…å’Œå“ç§çš„é¢„æµ‹ç»“æœ disease_preds = preds[:, :num_classes_disease] # è·å–ç¬¬ä¸€éƒ¨åˆ†ï¼Œå³ç–¾ç—…çš„é¢„æµ‹ variety_preds = preds[:, num_classes_disease:] # è·å–ç¬¬äºŒéƒ¨åˆ†ï¼Œå³å“ç§çš„é¢„æµ‹ # ä½¿ç”¨ softmax è®¡ç®—æ¦‚ç‡ disease_probabilities = F.softmax(disease_preds, dim=1) variety_probabilities = F.softmax(variety_preds, dim=1) # è·å–åˆ†ç±»çš„æœ€å¤§æ¦‚ç‡å¯¹åº”çš„ç±»åˆ«ç´¢å¼• predicted_disease_classes = disease_probabilities.argmax(dim=1) # æ‰¾å‡ºç–¾ç—…ç±»åˆ«çš„é¢„æµ‹ predicted_variety_classes = variety_probabilities.argmax(dim=1) # æ‰¾å‡ºå“ç§ç±»åˆ«çš„é¢„æµ‹ # æ˜ å°„ç±»åˆ«ç´¢å¼•å›å®é™…æ ‡ç­¾ predicted_disease_labels = np.array(learn.dls.vocab[0])[predicted_disease_classes] predicted_variety_labels = np.array(learn.dls.vocab[1])[predicted_variety_classes] # æŸ¥çœ‹éƒ¨åˆ†é¢„æµ‹ç»“æœ results_df = pd.DataFrame({ \u0026#39;Predicted Disease\u0026#39;: predicted_disease_labels[:10], # å‰10ä¸ªçš„é¢„æµ‹ç–¾ç—… \u0026#39;Predicted Variety\u0026#39;: predicted_variety_labels[:10], # å‰10ä¸ªçš„é¢„æµ‹å“ç§ }) print(results_df) Predicted Disease Predicted Variety blast AndraPonni normal RR tungro ADT45 bacterial_leaf_streak KarnatakaPonni dead_heart ADT45 tungro ADT45 normal ADT45 normal ADT45 brown_spot ADT45 bacterial_leaf_blight ADT45 ","date":"27 March 2025","externalUrl":null,"permalink":"/posts/deeplearning/learning-based-paddydiseaseclassification/","section":"Posts","summary":"","title":"Learning NN Based Paddy_Disease_Classification","type":"posts"},{"content":" å“ˆå¸Œ # æœ¬ç³»åˆ—çš„å¤§éƒ¨åˆ†éƒ½æ˜¯å¯¹labuladongå’Œä»£ç éšæƒ³å½•ç½‘ç«™çš„é¢˜ç›®çš„ç»ƒæ‰‹æ±‡æ€»(éƒ¨åˆ†æ˜¯åšä¸»è‡ªå·±ç»“åˆleetcodeå’Œæ´›è°·é¢˜ç›®çš„è¡¥å……ï¼‰åˆè¡·æ˜¯åšä¸»è‡ªç”¨å­¦ä¹ å“’!\nè¯·æ‰€æœ‰é˜…è¯»è¿™ç³»åˆ—åšå®¢çš„å‹å‹å…ˆç§»æ­¥é˜…è§ˆä»–ä»¬çš„ç½‘ç«™ï¼Œæ²¡æœ‰è¿™äº›ä¼˜ç§€ç½‘ç«™çš„åˆ†äº«ä¸ä¼šæœ‰è¿™ç³»åˆ—çš„æ–‡ç« ï¼Œæˆ‘åªæ˜¯çŸ¥è¯†çš„æ¬è¿å·¥ï¼\nä¸¤æ•°ä¹‹å’Œ # é¢˜ç›®æè¿° # ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å€¼ targetï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡º å’Œä¸ºç›®æ ‡å€¼ target çš„é‚£ ä¸¤ä¸ª æ•´æ•°ï¼Œå¹¶è¿”å›å®ƒä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚\nä½ å¯ä»¥å‡è®¾æ¯ç§è¾“å…¥åªä¼šå¯¹åº”ä¸€ä¸ªç­”æ¡ˆï¼Œå¹¶ä¸”ä½ ä¸èƒ½ä½¿ç”¨ä¸¤æ¬¡ç›¸åŒçš„å…ƒç´ ã€‚\nä½ å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç­”æ¡ˆã€‚\nACä»£ç (ä»£ç éšæƒ³å½•) # class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { unordered_map\u0026lt;int,int\u0026gt;map; for(int i=0;i\u0026lt;nums.size();i++) { int n=target-nums[i]; if(map.find(n)!=map.end())return {map.find(n)-\u0026gt;second,i}; else map.insert(pair\u0026lt;int,int\u0026gt;(nums[i],i)); } return {}; } }; P1102 A-B æ•°å¯¹ # ç»™å‡ºä¸€ä¸²æ­£æ•´æ•°æ•°åˆ—ä»¥åŠä¸€ä¸ªæ­£æ•´æ•°C, è¦æ±‚è®¡ç®—å‡ºæ‰€æœ‰æ»¡è¶³ A - B = Câ€‹ çš„æ•°å¯¹çš„ä¸ªæ•°ï¼ˆä¸åŒä½ç½®çš„æ•°å­—ä¸€æ ·çš„æ•°å¯¹ç®—ä¸åŒçš„æ•°å¯¹ï¼‰ã€‚\nè¾“å…¥æ ¼å¼ # è¾“å…¥å…±ä¸¤è¡Œã€‚\nç¬¬ä¸€è¡Œï¼Œä¸¤ä¸ªæ­£æ•´æ•° N,Cã€‚\nç¬¬äºŒè¡Œï¼ŒN ä¸ªæ­£æ•´æ•°ï¼Œä½œä¸ºè¦æ±‚å¤„ç†çš„é‚£ä¸²æ•°ã€‚\nè¾“å‡ºæ ¼å¼ # ä¸€è¡Œï¼Œè¡¨ç¤ºè¯¥ä¸²æ­£æ•´æ•°ä¸­åŒ…å«çš„æ»¡è¶³ A - B = Câ€‹ çš„æ•°å¯¹çš„ä¸ªæ•°ã€‚\nè¾“å…¥ # 4 1 1 1 2 3\nè¾“å‡º # 3\nè¯´æ˜/æç¤º # å¯¹äº 75%â€‹ çš„æ•°æ®ï¼Œâ€‹1\u0026lt; N \u0026lt; 2000â€‹ã€‚\nå¯¹äº100%çš„æ•°æ®ï¼Œ1 \u0026lt; N \u0026lt; 2Ã—10^5â€‹ï¼Œ0 \u0026lt; a_i \u0026lt; 2^30â€‹ï¼Œ1 \u0026lt; C \u0026lt; 2^30â€‹ã€‚\nACä»£ç  # #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; int main(){ int N, C; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; C; vector\u0026lt;int\u0026gt; nums(N); unordered_map\u0026lt;int, int\u0026gt; freq; // ä½¿ç”¨ int ä½œä¸ºé¢‘æ¬¡ç±»å‹ for(int i=0;i\u0026lt;N;i++){ int x; cin \u0026gt;\u0026gt; x; nums[i]=x; freq[x]++; } ll res = 0;//æ³¨æ„ç»“æœæ˜¯long long å› ä¸ºresä¼šç´¯åŠ  for(const int \u0026amp;x : nums){ int target = x + C; if(freq.find(target) != freq.end()){ res += freq[target]; } } cout \u0026lt;\u0026lt; res; } ","date":"26 March 2025","externalUrl":null,"permalink":"/posts/algorithm/%E5%93%88%E5%B8%8C/","section":"Posts","summary":"","title":"å“ˆå¸Œ","type":"posts"},{"content":" å›æº¯ # æœ¬ç³»åˆ—çš„å¤§éƒ¨åˆ†éƒ½æ˜¯å¯¹labuladongå’Œä»£ç éšæƒ³å½•ç½‘ç«™çš„é¢˜ç›®çš„ç»ƒæ‰‹æ±‡æ€»(éƒ¨åˆ†æ˜¯åšä¸»è‡ªå·±ç»“åˆleetcodeå’Œæ´›è°·é¢˜ç›®çš„è¡¥å……ï¼‰åˆè¡·æ˜¯åšä¸»è‡ªç”¨å­¦ä¹ å“’!\nè¯·æ‰€æœ‰é˜…è¯»è¿™ç³»åˆ—åšå®¢çš„å‹å‹å…ˆç§»æ­¥é˜…è§ˆä»–ä»¬çš„ç½‘ç«™ï¼Œæ²¡æœ‰è¿™äº›ä¼˜ç§€ç½‘ç«™çš„åˆ†äº«ä¸ä¼šæœ‰è¿™ç³»åˆ—çš„æ–‡ç« ï¼Œæˆ‘åªæ˜¯çŸ¥è¯†çš„æ¬è¿å·¥ï¼\nå›æº¯ä¸‰éƒ¨æ›²labuladong\n1)ç¡®å®šå›æº¯å‡½æ•°çš„è¿”å›å€¼åŠå‚æ•°\næ¯æ¬¡å›æº¯æ—¶è¦æ›´æ–°ä»€ä¹ˆï¼Œè¦è¿”å›ä»€ä¹ˆ\n2ï¼‰å›æº¯å‡½æ•°çš„ç»ˆæ­¢æ¡ä»¶\n3ï¼‰å›æº¯æœç´¢çš„éå†è¿‡ç¨‹\nvector\u0026lt;vector\u0026gt; result\nvector path\nP4913 ã€æ·±åŸº16.ä¾‹3ã€‘äºŒå‰æ ‘æ·±åº¦ # é¢˜ç›®æè¿° # æœ‰ä¸€ä¸ª n(n\u0026lt;10^6)â€‹ ä¸ªç»“ç‚¹çš„äºŒå‰æ ‘ã€‚ç»™å‡ºæ¯ä¸ªç»“ç‚¹çš„ä¸¤ä¸ªå­ç»“ç‚¹ç¼–å·ï¼ˆå‡ä¸è¶…è¿‡ nï¼‰ï¼Œå»ºç«‹ä¸€æ£µäºŒå‰æ ‘ï¼ˆæ ¹èŠ‚ç‚¹çš„ç¼–å·ä¸º 1â€‹ï¼‰ï¼Œå¦‚æœæ˜¯å¶å­ç»“ç‚¹ï¼Œåˆ™è¾“å…¥ 0 0ã€‚\nå»ºå¥½è¿™æ£µäºŒå‰æ ‘ä¹‹åï¼Œè¯·æ±‚å‡ºå®ƒçš„æ·±åº¦ã€‚äºŒå‰æ ‘çš„æ·±åº¦æ˜¯æŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­ç»“ç‚¹æ—¶ï¼Œæœ€å¤šç»è¿‡äº†å‡ å±‚ã€‚\nè¾“å…¥æ ¼å¼ # ç¬¬ä¸€è¡Œä¸€ä¸ªæ•´æ•° nâ€‹ï¼Œè¡¨ç¤ºç»“ç‚¹æ•°ã€‚\nä¹‹å nè¡Œï¼Œç¬¬ i è¡Œä¸¤ä¸ªæ•´æ•° lã€rï¼Œåˆ†åˆ«è¡¨ç¤ºç»“ç‚¹ i çš„å·¦å³å­ç»“ç‚¹ç¼–å·ã€‚è‹¥ l=0 åˆ™è¡¨ç¤ºæ— å·¦å­ç»“ç‚¹ï¼Œr=0 åŒç†ã€‚\nè¾“å‡ºæ ¼å¼ # ä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºæœ€å¤§ç»“ç‚¹æ·±åº¦ã€‚\nè¾“å…¥ # 7 2 7 3 6 4 5 0 0 0 0 0 0 0 0 è¾“å‡º # 4 ACä»£ç  # #include \u0026lt;iostream\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include\u0026lt;math.h\u0026gt; using namespace std; unordered_map\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt; tree; int maxDepth = 0; void traverse(int node, int currentDepth) { int left = tree[node].first; int right = tree[node].second; maxDepth = max(maxDepth,currentDepth); // éå†å·¦å­æ ‘ if (left != 0) { traverse(left, currentDepth + 1); } // éå†å³å­æ ‘ if (right != 0) { traverse(right, currentDepth + 1); } } int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; tree[i] = {l, r}; } traverse(1, 1); cout \u0026lt;\u0026lt; maxDepth \u0026lt;\u0026lt; endl; return 0; } P1025 [NOIP 2001 æé«˜ç»„] æ•°çš„åˆ’åˆ† # é¢˜ç›®æè¿° # å°†æ•´æ•° n åˆ†æˆ kä»½ï¼Œä¸”æ¯ä»½ä¸èƒ½ä¸ºç©ºï¼Œä»»æ„ä¸¤ä¸ªæ–¹æ¡ˆä¸ç›¸åŒï¼ˆä¸è€ƒè™‘é¡ºåºï¼‰ã€‚\nä¾‹å¦‚ï¼šn=7â€‹ï¼Œk=3ï¼Œä¸‹é¢ä¸‰ç§åˆ†æ³•è¢«è®¤ä¸ºæ˜¯ç›¸åŒçš„ã€‚\n1,1,5â€‹;\n1,5,1â€‹;\nâ€‹5,1,1.\né—®æœ‰å¤šå°‘ç§ä¸åŒçš„åˆ†æ³•ã€‚\nè¾“å…¥æ ¼å¼ # n,kï¼ˆ6\u0026lt;n\u0026lt; 200,2 \u0026lt;k \u0026lt;6ï¼‰\nè¾“å‡ºæ ¼å¼ # 1 ä¸ªæ•´æ•°ï¼Œå³ä¸åŒçš„åˆ†æ³•ã€‚\nè¾“å…¥ # 7 3\nè¾“å‡º # 4\nè¯´æ˜/æç¤º # å››ç§åˆ†æ³•ä¸ºï¼š\n1,1,5;\n1,2,4;\n1,3,3;\n2,2,3.\nACä»£ç  # #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, k, res = 0; stack\u0026lt;int\u0026gt; path; // å›æº¯å‡½æ•° void backtrack(int start, int sum) { // å¦‚æœå·²ç»é€‰æ‹©äº†kä¸ªæ•° if (path.size() == k) { if (sum == n) { res++; } return; } // è®¡ç®—å½“å‰æ•°æœ€å¤§å¯ä»¥æ˜¯å¤šå°‘ï¼Œé¿å…æ— æ•ˆé€’å½’ int remaining = k - path.size(); int max_i = (n - sum) / remaining; for(int i = start; i \u0026lt;= max_i; i++) { path.push(i); backtrack(i, sum + i); // ä¸‹ä¸€è½®èµ·å§‹å€¼è‡³å°‘ä¸ºiï¼Œç¡®ä¿éé€’å‡!!!å› ä¸ºå¥½å‡ ç§ç®—é‡å¤ path.pop(); } } int main(){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; backtrack(1, 0); cout \u0026lt;\u0026lt; res; return 0; } æœªåŠ å…¥è®°å¿†æ•°ç»„ï¼Œçº¯é€’å½’ï¼Œè¶…æ—¶ï¼š\n#include \u0026lt;iostream\u0026gt; using namespace std; int count(int num) { if (num == 0) return 0; int res = 1; // åŒ…æ‹¬è‡ªèº«ä½œä¸ºä¸€ä¸ªæ•°åˆ—çš„æƒ…å†µ for (int i = 1; i \u0026lt;= num / 2; ++i) { res += count(i); } return res; } int main() { int n; cin \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; count(n) \u0026lt;\u0026lt; endl; return 0; } æ”¹è¿›ï¼š\n#include \u0026lt;iostream\u0026gt; using namespace std; int dp[100001] = {0}; // è®°å¿†åŒ–æ•°ç»„ int count(int num) { if (num == 0) return 0; if (dp[num] != 0) return dp[num]; // å·²è®¡ç®—è¿‡åˆ™ç›´æ¥è¿”å› dp[num] = 1; // åˆå§‹åŒ–ä¸º1ï¼ˆè‡ªèº«ï¼‰ for (int i = 1; i \u0026lt;= num / 2; ++i) { dp[num] += count(i); } return dp[num]; } int main() { int n; cin \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; count(n) \u0026lt;\u0026lt; endl; return 0; } #include \u0026lt;iostream\u0026gt; using namespace std; const int MAX_N = 100000; // æ ¹æ®é¢˜ç›®çº¦æŸè°ƒæ•´æœ€å¤§å€¼ int dp[MAX_N + 1]; int main() { int n; cin \u0026gt;\u0026gt; n; dp[0] = 0; dp[1] = 1; for (int num = 2; num \u0026lt;= n; ++num) { dp[num] = 1; // è‡³å°‘åŒ…å«è‡ªå·± for (int i = 1; i \u0026lt;= num / 2; ++i) { dp[num] += dp[i]; //æ±‚å’Œè¿‡ç¨‹ } } cout \u0026lt;\u0026lt; dp[n] \u0026lt;\u0026lt; endl; return 0; } ã€è“æ¡¥æ¯é¢˜åº“ã€‘81305. å°é½çš„å­—æ¯æ–¹å—æ‹¼å†™ # é—®é¢˜æè¿° # å°é½æœ‰å››ä¸ªæœ¨å—ï¼Œæ¯ä¸ªæœ¨å—æ˜¯ä¸€ä¸ªç«‹æ–¹ä½“ï¼Œä¸Šé¢åˆ†åˆ«å†™æœ‰å­—æ¯è¡¨çš„å¤§å†™å­—æ¯ã€‚å¥¹æƒ³é€šè¿‡æ’åˆ—è¿™äº›æœ¨å—ï¼Œæ‹¼å‡ºä¸€äº›å•è¯ã€‚\nç»™å®šæ¯ä¸ªæœ¨å—ä¸Šçš„å­—æ¯å’Œå°é½æƒ³æ‹¼å‡ºçš„å•è¯åˆ—è¡¨ï¼Œè¯·ç¡®å®šå¥¹èƒ½æˆåŠŸæ‹¼å‡ºå“ªäº›å•è¯ã€‚\nè¾“å…¥æ ¼å¼ # ç¬¬ä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•° Nï¼Œè¡¨ç¤ºå°é½æƒ³æ‹¼å‡ºçš„å•è¯æ•°é‡ã€‚\næ¥ä¸‹æ¥çš„å››è¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºä¸€ä¸ªæœ¨å—ä¸Šå…­ä¸ªå¤§å†™å­—æ¯ã€‚\næ¥ä¸‹æ¥çš„ Nè¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸€ä¸ªå°å†™å­—æ¯æ•°é‡åœ¨ 1 åˆ° 4 ä¹‹é—´çš„å¤§å†™å­—æ¯å•è¯ã€‚\nè¾“å‡ºæ ¼å¼ # å¯¹äºå°é½æƒ³æ‹¼å‡ºçš„æ¯ä¸ªå•è¯ï¼Œå¦‚æœå¥¹èƒ½æˆåŠŸæ‹¼å‡ºï¼Œè¾“å‡º YESï¼Œå¦åˆ™è¾“å‡º NOã€‚\næ ·ä¾‹è¾“å…¥ # 6 MOOOOO OOOOOO ABCDEF UVWXYZ COW MOO ZOO MOVE CODE FARM æ ·ä¾‹è¾“å‡º # YES NO YES YES NO NO è¯„æµ‹æ•°æ®è§„æ¨¡ # 1â‰¤Nâ‰¤10ã€‚\nACä»£ç  # #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; vector\u0026lt;string\u0026gt; table; vector\u0026lt;string\u0026gt; words; bool canSpell(const string\u0026amp; word, vector\u0026lt;bool\u0026gt;\u0026amp; used, int index) { if (index == word.size()) return true; for (int i = 0; i \u0026lt; 4; i++) { if (!used[i] \u0026amp;\u0026amp; table[i].find(word[index]) != string::npos) { //æ³¨æ„stringä¹Ÿæœ‰findæ–¹æ³• != string::npos å’Œ unordered_map != map.end() æœ‰ç‚¹ç±»ä¼¼ used[i] = true; if (canSpell(word, used, index + 1)) return true; used[i] = false; } } return false; } int main() { int n; cin \u0026gt;\u0026gt; n; table.resize(4); words.resize(n); for (int i = 0; i \u0026lt; 4; i++)cin \u0026gt;\u0026gt; table[i]; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; words[i]; for (int i = 0; i \u0026lt; n; i++) { vector\u0026lt;bool\u0026gt; used(4, false); if (canSpell(words[i], used, 0)) { cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } ","date":"26 March 2025","externalUrl":null,"permalink":"/posts/algorithm/%E5%9B%9E%E6%BA%AF/","section":"Posts","summary":"","title":"å›æº¯","type":"posts"},{"content":" å¹¶æŸ¥é›† # æœ¬ç³»åˆ—çš„å¤§éƒ¨åˆ†éƒ½æ˜¯å¯¹labuladongå’Œä»£ç éšæƒ³å½•ç½‘ç«™çš„é¢˜ç›®çš„ç»ƒæ‰‹æ±‡æ€»(éƒ¨åˆ†æ˜¯åšä¸»è‡ªå·±ç»“åˆleetcodeå’Œæ´›è°·é¢˜ç›®çš„è¡¥å……ï¼‰åˆè¡·æ˜¯åšä¸»è‡ªç”¨å­¦ä¹ å“’!\nè¯·æ‰€æœ‰é˜…è¯»è¿™ç³»åˆ—åšå®¢çš„å‹å‹å…ˆç§»æ­¥é˜…è§ˆä»–ä»¬çš„ç½‘ç«™ï¼Œæ²¡æœ‰è¿™äº›ä¼˜ç§€ç½‘ç«™çš„åˆ†äº«ä¸ä¼šæœ‰è¿™ç³»åˆ—çš„æ–‡ç« ï¼Œæˆ‘åªæ˜¯çŸ¥è¯†çš„æ¬è¿å·¥ï¼\nâ€œå¹¶æŸ¥é›†ç”¨äºè§£å†³è¿é€šæ€§é—®é¢˜â€\ntemplate\njoinå‡½æ•°ä¸€å®šè¦å…ˆé€šè¿‡findå‡½æ•°å¯»æ ¹å†è¿›è¡Œå…³è”\nint n = 1005; // næ ¹æ®é¢˜ç›®ä¸­èŠ‚ç‚¹æ•°é‡è€Œå®šï¼Œä¸€èˆ¬æ¯”èŠ‚ç‚¹æ•°é‡å¤§ä¸€ç‚¹å°±å¥½ vector\u0026lt;int\u0026gt; father (n, 0); // å¹¶æŸ¥é›†åˆå§‹åŒ– void init() { for (int i = 0; i \u0026lt; n; ++i) { father[i] = i; } } // å¹¶æŸ¥é›†é‡Œå¯»æ ¹çš„è¿‡ç¨‹ int find(int u) { return u == father[u] ? u : father[u] = find(father[u]); // è·¯å¾„å‹ç¼©,å°†å¤šå±‚å‹ç¼©ä¸ºä¸¤å±‚ï¼Œåªæœ‰ç¬¬ä¸€å±‚æ˜¯æ ¹èŠ‚ç‚¹ } // åˆ¤æ–­ u å’Œ væ˜¯å¦æ‰¾åˆ°åŒä¸€ä¸ªæ ¹ bool isSame(int u, int v) { u = find(u); v = find(v); return u == v; } // å°†v-\u0026gt;u è¿™æ¡è¾¹åŠ å…¥å¹¶æŸ¥é›† void join(int u, int v) { u = find(u); // å¯»æ‰¾uçš„æ ¹ v = find(v); // å¯»æ‰¾vçš„æ ¹ if (u == v) return ; // å¦‚æœå‘ç°æ ¹ç›¸åŒï¼Œåˆ™è¯´æ˜åœ¨ä¸€ä¸ªé›†åˆï¼Œä¸ç”¨ä¸¤ä¸ªèŠ‚ç‚¹ç›¸è¿ç›´æ¥è¿”å› father[v] = u; } åˆ é™¤å†—ä½™è¾¹â…¡ï¼ˆæœ‰å‘å›¾ï¼‰ # æœ‰ä¸€ç§æœ‰å‘æ ‘,è¯¥æ ‘åªæœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œæ‰€æœ‰å…¶ä»–èŠ‚ç‚¹éƒ½æ˜¯è¯¥æ ¹èŠ‚ç‚¹çš„åç»§ã€‚è¯¥æ ‘é™¤äº†æ ¹èŠ‚ç‚¹ä¹‹å¤–çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸”åªæœ‰ä¸€ä¸ªçˆ¶èŠ‚ç‚¹ï¼Œè€Œæ ¹èŠ‚ç‚¹æ²¡æœ‰çˆ¶èŠ‚ç‚¹ã€‚æœ‰å‘æ ‘æ‹¥æœ‰ n ä¸ªèŠ‚ç‚¹å’Œ n - 1 æ¡è¾¹ã€‚è¾“å…¥ä¸€ä¸ªæœ‰å‘å›¾ï¼Œè¯¥å›¾ç”±ä¸€ä¸ªæœ‰ç€ n ä¸ªèŠ‚ç‚¹(èŠ‚ç‚¹ç¼–å· ä» 1 åˆ° n)ï¼Œn æ¡è¾¹ï¼Œè¯·è¿”å›ä¸€æ¡å¯ä»¥åˆ é™¤çš„è¾¹ï¼Œä½¿å¾—åˆ é™¤è¯¥æ¡è¾¹ä¹‹åè¯¥æœ‰å‘å›¾å¯ä»¥è¢«å½“ä½œä¸€é¢—æœ‰å‘æ ‘ã€‚\nè¾“å…¥æè¿°\nç¬¬ä¸€è¡Œè¾“å…¥ä¸€ä¸ªæ•´æ•° Nï¼Œè¡¨ç¤ºæœ‰å‘å›¾ä¸­èŠ‚ç‚¹å’Œè¾¹çš„ä¸ªæ•°ã€‚\nåç»­ N è¡Œï¼Œæ¯è¡Œè¾“å…¥ä¸¤ä¸ªæ•´æ•° s å’Œ tï¼Œä»£è¡¨è¿™æ˜¯ s èŠ‚ç‚¹è¿æ¥å¹¶æŒ‡å‘ t èŠ‚ç‚¹çš„å•å‘è¾¹\nè¾“å‡ºæè¿°\nè¾“å‡ºä¸€æ¡å¯ä»¥åˆ é™¤çš„è¾¹ï¼Œè‹¥æœ‰å¤šæ¡è¾¹å¯ä»¥åˆ é™¤ï¼Œè¯·è¾“å‡ºæ ‡å‡†è¾“å…¥ä¸­æœ€åå‡ºç°çš„ä¸€æ¡è¾¹ã€‚\nè¾“å…¥ç¤ºä¾‹\n3 1 2 1 3 2 3 è¾“å‡ºç¤ºä¾‹\n2 3\né¢˜ç›®åˆ†æ # å¦‚æœå‘ç°å…¥åº¦ä¸º2çš„èŠ‚ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦åˆ¤æ–­ åˆ é™¤å“ªä¸€æ¡è¾¹ï¼Œåˆ é™¤åæœ¬å›¾èƒ½æˆä¸ºæœ‰å‘æ ‘ã€‚å¦‚æœæ˜¯åˆ å“ªä¸ªéƒ½å¯ä»¥ï¼Œä¼˜å…ˆåˆ é¡ºåºé åçš„è¾¹ã€‚æƒ…å†µä¸‰ï¼š å¦‚æœæ²¡æœ‰å…¥åº¦ä¸º2çš„ç‚¹ï¼Œè¯´æ˜ å›¾ä¸­æœ‰ç¯äº†ï¼ˆæ³¨æ„æ˜¯æœ‰å‘ç¯ï¼‰ã€‚\nisTreeAfterRemoveEdge() åˆ¤æ–­åˆ ä¸€ä¸ªè¾¹ä¹‹åæ˜¯ä¸æ˜¯æœ‰å‘æ ‘ï¼š å°†æ‰€æœ‰è¾¹çš„ä¸¤ç«¯èŠ‚ç‚¹åˆ†åˆ«åŠ å…¥å¹¶æŸ¥é›†ï¼Œé‡åˆ°è¦ è¦åˆ é™¤çš„è¾¹åˆ™è·³è¿‡ï¼Œå¦‚æœé‡åˆ°å³å°†åŠ å…¥å¹¶æŸ¥é›†çš„è¾¹çš„ä¸¤ç«¯èŠ‚ç‚¹ æœ¬æ¥å°±åœ¨å¹¶æŸ¥é›†äº†ï¼Œè¯´æ˜æ„æˆäº†ç¯ã€‚\nå¦‚æœé¡ºåˆ©å°†æ‰€æœ‰è¾¹çš„ä¸¤ç«¯èŠ‚ç‚¹ï¼ˆé™¤äº†è¦åˆ é™¤çš„è¾¹ï¼‰åŠ å…¥äº†å¹¶æŸ¥é›†ï¼Œåˆ™è¯´æ˜ åˆ é™¤è¯¥æ¡è¾¹ è¿˜æ˜¯ä¸€ä¸ªæœ‰å‘æ ‘\ngetRemoveEdge()ç¡®å®šå›¾ä¸­ä¸€å®šæœ‰äº†æœ‰å‘ç¯ï¼Œé‚£ä¹ˆè¦æ‰¾åˆ°éœ€è¦åˆ é™¤çš„é‚£æ¡è¾¹ï¼š å°†æ‰€æœ‰è¾¹çš„ä¸¤ç«¯èŠ‚ç‚¹åˆ†åˆ«åŠ å…¥å¹¶æŸ¥é›†ï¼Œå¦‚æœé‡åˆ°å³å°†åŠ å…¥å¹¶æŸ¥é›†çš„è¾¹çš„ä¸¤ç«¯èŠ‚ç‚¹ æœ¬æ¥å°±åœ¨å¹¶æŸ¥é›†äº†ï¼Œè¯´æ˜æ„æˆäº†ç¯ã€‚\nACä»£ç  # #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int n; vector\u0026lt;int\u0026gt; father (1001, 0); // å¹¶æŸ¥é›†åˆå§‹åŒ– void init() { for (int i = 1; i \u0026lt;= n; ++i) { father[i] = i; } } // å¹¶æŸ¥é›†é‡Œå¯»æ ¹çš„è¿‡ç¨‹ int find(int u) { return u == father[u] ? u : father[u] = find(father[u]); } // å°†v-\u0026gt;u è¿™æ¡è¾¹åŠ å…¥å¹¶æŸ¥é›† void join(int u, int v) { u = find(u); v = find(v); if (u == v) return ; father[v] = u; } // åˆ¤æ–­ u å’Œ væ˜¯å¦æ‰¾åˆ°åŒä¸€ä¸ªæ ¹ bool same(int u, int v) { u = find(u); v = find(v); return u == v; } // åœ¨æœ‰å‘å›¾é‡Œæ‰¾åˆ°åˆ é™¤çš„é‚£æ¡è¾¹ï¼Œä½¿å…¶å˜æˆæ ‘ void getRemoveEdge(const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { init(); // åˆå§‹åŒ–å¹¶æŸ¥é›† for (int i = 0; i \u0026lt; n; i++) { // éå†æ‰€æœ‰çš„è¾¹ if (same(edges[i][0], edges[i][1])) { // æ„æˆæœ‰å‘ç¯äº†ï¼Œå°±æ˜¯è¦åˆ é™¤çš„è¾¹ cout \u0026lt;\u0026lt; edges[i][0] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; edges[i][1]; return; } else { join(edges[i][0], edges[i][1]); } } } // åˆ ä¸€æ¡è¾¹ä¹‹ååˆ¤æ–­æ˜¯ä¸æ˜¯æ ‘ bool isTreeAfterRemoveEdge(const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges, int deleteEdge) { init(); // åˆå§‹åŒ–å¹¶æŸ¥é›† for (int i = 0; i \u0026lt; n; i++) { if (i == deleteEdge) continue; if (same(edges[i][0], edges[i][1])) { // æ„æˆæœ‰å‘ç¯äº†ï¼Œä¸€å®šä¸æ˜¯æ ‘ return false; } join(edges[i][0], edges[i][1]); } return true; } int main() { int s, t; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; edges; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; inDegree(n + 1, 0); // è®°å½•èŠ‚ç‚¹å…¥åº¦ for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; inDegree[t]++; edges.push_back({s, t}); } vector\u0026lt;int\u0026gt; vec; // è®°å½•å…¥åº¦ä¸º2çš„è¾¹ï¼ˆå¦‚æœæœ‰çš„è¯å°±ä¸¤æ¡è¾¹ï¼‰ // æ‰¾å…¥åº¦ä¸º2çš„èŠ‚ç‚¹æ‰€å¯¹åº”çš„è¾¹ï¼Œæ³¨æ„è¦å€’åºï¼Œå› ä¸ºä¼˜å…ˆåˆ é™¤æœ€åå‡ºç°çš„ä¸€æ¡è¾¹ for (int i = n - 1; i \u0026gt;= 0; i--) { if (inDegree[edges[i][1]] == 2) { vec.push_back(i); } } // æƒ…å†µä¸€ã€æƒ…å†µäºŒ if (vec.size() \u0026gt; 0) { // æ”¾åœ¨vecé‡Œçš„è¾¹å·²ç»æŒ‰ç…§å€’å™æ”¾çš„ï¼Œæ‰€ä»¥è¿™é‡Œå°±ä¼˜å…ˆåˆ vec[0]è¿™æ¡è¾¹ if (isTreeAfterRemoveEdge(edges, vec[0])) { cout \u0026lt;\u0026lt; edges[vec[0]][0] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; edges[vec[0]][1]; } else { cout \u0026lt;\u0026lt; edges[vec[1]][0] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; edges[vec[1]][1]; } return 0; } // å¤„ç†æƒ…å†µä¸‰ // æ˜ç¡®æ²¡æœ‰å…¥åº¦ä¸º2çš„æƒ…å†µï¼Œé‚£ä¹ˆä¸€å®šæœ‰æœ‰å‘ç¯ï¼Œæ‰¾åˆ°æ„æˆç¯çš„è¾¹è¿”å›å°±å¯ä»¥äº† getRemoveEdge(edges); } ä¹°äº‘æœµï¼ˆ01èƒŒåŒ…+å¹¶æŸ¥é›†ï¼‰ # é¢˜ç›®æè¿° # Joeè§‰å¾—äº‘æœµå¾ˆç¾ï¼Œå†³å®šå»å±±ä¸Šçš„å•†åº—ä¹°ä¸€äº›äº‘æœµã€‚å•†åº—é‡Œæœ‰næœµäº‘ï¼Œäº‘æœµè¢«ç¼–å·ä¸º1ï¼Œ2ï¼Œâ€¦ï¼Œnï¼Œå¹¶ä¸”æ¯æœµäº‘éƒ½æœ‰ä¸€ä¸ªä»·å€¼ã€‚ä½†æ˜¯å•†åº—è€æ¿è·Ÿä»–è¯´ï¼Œä¸€äº›äº‘æœµè¦æ­é…æ¥ä¹°æ‰å¥½ï¼Œæ‰€ä»¥ä¹°ä¸€æœµäº‘åˆ™ä¸è¿™æœµäº‘æœ‰æ­é…çš„äº‘éƒ½è¦ä¹°ã€‚\nä½†æ˜¯Joeçš„é’±æœ‰é™ï¼Œæ‰€ä»¥ä»–å¸Œæœ›ä¹°çš„ä»·å€¼è¶Šå¤šè¶Šå¥½ã€‚\nè¾“å…¥æ ¼å¼ # ç¬¬1è¡Œnï¼Œmï¼Œwï¼Œè¡¨ç¤ºnæœµäº‘ï¼Œmä¸ªæ­é…ï¼ŒJoeæœ‰wçš„é’±ã€‚\nç¬¬ 2-n+1 è¡Œï¼Œæ¯è¡Œ ciï¼Œdi è¡¨ç¤ºiæœµäº‘çš„ä»·é’±å’Œä»·å€¼ã€‚\nç¬¬n+2-n+1+mè¡Œï¼Œæ¯è¡Œ uiï¼Œviï¼Œè¡¨ç¤ºä¹°uiå°±å¿…é¡»ä¹°viï¼ŒåŒç†ï¼Œå¦‚æœä¹°viå°±å¿…é¡»ä¹°uiã€‚\nè¾“å‡ºæ ¼å¼ # ä¸€è¡Œï¼Œè¡¨ç¤ºå¯ä»¥è·å¾—çš„æœ€å¤§ä»·å€¼ã€‚\nè¾“å…¥æ ·ä¾‹ # 5 3 10 3 10 3 10 3 10 5 100 10 1 1 3 3 2 4 2\nè¾“å‡ºæ ·ä¾‹ # 1\nã€æç¤ºã€‘ ã€æ•°æ®èŒƒå›´ã€‘\n30%çš„æ•°æ®ä¿è¯ï¼šnâ‰¤100ï¼›\n50%çš„æ•°æ®ä¿è¯ï¼šnâ‰¤1,000ï¼›mâ‰¤100ï¼›wâ‰¤1,000ï¼›\n100%çš„æ•°æ®ä¿è¯ï¼šnâ‰¤10,000ï¼›0â‰¤mâ‰¤5000ï¼›wâ‰¤10,000ã€‚\nACä»£ç  # #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MAXN = 10010; int dp[MAXN]; // DPæ•°ç»„ï¼Œè¡¨ç¤ºåœ¨é’±ä¸ºjæ—¶çš„æœ€å¤§ä»·å€¼ int father[MAXN]; // å¹¶æŸ¥é›†çˆ¶èŠ‚ç‚¹ int cost[MAXN]; // æ¯ç»„çš„æˆæœ¬ int value[MAXN]; // æ¯ç»„çš„ä»·å€¼ vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; grid; // å­˜å‚¨æ¯æœµäº‘çš„æˆæœ¬å’Œä»·å€¼ // åˆå§‹åŒ–å¹¶æŸ¥é›† void init(int n) { for (int i = 1; i \u0026lt;= n; i++) { father[i] = i; cost[i] = grid[i].first; value[i] = grid[i].second; } } // æŸ¥æ‰¾å¹¶æŸ¥é›†çš„æ ¹èŠ‚ç‚¹ int find(int x) { return x == father[x] ? x : father[x] = find(father[x]); } // åˆå¹¶ä¸¤ä¸ªäº‘æœµçš„ç»„ void join(int u, int v) { u = find(u); v = find(v); if (u == v) return; // å·²ç»åœ¨åŒä¸€ç»„ father[v] = u; // åˆå¹¶ cost[u] += cost[v]; // åˆå¹¶æˆæœ¬ value[u] += value[v]; // åˆå¹¶ä»·å€¼ } int main() { int n, m, w; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; w; grid.resize(n + 1); // è°ƒæ•´å¤§å° for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; grid[i].first \u0026gt;\u0026gt; grid[i].second; } init(n); // åˆå§‹åŒ–å¹¶æŸ¥é›† // å¤„ç†æ­é…å…³ç³» for (int i = 1; i \u0026lt;= m; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; join(u, v); // åˆå¹¶äº‘æœµçš„ç»„ } // åŠ¨æ€è§„åˆ’æ±‚è§£ for (int i = 1; i \u0026lt;= n; i++) { if (father[i] == i) { // åªå¤„ç†æ ¹èŠ‚ç‚¹ for (int j = w; j \u0026gt;= cost[i]; j--) { dp[j] = max(dp[j], dp[j - cost[i]] + value[i]); } } } // è¾“å‡ºæœ€å¤§ä»·å€¼ cout \u0026lt;\u0026lt; dp[w] \u0026lt;\u0026lt; endl; return 0; } å°é½çš„å›¾è®ºä¹‹æ—… # é—®é¢˜æè¿° # å°é½æ­£åœ¨å­¦ä¹ å›¾è®ºè¯¾ç¨‹ï¼Œå¹¶é‡åˆ°äº†ä»¥ä¸‹é—®é¢˜ï¼Œå¥¹æ„Ÿåˆ°æœ‰äº›å›°æƒ‘ã€‚è¯·ä½ å¸®åŠ©å¥¹è§£å†³è¿™ä¸ªé—®é¢˜ï¼\nç»™å®šä¸€ä¸ªè¿é€šçš„æ— å‘å›¾ï¼Œå›¾ä¸­çš„é¡¶ç‚¹æ ‡å·ä¸º 1â€¦Nï¼Œè¾¹æ ‡å·ä¸º 1â€¦Mã€‚å¯¹äºå›¾ä¸­çš„æ¯ä¸ªé¡¶ç‚¹ vï¼Œæ‰§è¡Œä»¥ä¸‹è¿‡ç¨‹ï¼š\nä»¤ S=v ä¸” h=0ã€‚\nå½“ âˆ£Sâˆ£\u0026lt;N æ—¶ï¼š\nä»æ‰€æœ‰ä¸ S ä¸­æŸä¸€ç«¯ç‚¹ç›¸è¿çš„è¾¹ä¸­ï¼Œé€‰æ‹©æ ‡å·æœ€å°çš„è¾¹ eã€‚å°† e çš„å¦ä¸€ç«¯ç‚¹åŠ å…¥ Sã€‚\næ›´æ–°h=10Ã—h+eã€‚\nè¿”å› h mod 10^9+7ã€‚\næ±‚è§£è¯¥è¿‡ç¨‹çš„æ‰€æœ‰è¿”å›å€¼ã€‚\nè¾“å…¥æ ¼å¼ # ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° N å’Œ Mã€‚\næ¥ä¸‹æ¥æœ‰Mè¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸€æ¡è¾¹ (a_e,b_e) çš„ä¸¤ä¸ªç«¯ç‚¹ï¼Œè¡¨ç¤ºå›¾ä¸­çš„ä¸€æ¡è¾¹ï¼ˆ1â‰¤a_e\u0026lt;b_eâ‰¤N )ã€‚ä¿è¯è¿™äº›è¾¹æ„æˆä¸€æ£µè¿é€šæ ‘ï¼Œä¸”æ¯ä¸€å¯¹é¡¶ç‚¹ä¹‹é—´æœ€å¤šåªæœ‰ä¸€æ¡è¾¹ã€‚\nè¾“å‡ºæ ¼å¼ # è¾“å‡º N è¡Œï¼Œå…¶ä¸­ç¬¬ i è¡Œåº”åŒ…å«ä»é¡¶ç‚¹ i å¼€å§‹æ‰§è¡Œè¿‡ç¨‹æ—¶çš„è¿”å›å€¼ã€‚\næ ·ä¾‹è¾“å…¥ # 3 2 1 2 2 3 æ ·ä¾‹è¾“å‡º # 12 12 21 è¯„æµ‹æ•°æ®è§„æ¨¡\n2â‰¤Nâ‰¤2Ã—10^5ï¼Œ Nâˆ’1â‰¤Mâ‰¤4Ã—10^5ã€‚\nTLEä»£ç  # //TLEäº†ï¼Œä»…ä½œæ€è·¯å€Ÿé‰´ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MOD = 1e9 + 7; struct Edge { int l, r; int val; }; struct CompareEdge { bool operator()(const Edge\u0026amp; a, const Edge\u0026amp; b) { return a.val \u0026gt; b.val; } }; int main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;Edge\u0026gt; edges(m + 1, {0, 0, 0}); vector\u0026lt;vector\u0026lt;Edge\u0026gt;\u0026gt; adj(n + 1); for (int i = 1; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; edges[i].l \u0026gt;\u0026gt; edges[i].r; edges[i].val = i; adj[edges[i].l].push_back(edges[i]); adj[edges[i].r].push_back(edges[i]); } vector\u0026lt;long long\u0026gt; result(n + 1, 0); for (int start = 1; start \u0026lt;= n; start++) { vector\u0026lt;bool\u0026gt; isinS(n + 1, false); isinS[start] = true; priority_queue\u0026lt;Edge, vector\u0026lt;Edge\u0026gt;, CompareEdge\u0026gt; pq; for (Edge\u0026amp; edge : adj[start]) { pq.push(edge); } int count = 1; long long h = 0; while (count \u0026lt; n \u0026amp;\u0026amp; !pq.empty()) { Edge edge = pq.top(); pq.pop(); int next = (isinS[edge.l]) ? edge.r : edge.l; if (isinS[next]) continue; isinS[next] = true; count++; h = (10 * h + edge.val) % MOD; for (Edge\u0026amp; edge : adj[next]) { if (!isinS[edge.l] || !isinS[edge.r]) { pq.push(edge); } } } result[start] = h; } for (int i = 1; i \u0026lt;= n; i++) { cout \u0026lt;\u0026lt; result[i] \u0026lt;\u0026lt; endl; } return 0; } ","date":"26 March 2025","externalUrl":null,"permalink":"/posts/algorithm/%E5%B9%B6%E6%9F%A5%E9%9B%86/","section":"Posts","summary":"","title":"å¹¶æŸ¥é›†","type":"posts"},{"content":" è“æ¡¥æ¯C++é¢˜åº“2023-1 # åšä¸»éACMerï¼Œé¢˜ç›®ä»£ç åˆ†æå¯èƒ½ä¼šæœ‰åé¢‡ï¼Œå»ºè®®è°¨æ…å‚è€ƒåšä¸»çš„ACä»£ç ã€‚åˆ†å¸ƒè¿™ç³»åˆ—çš„å¸–å­çš„åˆè¡·æ˜¯åˆ†äº«å®˜æ–¹çš„é¢˜åº“ï¼Œä»¥æ–¹ä¾¿å‹å‹ä»¬å¤‡èµ›:)\nå¶ä¸² # å°è“ç‰¹åˆ«å–œæ¬¢å¶æ•°ï¼Œå½“ä»–çœ‹åˆ°å­—ç¬¦ä¸²æ—¶ï¼Œä»–æ€»æ•°è¦æ£€æŸ¥ä¸€ä¸‹æ˜¯ä¸æ˜¯æ¯ç§å­—ç¬¦éƒ½æ˜¯å‡ºç°å¶æ•°æ¬¡ã€‚ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¯·å¸®åŠ©å°è“æ£€æŸ¥ä¸€ä¸‹è¯¥å­—ç¬¦ä¸²æ˜¯å¦æ»¡è¶³è¦æ±‚ã€‚\nè¾“å…¥æè¿° # è¾“å…¥ä¸€è¡ŒåŒ…å«ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆã€‚\nè¾“å‡ºæè¿° # å¦‚æœå­—ç¬¦ä¸²ä¸­çš„æ¯ç§å­—ç¬¦éƒ½æ˜¯å‡ºç°å¶æ•°æ¬¡ï¼Œè¾“å‡ºå¤§å†™è‹±æ–‡å•è¯ YES ï¼Œå¦åˆ™è¾“å‡ºå¤§å†™è‹±æ–‡å•è¯ NOã€‚\næ ·ä¾‹è¾“å…¥ # banana æ ·ä¾‹è¾“å‡º # NO è¯„æµ‹ç”¨ä¾‹è§„æ¨¡ # å¯¹äº 50%çš„è¯„æµ‹ç”¨ä¾‹ï¼Œ 1â‰¤ å­—ç¬¦ä¸²é•¿åº¦ â‰¤1000ï¼›\nå¯¹äºæ‰€æœ‰è¯„æµ‹ç”¨ä¾‹ï¼Œ1â‰¤ å­—ç¬¦ä¸²é•¿åº¦ â‰¤10^6 ã€‚\nACä»£ç  # åšä¸»ç¬¬ä¸€ååº”å°±æ˜¯unordered_mapï¼Œä¹Ÿå°±ç”¨å®ƒåšå‡ºæ¥äº†\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { unordered_map\u0026lt;char, int\u0026gt; map; string s; cin \u0026gt;\u0026gt; s; for (int i = 0; i \u0026lt; s.size(); i++) { map[s[i]]++; } for (auto\u0026amp; pair : map) { if (pair.second % 2 != 0) { cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34;; return 0; } } cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34;; return 0; } åˆ’åˆ† # é—®é¢˜æè¿° # ç»™å®š 40ä¸ªæ•°ï¼Œè¯·å°†å…¶ä»»æ„åˆ’åˆ†æˆä¸¤ç»„ï¼Œæ¯ç»„è‡³å°‘ä¸€ä¸ªå…ƒç´ ã€‚æ¯ç»„çš„æƒå€¼ä¸ºç»„å†…æ‰€æœ‰å…ƒç´ çš„å’Œã€‚åˆ’åˆ†çš„æƒå€¼ä¸ºä¸¤ç»„æƒå€¼çš„ä¹˜ç§¯ã€‚è¯·é—®å¯¹äºä»¥ä¸‹ 40 ä¸ªæ•°ï¼Œåˆ’åˆ†çš„æƒå€¼æœ€å¤§ä¸ºå¤šå°‘ã€‚\né—®é¢˜åˆ†æ # è¿™ä¸ªé¢˜å…ˆä»äºŒç»´æ•°ç»„åˆ†æï¼Œåšä¸»ç®€å•çš„ç”»äº†ä¸ªå›¾ï¼Œé€šè¿‡åˆ†æå¯ä»¥çœ‹å‡ºdp[i] [j] æ˜¯ç”±â€‹ dp[i-1] [j] â€‹å’Œ dp[i] [j-nums [i]] å…±åŒå½±å“çš„ã€‚\nç„¶åå†å‹ç¼©ä¸ºä¸€ç»´æ•°ç»„è§£å†³ã€‚\nå…·ä½“æ€è·¯å¯å‚è€ƒä»£ç éšæƒ³å½•çš„0-1èƒŒåŒ…åŸºç¡€ç†è®º2,è™½ç„¶æ˜¯ä»¥0-1èƒŒåŒ…ä¸¾ä¾‹ä½†æ˜¯å°†äºŒç»´æ•°ç»„å‹ç¼©ä¸ºä¸€ç»´æ•°ç»„çš„æ€è·¯å’Œæ³¨æ„çš„åœ°æ–¹å¯ä»¥å€Ÿé‰´ã€‚\nACä»£ç  # ç›´è§‰å°±æ˜¯åˆ†æˆä¸¤ç»„å’Œå·®ä¸å¤šçš„ä¸¤éƒ¨åˆ†ï¼Œè¿™æ ·ä¹˜ç§¯æœ€å¤§ã€‚ä¹Ÿå°±æ˜¯è¯´ä¸¤éƒ¨åˆ†çš„å’Œå°½é‡é è¿‘sum/2\né‡‡ç”¨åŠ¨æ€è§„åˆ’ï¼Œå®šä¹‰å¸ƒå°”æ•°ç»„dp[ i ] [ j ]ï¼Œè¡¨ç¤ºåœ¨å‰ç´¢å¼•ä¸º0-iä¸ªæ•°ä¸­ï¼Œæ˜¯å¦å­˜åœ¨å’Œä¸º j çš„ç»„åˆ\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { int nums[40] = {5160, 9191, 6410, 4657, 7492, 1531, 8854, 1253, 4520, 9231, 1266, 4801, 3484, 4323, 5070, 1789, 2744, 5959, 9426, 4433, 4404, 5291, 2470, 8533, 7608, 2935, 8922, 5273, 8364, 8819, 7374, 8077, 5336, 8495, 5602, 6553, 3548, 5267, 9150, 3309}; int total_sum = 0; for (int i = 0; i \u0026lt; 40; i++) { total_sum += nums[i]; } vector\u0026lt;bool\u0026gt; dp(total_sum / 2 + 1, false); dp[0] = true; for (int i = 0; i \u0026lt; 40; i++) { for (int j = total_sum / 2; j \u0026gt;= nums[i]; j--) { if (dp[j - nums[i]]) { dp[j] = true; } } } long long max_product = 0; for (int i = total_sum / 2; i \u0026gt;= 0; i--) { if (dp[i]) { max_product = (long long)i * (total_sum - i); break; } } cout \u0026lt;\u0026lt; max_product \u0026lt;\u0026lt; endl; return 0; } ç³–æœåˆ†é… # é—®é¢˜æè¿° # ä¸¤ç§ç³–æœåˆ†åˆ«æœ‰9ä¸ªå’Œ 16 ä¸ªï¼Œè¦å…¨éƒ¨åˆ†ç»™ 7 ä¸ªå°æœ‹å‹ï¼Œæ¯ä¸ªå°æœ‹å‹å¾—åˆ°çš„ç³–æœæ€»æ•°æœ€å°‘ä¸º 2 ä¸ªæœ€å¤šä¸º 5 ä¸ªï¼Œé—®æœ‰å¤šå°‘ç§ä¸åŒçš„åˆ†æ³•ã€‚ç³–æœå¿…é¡»å…¨éƒ¨åˆ†å®Œã€‚\nåªè¦æœ‰å…¶ä¸­ä¸€ä¸ªå°æœ‹å‹åœ¨ä¸¤ç§æ–¹æ¡ˆä¸­åˆ†åˆ°çš„ç³–æœä¸å®Œå…¨ç›¸åŒï¼Œè¿™ä¸¤ç§æ–¹æ¡ˆå°±ç®—ä½œä¸åŒçš„æ–¹æ¡ˆã€‚\nACä»£ç  # #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int res=0; void dfs(int idx, int a_size, int b_size) { if (idx == 7) { if(a_size == 0 \u0026amp;\u0026amp; b_size == 0)res++; return; } for (int i = 0; i \u0026lt;= a_size; i++) { for (int j = 0; j \u0026lt;= b_size; j++) { if (i + j \u0026gt;= 2 \u0026amp;\u0026amp; i + j \u0026lt;= 5) { dfs(idx + 1, a_size - i, b_size - j); } } } } int main() { int a = 16, b = 9; dfs(0, a, b); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } æ··ä¹˜æ•°å­— # é—®é¢˜æè¿° # æ··ä¹˜æ•°å­—çš„å®šä¹‰å¦‚ä¸‹: å¯¹äºä¸€ä¸ªæ­£æ•´æ•° ğ‘›ï¼Œå¦‚æœå­˜åœ¨æ­£æ•´æ•° ğ‘,ğ‘ï¼Œä½¿å¾—ğ‘›=ğ‘Ã—ğ‘ï¼Œè€Œä¸” ğ‘å’Œ ğ‘çš„åè¿›åˆ¶æ•°ä½ä¸­æ¯ä¸ªæ•°å­—å‡ºç°çš„æ¬¡æ•°ä¹‹å’Œä¸ ğ‘›ä¸­å¯¹åº”æ•°å­—å‡ºç°æ¬¡æ•°ç›¸åŒï¼Œåˆ™ç§° ğ‘›ä¸ºæ··ä¹˜æ•°å­—ã€‚ä¾‹å¦‚ï¼Œå¯¹äºæ­£æ•´æ•° ğ‘›=126ï¼Œå­˜åœ¨ ğ‘=6, ğ‘=21æ»¡è¶³æ¡ä»¶ï¼Œå› æ­¤126æ˜¯ä¸€ä¸ªæ··ä¹˜æ•°å­—ã€‚åˆå¦‚ï¼Œå¯¹äºæ­£æ•´æ•° ğ‘›=180225ï¼Œå­˜åœ¨ ğ‘=225, ğ‘=801 æ»¡è¶³æ¡ä»¶ï¼Œå› æ­¤ 180225 æ˜¯ä¸€ä¸ªæ··ä¹˜æ•°å­—ã€‚è¯·ä½ å¸®åŠ©è®¡ç®—å‡ºï¼Œ1âˆ¼1000000(å«)ä¹‹é—´ä¸€å…±æœ‰å¤šå°‘ä¸ªæ•°å­—æ˜¯æ··ä¹˜æ•°å­—ã€‚\nACä»£ç  # #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; bool judge(int a, int b, int c, int* valid) { fill(valid, valid+10, 0); while(a){valid[a%10]++;a/=10;} while(b){valid[b%10]++;b/=10;} while(c){valid[c%10]--;c/=10;} for(int i=0;i\u0026lt;10;i++) if(valid[i]!=0) return false; return true; } int main() { const int n = 1e6; vector\u0026lt;bool\u0026gt; nums(n+1, false); int res = 0; for(int i=1; i\u0026lt;=n; i++){ for(int j=1; j\u0026lt;=i \u0026amp;\u0026amp; i*j\u0026lt;=n; j++){ int valid[10]={0}; if(judge(i,j,i*j,valid) \u0026amp;\u0026amp; !nums[i*j]){ nums[i*j] = true; //æ³¨æ„ï¼ä¸€å¼€å§‹æ²¡åŠ boolç±»å‹çš„numsæ•°ç»„ï¼Œå…¶å®næ˜¯å¯èƒ½é‡å¤è®¡æ•°çš„ res++; } } } cout \u0026lt;\u0026lt; res; return 0; } ä¿é™©ç®± # é—®é¢˜æè¿° # å°è“æœ‰ä¸€ä¸ªä¿é™©ç®±ï¼Œä¿é™©ç®±ä¸Šå…±æœ‰ n ä½æ•°å­—ã€‚å°è“å¯ä»¥ä»»æ„è°ƒæ•´ä¿é™©ç®±ä¸Šçš„æ¯ä¸ªæ•°å­—ï¼Œæ¯ä¸€æ¬¡æ“ä½œå¯ä»¥å°†å…¶ä¸­ä¸€ä½å¢åŠ  1 æˆ–å‡å°‘ 1ã€‚å½“æŸä½åŸæœ¬ä¸º 9 æˆ– 0 æ—¶å¯èƒ½ä¼šå‘å‰ï¼ˆå·¦è¾¹ï¼‰è¿›ä½/é€€ä½ï¼Œå½“æœ€é«˜ä½ï¼ˆå·¦è¾¹ç¬¬ä¸€ä½ï¼‰ä¸Šçš„æ•°å­—å˜åŒ–æ—¶å‘å‰çš„è¿›ä½æˆ–é€€ä½å¿½ç•¥ã€‚\nç¤ºä¾‹ï¼š\n00000 çš„ç¬¬ 5 ä½å‡ 1 å˜ä¸º 99999ï¼› 99999 çš„ç¬¬ 5 ä½å‡ 1 å˜ä¸º 99998ï¼› 00000 çš„ç¬¬ 4 ä½å‡ 1 å˜ä¸º 99990ï¼› 97993 çš„ç¬¬ 4 ä½åŠ  1 å˜ä¸º 98003ï¼› 99909 çš„ç¬¬ 3 ä½åŠ  1 å˜ä¸º 00009ã€‚ ä¿é™©ç®±ä¸Šä¸€å¼€å§‹æœ‰ä¸€ä¸ªæ•°å­— xï¼Œå°è“å¸Œæœ›æŠŠå®ƒå˜æˆ yï¼Œè¿™æ ·æ‰èƒ½æ‰“å¼€å®ƒã€‚é—®å°è“æœ€å°‘éœ€è¦æ“ä½œçš„æ¬¡æ•°ã€‚\nè¾“å…¥æ ¼å¼ # ç¬¬ä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•° nã€‚ ç¬¬äºŒè¡ŒåŒ…å«ä¸€ä¸ª n ä½æ•´æ•° xã€‚ ç¬¬ä¸‰è¡ŒåŒ…å«ä¸€ä¸ª n ä½æ•´æ•° yã€‚ è¾“å‡ºæ ¼å¼ # è¾“å‡ºä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•°è¡¨ç¤ºç­”æ¡ˆã€‚\næ ·ä¾‹è¾“å…¥ # 5\n12349\n54321\næ ·ä¾‹è¾“å‡º # 11\nå¯¹äº 30% çš„è¯„æµ‹ç”¨ä¾‹ï¼Œ1 â‰¤ n â‰¤ 300ï¼› å¯¹äº 60% çš„è¯„æµ‹ç”¨ä¾‹ï¼Œ1 â‰¤ n â‰¤ 3000ï¼› å¯¹äºæ‰€æœ‰è¯„æµ‹ç”¨ä¾‹ï¼Œ1 â‰¤ n â‰¤ 1e5ï¼Œx å’Œ y ä¸­ä»…åŒ…å«æ•°å­— 0 è‡³ 9ï¼Œå¯èƒ½æœ‰å‰å¯¼é›¶ã€‚ ACä»£ç  # è¿™ä¸ªçŠ¶æ€æ–¹ç¨‹æ²¡æƒ³å‡ºæ¥:(\nå®šä¹‰åŠ¨æ€è§„åˆ’çŠ¶æ€ dp[i][j]ï¼Œå…¶ä¸­ï¼š\ni è¡¨ç¤ºå½“å‰å¤„ç†åˆ°æ•°å­—çš„ç¬¬ i ä½ï¼ˆä»ä½ä½åˆ°é«˜ä½ï¼Œå³ä»å³åˆ°å·¦ï¼‰ã€‚ j è¡¨ç¤ºå½“å‰ä½çš„è¿›ä½/é€€ä½çŠ¶æ€ï¼š j = 0ï¼šç¬¬ i ä½æ—¢æ²¡æœ‰è¿›ä½ä¹Ÿæ²¡æœ‰é€€ä½çš„æ“ä½œæ•°ã€‚ j = 1ï¼šç¬¬ i ä½è¿›è¡Œäº†è¿›ä½ï¼ˆå³å½“å‰ä½æ•°å­— +1 åå½±å“äº†é«˜ä½ï¼‰çš„æ“ä½œæ•°ã€‚ j = 2ï¼šç¬¬ i ä½è¿›è¡Œäº†é€€ä½ï¼ˆå³å½“å‰ä½æ•°å­— -1 åå½±å“äº†é«˜ä½ï¼‰çš„æ“ä½œæ•°ã€‚ #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt;xv(n,0),yv(n,0); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;dp(n,vector\u0026lt;int\u0026gt;(3,0)); string x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; reverse(x.begin(),x.end()); reverse(y.begin(),y.end()); for(int i=0;i\u0026lt;n;i++) { xv[i]=x[i]-\u0026#39;0\u0026#39;; yv[i]=y[i]-\u0026#39;0\u0026#39;; } for(int i=0;i\u0026lt;n;i++) { if(i==0) { dp[i][0]=abs(xv[i]-yv[i]); dp[i][1]=yv[i]-xv[i]+10; dp[i][2]=xv[i]-yv[i]+10; } else { dp[i][0]=min({dp[i-1][0]+abs(yv[i]-xv[i]), dp[i-1][1]+abs(xv[i]+1-yv[i]), dp[i-1][2]+abs(xv[i]-1-yv[i])}); dp[i][1]=min({dp[i-1][0]+(10+yv[i]-xv[i]), dp[i-1][1]+(10+yv[i]-(xv[i]+1)), //ä¸Šä¸€ä½å› ä¸ºè¿›ä½ï¼Œå› æ­¤xv[i]+1ã€‚åˆå› ä¸ºè¿™ä¸€ä½è¦é€šè¿‡è¿›ä½åŒ¹é…ï¼Œæ‰€ä»¥åŠ ä¸Š10 dp[i-1][2]+(10+yv[i]-(xv[i]-1))}); //ä»¥æ­¤ç±»æ¨ dp[i][2]=min({dp[i-1][0]+(10+xv[i]-yv[i]), dp[i-1][1]+(10+xv[i]+1-yv[i]), dp[i-1][2]+(10+xv[i]-1-yv[i])}); } } cout\u0026lt;\u0026lt;min({dp[n-1][0],dp[n-1][1],dp[n-1][2]}); return 0; } ç®¡é“ # é—®é¢˜æè¿° # æœ‰ä¸€æ ¹é•¿åº¦ä¸º len çš„æ¨ªå‘ç®¡é“ï¼Œè¯¥ç®¡é“æŒ‰ç…§å•ä½é•¿åº¦åˆ†ä¸º len æ®µï¼Œæ¯ä¸€æ®µçš„ä¸­å¤®æœ‰ä¸€ä¸ªå¯å¼€å…³çš„é˜€é—¨å’Œä¸€ä¸ªæ£€æµ‹æ°´æµçš„ä¼ æ„Ÿå™¨ã€‚\nä¸€å¼€å§‹ç®¡é“æ˜¯ç©ºçš„ï¼Œä½äº Li çš„é˜€é—¨ä¼šåœ¨ Si æ—¶åˆ»æ‰“å¼€ï¼Œå¹¶ä¸æ–­è®©æ°´æµå…¥ç®¡é“ã€‚\nå¯¹äºä½äº Li çš„é˜€é—¨ï¼Œå®ƒæµå…¥çš„æ°´åœ¨ Ti æ—¶åˆ»ï¼ˆTi \u0026gt;= Siï¼‰ä¼šä½¿å¾—ä»ç¬¬ Li - (Ti - Si) æ®µåˆ°ç¬¬ Li + (Ti - Si) æ®µçš„ä¼ æ„Ÿå™¨æ£€æµ‹åˆ°æ°´æµã€‚\næ±‚ç®¡é“ä¸­æ¯ä¸€æ®µä¸­é—´çš„ä¼ æ„Ÿå™¨éƒ½æ£€æµ‹åˆ°æœ‰æ°´æµçš„æœ€æ—©æ—¶é—´ã€‚\nè¾“å…¥æ ¼å¼ # è¾“å…¥çš„ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° n, lenï¼Œç”¨ä¸€ä¸ªç©ºæ ¼åˆ†éš”ï¼Œåˆ†åˆ«è¡¨ç¤ºä¼šæ‰“å¼€çš„é˜€é—¨æ•°å’Œç®¡é“é•¿åº¦ã€‚\næ¥ä¸‹æ¥ n è¡Œæ¯è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° Li, Siï¼Œç”¨ä¸€ä¸ªç©ºæ ¼åˆ†éš”ï¼Œè¡¨ç¤ºä½äºç¬¬ Li æ®µç®¡é“ä¸­å¤®çš„é˜€é—¨ä¼šåœ¨ Si æ—¶åˆ»æ‰“å¼€ã€‚\nè¾“å‡ºæ ¼å¼ # è¾“å‡ºä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•°è¡¨ç¤ºç­”æ¡ˆã€‚\næ ·ä¾‹è¾“å…¥ # 3 10 1 1 6 5 10 2 æ ·ä¾‹è¾“å‡º # 5 å¯¹äº 30% çš„è¯„æµ‹ç”¨ä¾‹ï¼Œn \u0026lt;= 200ï¼ŒSi, len \u0026lt;= 3000ï¼› å¯¹äº 70% çš„è¯„æµ‹ç”¨ä¾‹ï¼Œn \u0026lt;= 5000ï¼ŒSi, len \u0026lt;= 10^5ï¼› å¯¹äºæ‰€æœ‰è¯„æµ‹ç”¨ä¾‹ï¼Œ1 \u0026lt;= n \u0026lt;= 10^5ï¼Œ1 \u0026lt;= Si, len \u0026lt;= 10^9ï¼Œ1 \u0026lt;= Li \u0026lt;= lenï¼ŒLi-1 \u0026lt; Liã€‚ TLEä»£ç  # ï¼ˆåªé€šè¿‡äº†ç™¾åˆ†ä¹‹60ï¼Œæ²¡é‡‡ç”¨ç»å…¸çš„åŒºé—´è¦†ç›–å¥—è·¯ï¼‰\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; bool judgeisfill(long long time, const vector\u0026lt;pair\u0026lt;long, long\u0026gt;\u0026gt;\u0026amp; water, long long len) { vector\u0026lt;bool\u0026gt; covered(len + 1, false); // ç”¨äºæ ‡è®°æ¯ä¸€æ®µæ˜¯å¦è¢«è¦†ç›– for (int i = 0; i \u0026lt; water.size(); i++) { if (time \u0026gt;= water[i].second) { long long left = max(1LL, water[i].first - (time - water[i].second)); long long right = min(len, water[i].first + (time - water[i].second)); for (long long j = left; j \u0026lt;= right; j++) { covered[j] = true; // æ ‡è®°è¦†ç›–èŒƒå›´ } } } for (int i = 1; i \u0026lt;= len; i++) { if (!covered[i]) return false; } return true; } int main() { int n; long long len; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; len; vector\u0026lt;pair\u0026lt;long, long\u0026gt;\u0026gt; water(n, {0, 0}); vector\u0026lt;bool\u0026gt; pipe(n, false); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; water[i].first \u0026gt;\u0026gt; water[i].second; } long long s = 1e9; long long l = 1, r = s; while (l \u0026lt; r) { long long mid = (l + r) \u0026gt;\u0026gt; 1; if (judgeisfill(mid, water, len)) { r = mid; } else { l = mid + 1; } } cout \u0026lt;\u0026lt; l; return 0; } ACä»£ç  # #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; bool judgeisfill(long long time, const vector\u0026lt;pair\u0026lt;long, long\u0026gt;\u0026gt;\u0026amp; water, long long len) { vector\u0026lt;pair\u0026lt;long long ,long long\u0026gt;\u0026gt; intervals; for (const auto\u0026amp; valve : water) { if (time \u0026gt;= valve.second) { // å¦‚æœå½“å‰æ—¶é—´å¤§äºç­‰äºé˜€é—¨æ‰“å¼€çš„æ—¶é—´ long long left = max(1LL, valve.first - (time - valve.second)); // è®¡ç®—å·¦è¾¹ç•Œ long long right = min(len, valve.first + (time - valve.second)); // è®¡ç®—å³è¾¹ç•Œ intervals.push_back({left, right}); } } if (intervals.empty()) return false; // å¦‚æœæ²¡æœ‰åŒºé—´ï¼Œç›´æ¥è¿”å› false // æŒ‰å·¦ç«¯ç‚¹æ’åº sort(intervals.begin(), intervals.end()); // æ£€æŸ¥è¦†ç›–èŒƒå›´ long long r = intervals[0].second; // åˆå§‹æœ€è¿œå³ç«¯ç‚¹ if (intervals[0].first \u0026gt; 1) return false; // å¦‚æœç¬¬ä¸€ä¸ªåŒºé—´çš„å·¦ç«¯ç‚¹å¤§äº 1ï¼Œç›´æ¥è¿”å› false for (size_t i = 1; i \u0026lt; intervals.size(); i++) { if (intervals[i].first \u0026gt; r + 1) return false; // å¦‚æœå½“å‰åŒºé—´ä¸ r ä¸ç›¸é‚»ï¼Œè¿”å› false r = max(r, intervals[i].second); // æ›´æ–°æœ€è¿œå³ç«¯ç‚¹ } return r \u0026gt;= len; // å¦‚æœ r å¤§äºç­‰äº lenï¼Œè¿”å› true } int main() { int n; long long len; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; len; vector\u0026lt;pair\u0026lt;long, long\u0026gt;\u0026gt; water(n); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; water[i].first \u0026gt;\u0026gt; water[i].second; } long long l = 0, r = 1e18; // è®¾ç½®ä¸€ä¸ªè¾ƒå¤§çš„ä¸Šç•Œ while (l \u0026lt; r) { long long mid = (l + r) \u0026gt;\u0026gt; 1; if (judgeisfill(mid, water, len)) { r = mid; } else { l = mid + 1; } } cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; endl; return 0; } åŒºé—´è¦†ç›–æ˜¯ä¸€ä¸ªç»å…¸é—®é¢˜ã€‚æˆ‘ä»¬å¯ä»¥æŒ‰åŒºé—´çš„å·¦ç«¯ç‚¹æ¥æ’åºè¿™äº›åŒºé—´ã€‚æˆ‘ä»¬æ£€æŸ¥è¿™äº›åŒºé—´æ˜¯å¦è¦†ç›–äº†æ•´ä¸ªç®¡é“ã€‚å¦‚æœç¬¬ä¸€ä¸ªåŒºé—´çš„å·¦ç«¯ç‚¹å¤§äº 1ï¼Œé‚£ä¹ˆè¡¨ç¤ºç®¡é“çš„å¼€å§‹éƒ¨åˆ†æ²¡æœ‰è¢«è¦†ç›–ï¼Œç›´æ¥è¿”å› falseã€‚å¦åˆ™æˆ‘ä»¬è®¾ä¸€ä¸ªå˜é‡ r è¡¨ç¤ºå¯åˆ°è¾¾çš„æœ€è¿œè·ç¦»ï¼Œrçš„åˆå§‹å€¼ä¸ºç¬¬ä¸€ä¸ªåŒºé—´çš„å³ç«¯ç‚¹ã€‚æˆ‘ä»¬æ¥ç€æ£€æŸ¥å…¶ä»–åŒºé—´æ˜¯å¦ä¸ rç›¸é‚»æˆ–é‡å ã€‚å¦‚æœå½“å‰åŒºé—´å’Œ r ç›¸é‚»æˆ–é‡å ï¼Œæˆ‘ä»¬å°†å½“å‰åŒºé—´çš„å³ç«¯ç‚¹å’Œ rå–æœ€å¤§å€¼ã€‚æœ€åå¦‚æœ râ‰¥lenåˆ™è¯´æ˜æˆåŠŸè¦†ç›–æ‰€æœ‰åŒºé—´ï¼Œå¦åˆ™è¯´æ˜æ²¡æœ‰ã€‚\n","date":"26 March 2025","externalUrl":null,"permalink":"/posts/lanqiaocup/lanqiaocup2023-1/","section":"Posts","summary":"","title":"Lanqiaocup2023-1","type":"posts"},{"content":" Titanic ç®€æ´çš„ç¥ç»ç½‘ç»œå¤ç° # æœ¬æ–‡å¤ç°çš„æ˜¯fastaiçš„å®˜æ–¹è§†é¢‘æ•™ç¨‹ ç‚¹å‡»æ­¤å¤„è·³è½¬\nå…¶å®˜æ–¹kaggleç¬”è®°æœ¬ ç‚¹å‡»æ­¤å¤„è·³è½¬\næœ¬ç¯‡åšå®¢æ˜¯åœ¨fastaiè¯¾ç¨‹åŸºç¡€ä¸Šè¿›è¡Œæ€»ç»“ï¼Œå…ˆå¤ç°åªæœ‰ä¸€å±‚éšè—å±‚çš„ç¥ç»ç½‘ç»œï¼Œæ¥ç€åœ¨æ­¤åŸºç¡€ä¸Šå¤ç°æ·±åº¦å­¦ä¹ ç®€æ˜“æ¡†æ¶\nimport torch import numpy as np import pandas as pd df = pd.read_csv(\u0026#34;./train.csv\u0026#34;) df.head() å¤„ç†ç¼ºå¤±å€¼ï¼ˆä½¿ç”¨ä¼—æ•°ï¼‰ # df.isna().sum() ##OUTPUT PassengerId 0 Survived 0 Pclass 0 Name 0 Sex 0 Age 177 SibSp 0 Parch 0 Ticket 0 Fare 0 Cabin 687 Embarked 2 dtype: int64 modes = df.mode().iloc[0] #iloc[0]æ˜¯æŒ‡çš„æ˜¯é€‰æ‹©ç¬¬ä¸€ä¸ªä¼—æ•°ï¼ˆå³ç¬¬ä¸€è¡Œï¼‰ï¼Œå¹¶å°†å…¶èµ‹å€¼ç»™ modes df.fillna(modes,inplace=True) df.head() å¤„ç†æ•°å€¼å˜é‡ï¼ˆé•¿å°¾æ•ˆåº”ï¼‰ # df.isna().sum() ##OUTPUT PassengerId 0 Survived 0 Pclass 0 Name 0 Sex 0 Age 0 SibSp 0 Parch 0 Ticket 0 Fare 0 Cabin 0 Embarked 0 dtype: int64 df.describe() PassengerId Survived Pclass Age SibSp Parch Fare count 891.000000 891.000000 891.000000 891.000000 891.000000 891.000000 891.000000 mean 446.000000 0.383838 2.308642 28.566970 0.523008 0.381594 32.204208 std 257.353842 0.486592 0.836071 13.199572 1.102743 0.806057 49.693429 min 1.000000 0.000000 1.000000 0.420000 0.000000 0.000000 0.000000 25% 223.500000 0.000000\u003e 2.000000 22.000000 0.000000 0.000000 7.910400 50% 446.000000 0.000000 3.000000 24.000000 0.000000 0.000000 14.454200 75% 668.500000 1.000000 3.000000 35.000000 1.000000 0.000000 31.000000 max 891.000000 1.000000 3.000000 80.000000 8.000000 6.000000 512.329200 df[\u0026#34;Fare\u0026#34;]=np.log(df[\u0026#34;Fare\u0026#34;]+1) å¤„ç†æ–‡æœ¬å˜é‡ # df.describe(include=[object]) Name Sex Ticket Cabin Embarked count 891 891 891 891 891 unique 891 2 681 147 3 top Dooley, Mr. Patrick male 1601 B96 B98 S freq 1 577 7 691 646 df = pd.get_dummies(df, columns=[\u0026#34;Sex\u0026#34;, \u0026#34;Pclass\u0026#34;, \u0026#34;Embarked\u0026#34;], dtype=int) df.columns ##OUTPUT Index([\u0026#39;PassengerId\u0026#39;, \u0026#39;Survived\u0026#39;, \u0026#39;Name\u0026#39;, \u0026#39;Age\u0026#39;, \u0026#39;SibSp\u0026#39;, \u0026#39;Parch\u0026#39;, \u0026#39;Ticket\u0026#39;, \u0026#39;Fare\u0026#39;, \u0026#39;Cabin\u0026#39;, \u0026#39;Sex_female\u0026#39;, \u0026#39;Sex_male\u0026#39;, \u0026#39;Pclass_1\u0026#39;, \u0026#39;Pclass_2\u0026#39;, \u0026#39;Pclass_3\u0026#39;, \u0026#39;Embarked_C\u0026#39;, \u0026#39;Embarked_Q\u0026#39;, \u0026#39;Embarked_S\u0026#39;], dtype=\u0026#39;object\u0026#39;) df.head() added_cols =[\u0026#34;Sex_male\u0026#34;,\u0026#34;Sex_female\u0026#34;,\u0026#34;Pclass_1\u0026#34;,\u0026#34;Pclass_2\u0026#34;,\u0026#34;Pclass_3\u0026#34;,\u0026#34;Embarked_C\u0026#34;,\u0026#34;Embarked_Q\u0026#34;,\u0026#34;Embarked_S\u0026#34;] df[added_cols].head( ) Sex_male Sex_female Pclass_1 Pclass_2 Pclass_3 Embarked_C Embarked_Q Embarked_S 0 1 0 0 0 1 0 0 1 1 0 1 1 0 0 1 0 0 2 0 1 0 0 1 0 0 1 3 0 1 1 0 0 0 0 1 4 1 0 0 0 1 0 0 1 åˆ’åˆ†æ•°æ®é›† # from torch import tensor indep_cols=[\u0026#34;Age\u0026#34;,\u0026#34;SibSp\u0026#34;,\u0026#34;Parch\u0026#34;,\u0026#34;Fare\u0026#34;]+added_cols t_dep = tensor(df.Survived) t_indep = tensor(df[indep_cols].values, dtype=torch.float) t_dep.shape torch.Size([891])\nt_indep.shape torch.Size([891, 12])\nt_indep ##OUTPUT tensor([[22., 1., 0., ..., 0., 0., 1.], [38., 1., 0., ..., 1., 0., 0.], [26., 0., 0., ..., 0., 0., 1.], ..., [24., 1., 2., ..., 0., 0., 1.], [26., 0., 0., ..., 1., 0., 0.], [32., 0., 0., ..., 0., 1., 0.]]) from fastai.data.transforms import RandomSplitter trn_split,val_split = RandomSplitter(seed=42)(df) trn_indep = t_indep[trn_split] val_indep = t_indep[val_split] trn_dep = t_dep[trn_split] val_dep = t_dep[val_split] len(trn_dep) 713\nlen(val_dep) 178\ntrn_dep = trn_dep[:,None] #å‡ç»´ï¼Œè½¬æˆçŸ©é˜µ vla_dep = trn_dep[:,None] å®šä¹‰è®­ç»ƒå‡½æ•°å’ŒéªŒè¯å‡½æ•° # è®­ç»ƒæ¨¡å‹ # def train_model(epochs=30,lr=1.4): torch.manual_seed(442) #èƒ½å¤ç°è®­ç»ƒè¿‡ç¨‹ coeffs = init_coeffs() for i in range(epochs): one_epoch(coeffs,lr=lr) return coeffs def init_coeffs(n_hidden=20): layer1=(torch.rand(n_coeffs,n_hidden)-0.5)/n_hidden layer2=torch.rand(n_hidden,1)-0.3 const=torch.rand(1)[0] #[0]çš„ä½œç”¨æ˜¯åœ¨å¼ é‡ä¸­å–æ ‡é‡ return layer1.requires_grad_(),layer2.requires_grad_(),const.requires_grad_() def one_epoch(coeffs,lr): loss = calc_loss(coeffs,trn_indep,trn_dep) loss.backward() with torch.no_grad():update_coeffs(coeffs,lr) print(f\u0026#34;{loss:.3f}\u0026#34;,end=\u0026#34;; \u0026#34;) def update_coeffs(coeffs,lr): for layer in coeffs: layer.sub_(layer.grad*lr) layer.grad.zero_() def calc_loss(coeffs,indeps,deps): return torch.abs(calc_preds(coeffs,indeps)-deps).mean() import torch.nn.functional as F def calc_preds(coeffs, indeps): l1,l2,const = coeffs res = F.relu(indeps@l1) res = res@l2 + const return torch.sigmoid(res) éªŒè¯æ¨¡å‹ # def acc(coeffs): return(val_dep.bool()==(calc_preds(coeffs,val_indep)\u0026gt;0.5)).float().mean() å¼€å§‹è®­ç»ƒ # n_coeffs = trn_indep.shape[1] coeffs = train_model(lr=2.4) 0.579; 0.370; 0.369; 0.369; 0.368; 0.368; 0.367; 0.366; 0.366; 0.365; 0.365; 0.364; 0.363; 0.363; 0.362; 0.361; 0.361; 0.360; 0.359; 0.358; 0.357; 0.357; 0.356; 0.355; 0.354; 0.352; 0.351; 0.349; 0.347; 0.344;\nacc(coeffs) tensor(0.5322)\ncoeffs = train_model(lr=1.2) 0.579; 0.377; 0.370; 0.369; 0.369; 0.369; 0.368; 0.368; 0.368; 0.367; 0.367; 0.366; 0.366; 0.366; 0.365; 0.365; 0.365; 0.364; 0.364; 0.364; 0.363; 0.363; 0.363; 0.362; 0.362; 0.361; 0.361; 0.361; 0.360; 0.360;\nacc(coeffs) tensor(0.5869)\næ·±åº¦å­¦ä¹  # def init_coeffs(): hiddens = [10, 10] sizes = [n_coeffs] + hiddens + [1] n = len(sizes) layers = [(torch.rand(sizes[i], sizes[i+1])-0.3)/sizes[i+1]*4 for i in range(n-1)] consts = [(torch.rand(1)[0]-0.5)*0.1 for i in range(n-1)] for l in layers+consts: l.requires_grad_() return layers,consts import torch.nn.functional as F def calc_preds(coeffs, indeps): layers,consts = coeffs n = len(layers) res = indeps for i,l in enumerate(layers): res = res@l + consts[i] if i!=n-1: res = F.relu(res) return torch.sigmoid(res) def update_coeffs(coeffs, lr): layers,consts = coeffs for layer in layers+consts: layer.sub_(layer.grad * lr) layer.grad.zero_() n_coeffs = trn_indep.shape[1] coeffs = train_model(lr=4) 0.373; 0.377; 0.377; 0.375; 0.371; 0.368; 0.365; 0.361; 0.357; 0.357; 0.356; 0.350; 0.344; 0.619; 0.340; 0.621; 0.621; 0.620; 0.618; 0.613; 0.569; 0.379; 0.379; 0.379; 0.379; 0.379; 0.379; 0.379; 0.379; 0.379;\nacc(coeffs) tensor(0.5955)\n","date":"24 March 2025","externalUrl":null,"permalink":"/posts/deeplearning/create-neural-net-from-scratch/","section":"Posts","summary":"","title":"Create Neural Net From Scratch","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]