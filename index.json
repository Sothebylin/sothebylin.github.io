
[{"content":"","date":"26 March 2025","externalUrl":null,"permalink":"/series/algorithm-learing/","section":"Series","summary":"","title":"Algorithm Learing","type":"series"},{"content":"","date":"26 March 2025","externalUrl":null,"permalink":"/categories/algorithm-problems/","section":"文章分类","summary":"","title":"Algorithm Problems","type":"categories"},{"content":"","date":"26 March 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"26 March 2025","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"26 March 2025","externalUrl":null,"permalink":"/","section":"春日汀","summary":"","title":"春日汀","type":"page"},{"content":" 哈希 # 本系列的大部分都是对labuladong和代码随想录网站的题目的练手汇总(部分是博主自己结合leetcode和洛谷题目的补充）初衷是博主自用学习哒!\n请所有阅读这系列博客的友友先移步阅览他们的网站，没有这些优秀网站的分享不会有这系列的文章，我只是知识的搬运工！\n两数之和 # 题目描述 # 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\n你可以按任意顺序返回答案。\nAC代码 # class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { unordered_map\u0026lt;int,int\u0026gt;map; for(int i=0;i\u0026lt;nums.size();i++) { int n=target-nums[i]; if(map.find(n)!=map.end())return {map.find(n)-\u0026gt;second,i}; else map.insert(pair\u0026lt;int,int\u0026gt;(nums[i],i)); } return {}; } }; P1102 A-B 数对 # 给出一串正整数数列以及一个正整数C, 要求计算出所有满足 A - B = C​ 的数对的个数（不同位置的数字一样的数对算不同的数对）。\n输入格式 # 输入共两行。\n第一行，两个正整数 N,C。\n第二行，N 个正整数，作为要求处理的那串数。\n输出格式 # 一行，表示该串正整数中包含的满足 A - B = C​ 的数对的个数。\n输入 # 4 1 1 1 2 3\n输出 # 3\n说明/提示 # 对于 75%​ 的数据，​1\u0026lt; N \u0026lt; 2000​。\n对于100%的数据，1 \u0026lt; N \u0026lt; 2×10^5​，0 \u0026lt; a_i \u0026lt; 2^30​，1 \u0026lt; C \u0026lt; 2^30​。\nAC代码 # #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; int main(){ int N, C; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; C; vector\u0026lt;int\u0026gt; nums(N); unordered_map\u0026lt;int, int\u0026gt; freq; // 使用 int 作为频次类型 for(int i=0;i\u0026lt;N;i++){ int x; cin \u0026gt;\u0026gt; x; nums[i]=x; freq[x]++; } ll res = 0;//注意结果是long long 因为res会累加 for(const int \u0026amp;x : nums){ int target = x + C; if(freq.find(target) != freq.end()){ res += freq[target]; } } cout \u0026lt;\u0026lt; res; } ","date":"26 March 2025","externalUrl":null,"permalink":"/posts/algorithm/%E5%93%88%E5%B8%8C/","section":"Posts","summary":"","title":"哈希","type":"posts"},{"content":"","date":"26 March 2025","externalUrl":null,"permalink":"/categories/","section":"文章分类","summary":"","title":"文章分类","type":"categories"},{"content":" 回溯 # 本系列的大部分都是对labuladong和代码随想录网站的题目的练手汇总(部分是博主自己结合leetcode和洛谷题目的补充）初衷是博主自用学习哒!\n请所有阅读这系列博客的友友先移步阅览他们的网站，没有这些优秀网站的分享不会有这系列的文章，我只是知识的搬运工！\n回溯三部曲\n1)确定回溯函数的返回值及参数\n每次回溯时要更新什么，要返回什么\n2）回溯函数的终止条件\n3）回溯搜索的遍历过程\nvector\u0026lt;vector\u0026gt; result\nvector path\nP4913 【深基16.例3】二叉树深度 # 题目描述 # 有一个 n(n\u0026lt;10^6)​ 个结点的二叉树。给出每个结点的两个子结点编号（均不超过 n），建立一棵二叉树（根节点的编号为 1​），如果是叶子结点，则输入 0 0。\n建好这棵二叉树之后，请求出它的深度。二叉树的深度是指从根节点到叶子结点时，最多经过了几层。\n输入格式 # 第一行一个整数 n​，表示结点数。\n之后 n行，第 i 行两个整数 l、r，分别表示结点 i 的左右子结点编号。若 l=0 则表示无左子结点，r=0 同理。\n输出格式 # 一个整数，表示最大结点深度。\n输入 # 7 2 7 3 6 4 5 0 0 0 0 0 0 0 0 输出 # 4 AC代码 # #include \u0026lt;iostream\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include\u0026lt;math.h\u0026gt; using namespace std; unordered_map\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt; tree; int maxDepth = 0; void traverse(int node, int currentDepth) { int left = tree[node].first; int right = tree[node].second; maxDepth = max(maxDepth,currentDepth); // 遍历左子树 if (left != 0) { traverse(left, currentDepth + 1); } // 遍历右子树 if (right != 0) { traverse(right, currentDepth + 1); } } int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; tree[i] = {l, r}; } traverse(1, 1); cout \u0026lt;\u0026lt; maxDepth \u0026lt;\u0026lt; endl; return 0; } P1025 [NOIP 2001 提高组] 数的划分 # 题目描述 # 将整数 n 分成 k份，且每份不能为空，任意两个方案不相同（不考虑顺序）。\n例如：n=7​，k=3，下面三种分法被认为是相同的。\n1,1,5​;\n1,5,1​;\n​5,1,1.\n问有多少种不同的分法。\n输入格式 # n,k（6\u0026lt;n\u0026lt; 200,2 \u0026lt;k \u0026lt;6）\n输出格式 # 1 个整数，即不同的分法。\n输入 # 7 3\n输出 # 4\n说明/提示 # 四种分法为：\n1,1,5;\n1,2,4;\n1,3,3;\n2,2,3.\nAC代码 # #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, k, res = 0; stack\u0026lt;int\u0026gt; path; // 回溯函数 void backtrack(int start, int sum) { // 如果已经选择了k个数 if (path.size() == k) { if (sum == n) { res++; } return; } // 计算当前数最大可以是多少，避免无效递归 int remaining = k - path.size(); int max_i = (n - sum) / remaining; for(int i = start; i \u0026lt;= max_i; i++) { path.push(i); backtrack(i, sum + i); // 下一轮起始值至少为i，确保非递减!!!因为好几种算重复 path.pop(); } } int main(){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; backtrack(1, 0); cout \u0026lt;\u0026lt; res; return 0; } 未加入记忆数组，纯递归，超时：\n#include \u0026lt;iostream\u0026gt; using namespace std; int count(int num) { if (num == 0) return 0; int res = 1; // 包括自身作为一个数列的情况 for (int i = 1; i \u0026lt;= num / 2; ++i) { res += count(i); } return res; } int main() { int n; cin \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; count(n) \u0026lt;\u0026lt; endl; return 0; } 改进：\n#include \u0026lt;iostream\u0026gt; using namespace std; int dp[100001] = {0}; // 记忆化数组 int count(int num) { if (num == 0) return 0; if (dp[num] != 0) return dp[num]; // 已计算过则直接返回 dp[num] = 1; // 初始化为1（自身） for (int i = 1; i \u0026lt;= num / 2; ++i) { dp[num] += count(i); } return dp[num]; } int main() { int n; cin \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; count(n) \u0026lt;\u0026lt; endl; return 0; } #include \u0026lt;iostream\u0026gt; using namespace std; const int MAX_N = 100000; // 根据题目约束调整最大值 int dp[MAX_N + 1]; int main() { int n; cin \u0026gt;\u0026gt; n; dp[0] = 0; dp[1] = 1; for (int num = 2; num \u0026lt;= n; ++num) { dp[num] = 1; // 至少包含自己 for (int i = 1; i \u0026lt;= num / 2; ++i) { dp[num] += dp[i]; //求和过程 } } cout \u0026lt;\u0026lt; dp[n] \u0026lt;\u0026lt; endl; return 0; } 【蓝桥杯题库】81305. 小齐的字母方块拼写 # 问题描述 # 小齐有四个木块，每个木块是一个立方体，上面分别写有字母表的大写字母。她想通过排列这些木块，拼出一些单词。\n给定每个木块上的字母和小齐想拼出的单词列表，请确定她能成功拼出哪些单词。\n输入格式 # 第一行包含一个整数 N，表示小齐想拼出的单词数量。\n接下来的四行，每行包含一个字符串，表示一个木块上六个大写字母。\n接下来的 N行，每行包含一个小写字母数量在 1 到 4 之间的大写字母单词。\n输出格式 # 对于小齐想拼出的每个单词，如果她能成功拼出，输出 YES，否则输出 NO。\n样例输入 # 6 MOOOOO OOOOOO ABCDEF UVWXYZ COW MOO ZOO MOVE CODE FARM 样例输出 # YES NO YES YES NO NO 评测数据规模 # 1≤N≤10。\nAC代码 # #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; vector\u0026lt;string\u0026gt; table; vector\u0026lt;string\u0026gt; words; bool canSpell(const string\u0026amp; word, vector\u0026lt;bool\u0026gt;\u0026amp; used, int index) { if (index == word.size()) return true; for (int i = 0; i \u0026lt; 4; i++) { if (!used[i] \u0026amp;\u0026amp; table[i].find(word[index]) != string::npos) { //注意string也有find方法 != string::npos 和 unordered_map != map.end() 有点类似 used[i] = true; if (canSpell(word, used, index + 1)) return true; used[i] = false; } } return false; } int main() { int n; cin \u0026gt;\u0026gt; n; table.resize(4); words.resize(n); for (int i = 0; i \u0026lt; 4; i++)cin \u0026gt;\u0026gt; table[i]; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; words[i]; for (int i = 0; i \u0026lt; n; i++) { vector\u0026lt;bool\u0026gt; used(4, false); if (canSpell(words[i], used, 0)) { cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } ","date":"26 March 2025","externalUrl":null,"permalink":"/posts/algorithm/%E5%9B%9E%E6%BA%AF/","section":"Posts","summary":"","title":"回溯","type":"posts"},{"content":" 并查集 # 本系列的大部分都是对labuladong和代码随想录网站的题目的练手汇总(部分是博主自己结合leetcode和洛谷题目的补充）初衷是博主自用学习哒!\n请所有阅读这系列博客的友友先移步阅览他们的网站，没有这些优秀网站的分享不会有这系列的文章，我只是知识的搬运工！\n“并查集用于解决连通性问题”\ntemplate\njoin函数一定要先通过find函数寻根再进行关联\nint n = 1005; // n根据题目中节点数量而定，一般比节点数量大一点就好 vector\u0026lt;int\u0026gt; father (n, 0); // 并查集初始化 void init() { for (int i = 0; i \u0026lt; n; ++i) { father[i] = i; } } // 并查集里寻根的过程 int find(int u) { return u == father[u] ? u : father[u] = find(father[u]); // 路径压缩,将多层压缩为两层，只有第一层是根节点 } // 判断 u 和 v是否找到同一个根 bool isSame(int u, int v) { u = find(u); v = find(v); return u == v; } // 将v-\u0026gt;u 这条边加入并查集 void join(int u, int v) { u = find(u); // 寻找u的根 v = find(v); // 寻找v的根 if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回 father[v] = u; } 删除冗余边Ⅱ（有向图） # 有一种有向树,该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。有向树拥有 n 个节点和 n - 1 条边。输入一个有向图，该图由一个有着 n 个节点(节点编号 从 1 到 n)，n 条边，请返回一条可以删除的边，使得删除该条边之后该有向图可以被当作一颗有向树。\n输入描述\n第一行输入一个整数 N，表示有向图中节点和边的个数。\n后续 N 行，每行输入两个整数 s 和 t，代表这是 s 节点连接并指向 t 节点的单向边\n输出描述\n输出一条可以删除的边，若有多条边可以删除，请输出标准输入中最后出现的一条边。\n输入示例\n3 1 2 1 3 2 3 输出示例\n2 3\n题目分析 # 如果发现入度为2的节点，我们需要判断 删除哪一条边，删除后本图能成为有向树。如果是删哪个都可以，优先删顺序靠后的边。情况三： 如果没有入度为2的点，说明 图中有环了（注意是有向环）。\nisTreeAfterRemoveEdge() 判断删一个边之后是不是有向树： 将所有边的两端节点分别加入并查集，遇到要 要删除的边则跳过，如果遇到即将加入并查集的边的两端节点 本来就在并查集了，说明构成了环。\n如果顺利将所有边的两端节点（除了要删除的边）加入了并查集，则说明 删除该条边 还是一个有向树\ngetRemoveEdge()确定图中一定有了有向环，那么要找到需要删除的那条边： 将所有边的两端节点分别加入并查集，如果遇到即将加入并查集的边的两端节点 本来就在并查集了，说明构成了环。\nAC代码 # #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int n; vector\u0026lt;int\u0026gt; father (1001, 0); // 并查集初始化 void init() { for (int i = 1; i \u0026lt;= n; ++i) { father[i] = i; } } // 并查集里寻根的过程 int find(int u) { return u == father[u] ? u : father[u] = find(father[u]); } // 将v-\u0026gt;u 这条边加入并查集 void join(int u, int v) { u = find(u); v = find(v); if (u == v) return ; father[v] = u; } // 判断 u 和 v是否找到同一个根 bool same(int u, int v) { u = find(u); v = find(v); return u == v; } // 在有向图里找到删除的那条边，使其变成树 void getRemoveEdge(const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { init(); // 初始化并查集 for (int i = 0; i \u0026lt; n; i++) { // 遍历所有的边 if (same(edges[i][0], edges[i][1])) { // 构成有向环了，就是要删除的边 cout \u0026lt;\u0026lt; edges[i][0] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; edges[i][1]; return; } else { join(edges[i][0], edges[i][1]); } } } // 删一条边之后判断是不是树 bool isTreeAfterRemoveEdge(const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges, int deleteEdge) { init(); // 初始化并查集 for (int i = 0; i \u0026lt; n; i++) { if (i == deleteEdge) continue; if (same(edges[i][0], edges[i][1])) { // 构成有向环了，一定不是树 return false; } join(edges[i][0], edges[i][1]); } return true; } int main() { int s, t; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; edges; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; inDegree(n + 1, 0); // 记录节点入度 for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; inDegree[t]++; edges.push_back({s, t}); } vector\u0026lt;int\u0026gt; vec; // 记录入度为2的边（如果有的话就两条边） // 找入度为2的节点所对应的边，注意要倒序，因为优先删除最后出现的一条边 for (int i = n - 1; i \u0026gt;= 0; i--) { if (inDegree[edges[i][1]] == 2) { vec.push_back(i); } } // 情况一、情况二 if (vec.size() \u0026gt; 0) { // 放在vec里的边已经按照倒叙放的，所以这里就优先删vec[0]这条边 if (isTreeAfterRemoveEdge(edges, vec[0])) { cout \u0026lt;\u0026lt; edges[vec[0]][0] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; edges[vec[0]][1]; } else { cout \u0026lt;\u0026lt; edges[vec[1]][0] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; edges[vec[1]][1]; } return 0; } // 处理情况三 // 明确没有入度为2的情况，那么一定有有向环，找到构成环的边返回就可以了 getRemoveEdge(edges); } 买云朵（01背包+并查集） # 题目描述 # Joe觉得云朵很美，决定去山上的商店买一些云朵。商店里有n朵云，云朵被编号为1，2，…，n，并且每朵云都有一个价值。但是商店老板跟他说，一些云朵要搭配来买才好，所以买一朵云则与这朵云有搭配的云都要买。\n但是Joe的钱有限，所以他希望买的价值越多越好。\n输入格式 # 第1行n，m，w，表示n朵云，m个搭配，Joe有w的钱。\n第 2-n+1 行，每行 ci，di 表示i朵云的价钱和价值。\n第n+2-n+1+m行，每行 ui，vi，表示买ui就必须买vi，同理，如果买vi就必须买ui。\n输出格式 # 一行，表示可以获得的最大价值。\n输入样例 # 5 3 10 3 10 3 10 3 10 5 100 10 1 1 3 3 2 4 2\n输出样例 # 1\n【提示】 【数据范围】\n30%的数据保证：n≤100；\n50%的数据保证：n≤1,000；m≤100；w≤1,000；\n100%的数据保证：n≤10,000；0≤m≤5000；w≤10,000。\nAC代码 # #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MAXN = 10010; int dp[MAXN]; // DP数组，表示在钱为j时的最大价值 int father[MAXN]; // 并查集父节点 int cost[MAXN]; // 每组的成本 int value[MAXN]; // 每组的价值 vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; grid; // 存储每朵云的成本和价值 // 初始化并查集 void init(int n) { for (int i = 1; i \u0026lt;= n; i++) { father[i] = i; cost[i] = grid[i].first; value[i] = grid[i].second; } } // 查找并查集的根节点 int find(int x) { return x == father[x] ? x : father[x] = find(father[x]); } // 合并两个云朵的组 void join(int u, int v) { u = find(u); v = find(v); if (u == v) return; // 已经在同一组 father[v] = u; // 合并 cost[u] += cost[v]; // 合并成本 value[u] += value[v]; // 合并价值 } int main() { int n, m, w; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; w; grid.resize(n + 1); // 调整大小 for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; grid[i].first \u0026gt;\u0026gt; grid[i].second; } init(n); // 初始化并查集 // 处理搭配关系 for (int i = 1; i \u0026lt;= m; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; join(u, v); // 合并云朵的组 } // 动态规划求解 for (int i = 1; i \u0026lt;= n; i++) { if (father[i] == i) { // 只处理根节点 for (int j = w; j \u0026gt;= cost[i]; j--) { dp[j] = max(dp[j], dp[j - cost[i]] + value[i]); } } } // 输出最大价值 cout \u0026lt;\u0026lt; dp[w] \u0026lt;\u0026lt; endl; return 0; } 小齐的图论之旅 # 问题描述 # 小齐正在学习图论课程，并遇到了以下问题，她感到有些困惑。请你帮助她解决这个问题！\n给定一个连通的无向图，图中的顶点标号为 1…N，边标号为 1…M。对于图中的每个顶点 v，执行以下过程：\n令 S=v 且 h=0。\n当 ∣S∣\u0026lt;N 时：\n从所有与 S 中某一端点相连的边中，选择标号最小的边 e。将 e 的另一端点加入 S。\n更新h=10×h+e。\n返回 h mod 10^9+7。\n求解该过程的所有返回值。\n输入格式 # 第一行包含两个整数 N 和 M。\n接下来有M行，每行包含一条边 (a_e,b_e) 的两个端点，表示图中的一条边（1≤a_e\u0026lt;b_e≤N )。保证这些边构成一棵连通树，且每一对顶点之间最多只有一条边。\n输出格式 # 输出 N 行，其中第 i 行应包含从顶点 i 开始执行过程时的返回值。\n样例输入 # 3 2 1 2 2 3 样例输出 # 12 12 21 评测数据规模\n2≤N≤2×10^5， N−1≤M≤4×10^5。\nTLE代码 # //TLE了，仅作思路借鉴 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MOD = 1e9 + 7; struct Edge { int l, r; int val; }; struct CompareEdge { bool operator()(const Edge\u0026amp; a, const Edge\u0026amp; b) { return a.val \u0026gt; b.val; } }; int main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;Edge\u0026gt; edges(m + 1, {0, 0, 0}); vector\u0026lt;vector\u0026lt;Edge\u0026gt;\u0026gt; adj(n + 1); for (int i = 1; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; edges[i].l \u0026gt;\u0026gt; edges[i].r; edges[i].val = i; adj[edges[i].l].push_back(edges[i]); adj[edges[i].r].push_back(edges[i]); } vector\u0026lt;long long\u0026gt; result(n + 1, 0); for (int start = 1; start \u0026lt;= n; start++) { vector\u0026lt;bool\u0026gt; isinS(n + 1, false); isinS[start] = true; priority_queue\u0026lt;Edge, vector\u0026lt;Edge\u0026gt;, CompareEdge\u0026gt; pq; for (Edge\u0026amp; edge : adj[start]) { pq.push(edge); } int count = 1; long long h = 0; while (count \u0026lt; n \u0026amp;\u0026amp; !pq.empty()) { Edge edge = pq.top(); pq.pop(); int next = (isinS[edge.l]) ? edge.r : edge.l; if (isinS[next]) continue; isinS[next] = true; count++; h = (10 * h + edge.val) % MOD; for (Edge\u0026amp; edge : adj[next]) { if (!isinS[edge.l] || !isinS[edge.r]) { pq.push(edge); } } } result[start] = h; } for (int i = 1; i \u0026lt;= n; i++) { cout \u0026lt;\u0026lt; result[i] \u0026lt;\u0026lt; endl; } return 0; } ","date":"26 March 2025","externalUrl":null,"permalink":"/posts/algorithm/%E5%B9%B6%E6%9F%A5%E9%9B%86/","section":"Posts","summary":"","title":"并查集","type":"posts"},{"content":" 蓝桥杯C++题库2023-1 # 博主非ACMer，题目代码分析可能会有偏颇，建议谨慎参考博主的AC代码。分布这系列的帖子的初衷是分享官方的题库，以方便友友们备赛:)\n偶串 # 小蓝特别喜欢偶数，当他看到字符串时，他总数要检查一下是不是每种字符都是出现偶数次。给定一个字符串，请帮助小蓝检查一下该字符串是否满足要求。\n输入描述 # 输入一行包含一个字符串，由小写英文字母组成。\n输出描述 # 如果字符串中的每种字符都是出现偶数次，输出大写英文单词 YES ，否则输出大写英文单词 NO。\n样例输入 # banana 样例输出 # NO 评测用例规模 # 对于 50%的评测用例， 1≤ 字符串长度 ≤1000；\n对于所有评测用例，1≤ 字符串长度 ≤10^6 。\nAC代码 # 博主第一反应就是unordered_map，也就用它做出来了\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { unordered_map\u0026lt;char, int\u0026gt; map; string s; cin \u0026gt;\u0026gt; s; for (int i = 0; i \u0026lt; s.size(); i++) { map[s[i]]++; } for (auto\u0026amp; pair : map) { if (pair.second % 2 != 0) { cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34;; return 0; } } cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34;; return 0; } 划分 # 问题描述 # 给定 40个数，请将其任意划分成两组，每组至少一个元素。每组的权值为组内所有元素的和。划分的权值为两组权值的乘积。请问对于以下 40 个数，划分的权值最大为多少。\nAC代码 # 直觉就是分成两组和差不多的两部分，这样乘积最大。也就是说两部分的和尽量靠近sum/2\n采用动态规划，定义布尔数组dp[ i ] [ j ]，表示在前索引为0-i个数中，是否存在和为 j 的组合\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { int nums[40] = {5160, 9191, 6410, 4657, 7492, 1531, 8854, 1253, 4520, 9231, 1266, 4801, 3484, 4323, 5070, 1789, 2744, 5959, 9426, 4433, 4404, 5291, 2470, 8533, 7608, 2935, 8922, 5273, 8364, 8819, 7374, 8077, 5336, 8495, 5602, 6553, 3548, 5267, 9150, 3309}; int total_sum = 0; for (int i = 0; i \u0026lt; 40; i++) { total_sum += nums[i]; } vector\u0026lt;bool\u0026gt; dp(total_sum / 2 + 1, false); dp[0] = true; for (int i = 0; i \u0026lt; 40; i++) { for (int j = total_sum / 2; j \u0026gt;= nums[i]; j--) { if (dp[j - nums[i]]) { dp[j] = true; } } } long long max_product = 0; for (int i = total_sum / 2; i \u0026gt;= 0; i--) { if (dp[i]) { max_product = (long long)i * (total_sum - i); break; } } cout \u0026lt;\u0026lt; max_product \u0026lt;\u0026lt; endl; return 0; } 糖果分配 # 问题描述 # 两种糖果分别有9个和 16 个，要全部分给 7 个小朋友，每个小朋友得到的糖果总数最少为 2 个最多为 5 个，问有多少种不同的分法。糖果必须全部分完。\n只要有其中一个小朋友在两种方案中分到的糖果不完全相同，这两种方案就算作不同的方案。\n问题分析 # 这个题先从二维数组分析，博主简单的画了个图，通过分析可以看出dp[i] [j] 是由​ dp[i-1] [j] ​和 dp[i] [j-nums [i]] 共同影响的。\n然后再压缩为一维数组解决。\n具体思路可参考代码随想录的0-1背包基础理论2,虽然是以0-1背包举例但是将二维数组压缩为一维数组的思路和注意的地方可以借鉴。\nAC代码 # #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int res=0; void dfs(int idx, int a_size, int b_size) { if (idx == 7) { if(a_size == 0 \u0026amp;\u0026amp; b_size == 0)res++; return; } for (int i = 0; i \u0026lt;= a_size; i++) { for (int j = 0; j \u0026lt;= b_size; j++) { if (i + j \u0026gt;= 2 \u0026amp;\u0026amp; i + j \u0026lt;= 5) { dfs(idx + 1, a_size - i, b_size - j); } } } } int main() { int a = 16, b = 9; dfs(0, a, b); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } ","date":"26 March 2025","externalUrl":null,"permalink":"/posts/lanqiaocup/lanqiaocup2023-1/","section":"Posts","summary":"","title":"Lanqiaocup2023-1","type":"posts"},{"content":"","date":"26 March 2025","externalUrl":null,"permalink":"/series/%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%A2%98%E5%BA%93/","section":"Series","summary":"","title":"蓝桥杯题库","type":"series"},{"content":" Titanic 简洁的神经网络复现 # 本文复现的是fastai的官方视频教程 点击此处跳转\n其官方kaggle笔记本 点击此处跳转\n本篇博客是在fastai课程基础上进行总结，先复现只有一层隐藏层的神经网络，接着在此基础上复现深度学习简易框架\nimport torch import numpy as np import pandas as pd df = pd.read_csv(\u0026#34;./train.csv\u0026#34;) df.head() 处理缺失值（使用众数） # df.isna().sum() ##OUTPUT PassengerId 0 Survived 0 Pclass 0 Name 0 Sex 0 Age 177 SibSp 0 Parch 0 Ticket 0 Fare 0 Cabin 687 Embarked 2 dtype: int64 modes = df.mode().iloc[0] #iloc[0]是指的是选择第一个众数（即第一行），并将其赋值给 modes df.fillna(modes,inplace=True) df.head() 处理数值变量（长尾效应） # df.isna().sum() ##OUTPUT PassengerId 0 Survived 0 Pclass 0 Name 0 Sex 0 Age 0 SibSp 0 Parch 0 Ticket 0 Fare 0 Cabin 0 Embarked 0 dtype: int64 df.describe() PassengerId Survived Pclass Age SibSp Parch Fare count 891.000000 891.000000 891.000000 891.000000 891.000000 891.000000 891.000000 mean 446.000000 0.383838 2.308642 28.566970 0.523008 0.381594 32.204208 std 257.353842 0.486592 0.836071 13.199572 1.102743 0.806057 49.693429 min 1.000000 0.000000 1.000000 0.420000 0.000000 0.000000 0.000000 25% 223.500000 0.000000\u003e 2.000000 22.000000 0.000000 0.000000 7.910400 50% 446.000000 0.000000 3.000000 24.000000 0.000000 0.000000 14.454200 75% 668.500000 1.000000 3.000000 35.000000 1.000000 0.000000 31.000000 max 891.000000 1.000000 3.000000 80.000000 8.000000 6.000000 512.329200 df[\u0026#34;Fare\u0026#34;]=np.log(df[\u0026#34;Fare\u0026#34;]+1) 处理文本变量 # df.describe(include=[object]) Name Sex Ticket Cabin Embarked count 891 891 891 891 891 unique 891 2 681 147 3 top Dooley, Mr. Patrick male 1601 B96 B98 S freq 1 577 7 691 646 df = pd.get_dummies(df, columns=[\u0026#34;Sex\u0026#34;, \u0026#34;Pclass\u0026#34;, \u0026#34;Embarked\u0026#34;], dtype=int) df.columns ##OUTPUT Index([\u0026#39;PassengerId\u0026#39;, \u0026#39;Survived\u0026#39;, \u0026#39;Name\u0026#39;, \u0026#39;Age\u0026#39;, \u0026#39;SibSp\u0026#39;, \u0026#39;Parch\u0026#39;, \u0026#39;Ticket\u0026#39;, \u0026#39;Fare\u0026#39;, \u0026#39;Cabin\u0026#39;, \u0026#39;Sex_female\u0026#39;, \u0026#39;Sex_male\u0026#39;, \u0026#39;Pclass_1\u0026#39;, \u0026#39;Pclass_2\u0026#39;, \u0026#39;Pclass_3\u0026#39;, \u0026#39;Embarked_C\u0026#39;, \u0026#39;Embarked_Q\u0026#39;, \u0026#39;Embarked_S\u0026#39;], dtype=\u0026#39;object\u0026#39;) df.head() added_cols =[\u0026#34;Sex_male\u0026#34;,\u0026#34;Sex_female\u0026#34;,\u0026#34;Pclass_1\u0026#34;,\u0026#34;Pclass_2\u0026#34;,\u0026#34;Pclass_3\u0026#34;,\u0026#34;Embarked_C\u0026#34;,\u0026#34;Embarked_Q\u0026#34;,\u0026#34;Embarked_S\u0026#34;] df[added_cols].head( ) Sex_male Sex_female Pclass_1 Pclass_2 Pclass_3 Embarked_C Embarked_Q Embarked_S 0 1 0 0 0 1 0 0 1 1 0 1 1 0 0 1 0 0 2 0 1 0 0 1 0 0 1 3 0 1 1 0 0 0 0 1 4 1 0 0 0 1 0 0 1 划分数据集 # from torch import tensor indep_cols=[\u0026#34;Age\u0026#34;,\u0026#34;SibSp\u0026#34;,\u0026#34;Parch\u0026#34;,\u0026#34;Fare\u0026#34;]+added_cols t_dep = tensor(df.Survived) t_indep = tensor(df[indep_cols].values, dtype=torch.float) t_dep.shape torch.Size([891])\nt_indep.shape torch.Size([891, 12])\nt_indep ##OUTPUT tensor([[22., 1., 0., ..., 0., 0., 1.], [38., 1., 0., ..., 1., 0., 0.], [26., 0., 0., ..., 0., 0., 1.], ..., [24., 1., 2., ..., 0., 0., 1.], [26., 0., 0., ..., 1., 0., 0.], [32., 0., 0., ..., 0., 1., 0.]]) from fastai.data.transforms import RandomSplitter trn_split,val_split = RandomSplitter(seed=42)(df) trn_indep = t_indep[trn_split] val_indep = t_indep[val_split] trn_dep = t_dep[trn_split] val_dep = t_dep[val_split] len(trn_dep) 713\nlen(val_dep) 178\ntrn_dep = trn_dep[:,None] #升维，转成矩阵 vla_dep = trn_dep[:,None] 定义训练函数和验证函数 # 训练模型 # def train_model(epochs=30,lr=1.4): torch.manual_seed(442) #能复现训练过程 coeffs = init_coeffs() for i in range(epochs): one_epoch(coeffs,lr=lr) return coeffs def init_coeffs(n_hidden=20): layer1=(torch.rand(n_coeffs,n_hidden)-0.5)/n_hidden layer2=torch.rand(n_hidden,1)-0.3 const=torch.rand(1)[0] #[0]的作用是在张量中取标量 return layer1.requires_grad_(),layer2.requires_grad_(),const.requires_grad_() def one_epoch(coeffs,lr): loss = calc_loss(coeffs,trn_indep,trn_dep) loss.backward() with torch.no_grad():update_coeffs(coeffs,lr) print(f\u0026#34;{loss:.3f}\u0026#34;,end=\u0026#34;; \u0026#34;) def update_coeffs(coeffs,lr): for layer in coeffs: layer.sub_(layer.grad*lr) layer.grad.zero_() def calc_loss(coeffs,indeps,deps): return torch.abs(calc_preds(coeffs,indeps)-deps).mean() import torch.nn.functional as F def calc_preds(coeffs, indeps): l1,l2,const = coeffs res = F.relu(indeps@l1) res = res@l2 + const return torch.sigmoid(res) 验证模型 # def acc(coeffs): return(val_dep.bool()==(calc_preds(coeffs,val_indep)\u0026gt;0.5)).float().mean() 开始训练 # n_coeffs = trn_indep.shape[1] coeffs = train_model(lr=2.4) 0.579; 0.370; 0.369; 0.369; 0.368; 0.368; 0.367; 0.366; 0.366; 0.365; 0.365; 0.364; 0.363; 0.363; 0.362; 0.361; 0.361; 0.360; 0.359; 0.358; 0.357; 0.357; 0.356; 0.355; 0.354; 0.352; 0.351; 0.349; 0.347; 0.344;\nacc(coeffs) tensor(0.5322)\ncoeffs = train_model(lr=1.2) 0.579; 0.377; 0.370; 0.369; 0.369; 0.369; 0.368; 0.368; 0.368; 0.367; 0.367; 0.366; 0.366; 0.366; 0.365; 0.365; 0.365; 0.364; 0.364; 0.364; 0.363; 0.363; 0.363; 0.362; 0.362; 0.361; 0.361; 0.361; 0.360; 0.360;\nacc(coeffs) tensor(0.5869)\n深度学习 # def init_coeffs(): hiddens = [10, 10] sizes = [n_coeffs] + hiddens + [1] n = len(sizes) layers = [(torch.rand(sizes[i], sizes[i+1])-0.3)/sizes[i+1]*4 for i in range(n-1)] consts = [(torch.rand(1)[0]-0.5)*0.1 for i in range(n-1)] for l in layers+consts: l.requires_grad_() return layers,consts import torch.nn.functional as F def calc_preds(coeffs, indeps): layers,consts = coeffs n = len(layers) res = indeps for i,l in enumerate(layers): res = res@l + consts[i] if i!=n-1: res = F.relu(res) return torch.sigmoid(res) def update_coeffs(coeffs, lr): layers,consts = coeffs for layer in layers+consts: layer.sub_(layer.grad * lr) layer.grad.zero_() n_coeffs = trn_indep.shape[1] coeffs = train_model(lr=4) 0.373; 0.377; 0.377; 0.375; 0.371; 0.368; 0.365; 0.361; 0.357; 0.357; 0.356; 0.350; 0.344; 0.619; 0.340; 0.621; 0.621; 0.620; 0.618; 0.613; 0.569; 0.379; 0.379; 0.379; 0.379; 0.379; 0.379; 0.379; 0.379; 0.379;\nacc(coeffs) tensor(0.5955)\n","date":"24 March 2025","externalUrl":null,"permalink":"/posts/create-neural-net-from-scratch/","section":"Posts","summary":"","title":"Create Neural Net From Scratch","type":"posts"},{"content":"","date":"24 March 2025","externalUrl":null,"permalink":"/categories/deeplearning/","section":"文章分类","summary":"","title":"DeepLearning","type":"categories"},{"content":"","date":"24 March 2025","externalUrl":null,"permalink":"/series/fastai-course-learning-/","section":"Series","summary":"","title":"Fastai Course Learning ","type":"series"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]