
[{"content":"","date":"27 March 2025","externalUrl":null,"permalink":"/categories/deeplearning/","section":"æ–‡ç« åˆ†ç±»","summary":"","title":"DeepLearning","type":"categories"},{"content":"","date":"27 March 2025","externalUrl":null,"permalink":"/series/fastai-course-learning-/","section":"Series","summary":"","title":"Fastai Course Learning ","type":"series"},{"content":" Learning neural network further # æœ¬æ–‡å¤ç°çš„æ˜¯fastaiçš„å®˜æ–¹è§†é¢‘æ•™ç¨‹ ç‚¹å‡»æ­¤å¤„è·³è½¬\nå…¶å®˜æ–¹kaggleç¬”è®°æœ¬ ç‚¹å‡»æ­¤å¤„è·³è½¬\næœ¬ç¯‡åšå®¢æ˜¯åœ¨fastaiè¯¾ç¨‹åŸºç¡€ä¸Šè¿›è¡Œæ€»ç»“ï¼ŒåŸºäºkaggleä¸Šçš„paddy disease classificatinæ¯”èµ›ï¼Œä½¿ç”¨äº†Resnetæ¡†æ¶å’ŒConvnextæ¡†æ¶å®ç°å¯¹ç–¾ç—…çš„åˆ†ç±»ï¼Œç»“æœå‘ç°Convnextæ¯”Resnextæ•ˆæœæ›´å¥½ï¼Œå¹¶ä¸”ä½¿ç”¨äº†æµ‹è¯•æ—¶é—´å¢å¼ºï¼ˆTTAï¼‰ã€æ‰©å¤§è®­ç»ƒè§„æ¨¡ã€å¯¹å›¾åƒè¿›è¡Œå¡«å……ç­‰æ–¹å¼æ¢ç©¶é™ä½è¯¯å·®çš„æ•ˆæœï¼Œæœ€åè¿˜æ„å»ºäº†å¤šè¾“å‡ºæ¨¡å‹ï¼Œè¾“å‡ºç–¾ç—…ä»¥åŠç§ç±»ã€‚\nSetup # !pip install -Uq fastkaggle from fastai import * from fastkaggle import * comp = \u0026#39;paddy-disease-classification\u0026#39; path = setup_comp(comp, install=\u0026#39;fastai \u0026#34;timm\u0026gt;=0.6.2.dev0\u0026#34;\u0026#39;) path.ls() (#4) [Path(\u0026rsquo;../input/paddy-disease-classification/sample_submission.csv\u0026rsquo;),Path(\u0026rsquo;../input/paddy-disease-classification/train_images\u0026rsquo;),Path(\u0026rsquo;../input/paddy-disease-classification/train.csv\u0026rsquo;),Path(\u0026rsquo;../input/paddy-disease-classification/test_images\u0026rsquo;)]\nfrom fastai.vision.all import * trn_path = path/\u0026#39;train_images\u0026#39; imgfiles = get_image_files(trn_path) img = PILImage.create(imgfiles[0]) print(img.size) img.to_thumb(128) (480, 640)\nä¸è¿‡è¦æ³¨æ„çš„æ˜¯PILå±•ç¤ºçš„å›¾åƒå°ºå¯¸æ ¼å¼\nåº“/æ–¹æ³• å°ºå¯¸æ ¼å¼ å¤‡æ³¨ PIL / PILImage (å®½åº¦, é«˜åº¦) ç›´æ¥å¯¹åº”å›¾åƒçš„å®é™…åƒç´ å°ºå¯¸ OpenCV (é«˜åº¦, å®½åº¦) OpenCV ä½¿ç”¨ (h, w) çš„ NumPy é£æ ¼ matplotlib (å®½åº¦, é«˜åº¦) ä¸ PIL ä¸€è‡´ PyTorch (é€šé“, é«˜åº¦, å®½åº¦) å¼ é‡æ ¼å¼ï¼ˆéœ€é¢å¤–æ³¨æ„ï¼‰ ä¸ºæ£€æŸ¥æ‰€æœ‰å›¾åƒçš„å°ºå¯¸é‡‡ç”¨fastcoreä¸­çš„parallelæ¨¡å—å¹¶è¡Œå¤„ç†\nfrom fastcore.parallel import * def f(o): return PILImage.create(o).size sizes = parallel(f, imgfiles, n_workers=8) pd.Series(sizes).value_counts() (480, 640) 10403 (640, 480) 4 Name: count, dtype: int64\ndls = ImageDataLoaders.from_folder( trn_path, valid_pct=0.2, #å½“æœªåˆ’åˆ†è®­ç»ƒé›†å’ŒéªŒè¯é›†æ—¶éœ€è¦ä¼ é€’valid_pctå‚æ•° seed=42, item_tfms=Resize(480,method=\u0026#39;squish\u0026#39;), batch_tfms=aug_transforms(size=128,min_scale=0.75) ) item_tfms æ˜¯ ImageDataLoaders.from_folder() æ–¹æ³•çš„ä¸€ä¸ªå‚æ•°åï¼Œå…¨ç§°ä¸º â€‹item transformationsâ€‹ï¼ˆå•æ ·æœ¬å˜æ¢ï¼‰ã€‚å®ƒç”¨äºå®šä¹‰åœ¨æ•°æ®åŠ è½½æ—¶å¯¹å•ä¸ªå›¾åƒï¼ˆitemï¼‰åº”ç”¨çš„é¢„å¤„ç†æˆ–å¢å¼ºæ“ä½œã€‚\ndls.show_batch(max_n=6) fastai çš„ from_folder æ–¹å¼èƒ½ä»å­æ–‡ä»¶å¤¹åè‡ªåŠ¨æå–ç±»åˆ«ã€‚\né‡‡ç”¨Resnet26dè®­ç»ƒ # å®šä¹‰å­¦ä¹ æ¨¡å‹å¹¶æŸ¥æ‰¾å­¦ä¹ ç‡ # learn = vision_learner( dls, \u0026#39;resnet26d\u0026#39;, metrics=error_rate, path=\u0026#39;.\u0026#39;).to_fp16() model.safetensors: 0%| | 0.00/64.2M [00:00\u0026lt;?, ?B/s]\nå‚æ•° ä½œç”¨ ç¤ºä¾‹å€¼/ç±»å‹ è¡¥å……è¯´æ˜ dls æ•°æ®åŠ è½½å™¨ï¼ŒåŒ…å«è®­ç»ƒé›†å’ŒéªŒè¯é›† ImageDataLoaderså¯¹è±¡ éœ€é€šè¿‡ DataBlock æˆ–å·¥å‚å‡½æ•°ï¼ˆå¦‚ ImageDataLoaders.from_folderï¼‰ç”Ÿæˆ 'resnet26d' æ¨¡å‹æ¶æ„ï¼ˆResNetçš„å˜ä½“ï¼Œå¹³è¡¡é€Ÿåº¦å’Œç²¾åº¦ï¼‰ å­—ç¬¦ä¸²æˆ–nn.Module å…¶ä»–é€‰é¡¹ï¼š'resnet34', 'efficientnet_b0', 'convnext_tiny' ç­‰ metrics è®­ç»ƒæ—¶è®¡ç®—çš„è¯„ä¼°æŒ‡æ ‡ï¼ˆæ”¯æŒå•æŒ‡æ ‡æˆ–åˆ—è¡¨ï¼‰ error_rate å¸¸ç”¨æŒ‡æ ‡ï¼š\nâ€¢ accuracy\nâ€¢ Precision\nâ€¢ Recall\nâ€¢ F1Score\nâ€¢ RocAucï¼ˆäºŒåˆ†ç±»ï¼‰\nâ€¢ Perplexityï¼ˆè¯­è¨€æ¨¡å‹ï¼‰ path æ¨¡å‹å’Œæ—¥å¿—çš„ä¿å­˜ç›®å½•ï¼ˆ.è¡¨ç¤ºå½“å‰ç›®å½•ï¼‰ å­—ç¬¦ä¸²æˆ–Pathå¯¹è±¡ ä¿å­˜å†…å®¹åŒ…æ‹¬ï¼š\nâ€¢ æ¨¡å‹å‚æ•°ï¼ˆ.pthï¼‰\nâ€¢ è®­ç»ƒæ—¥å¿—ï¼ˆhistory.csvï¼‰ .to_fp16() å¯ç”¨æ··åˆç²¾åº¦è®­ç»ƒï¼ˆFP16ï¼‰ï¼ŒåŠ é€Ÿè®­ç»ƒå¹¶å‡å°‘æ˜¾å­˜å ç”¨ æ–¹æ³•è°ƒç”¨ éœ€GPUæ”¯æŒï¼ˆå¦‚NVIDIA Volta+æ¶æ„ï¼‰\nå¯ç”¨ .to_fp32() å¼ºåˆ¶ç¦ç”¨ æŸ¥æ‰¾ä¸€ä¸‹æœ€ä½³çš„å­¦ä¹ ç‡\nlearn.lr_find(suggest_funcs=(valley,slide)) SuggestedLRs(valley=0.0010000000474974513, slide=0.0020892962347716093)\nsuggest_funcs å‚æ•°ï¼šæŒ‡å®šå­¦ä¹ ç‡æ¨èç­–ç•¥\nvalleyï¼šé€‰æ‹©æŸå¤±ä¸‹é™æœ€é™¡å³­çš„ç‚¹ï¼ˆé¿å…è¿‡å¤§çš„å­¦ä¹ ç‡ï¼‰ã€‚\nslideï¼šé€‰æ‹©æŸå¤±å¼€å§‹å¹³ç¨³ä¸Šå‡çš„ç‚¹ï¼ˆä¿å®ˆä½†ç¨³å®šï¼‰ã€‚\nResnet26dæ¨¡å‹è®­ç»ƒ # learn.fine_tune(3,0.01) epoch train_loss valid_loss error_rate time 0 1.783480 1.293824 0.423835 00:42 epoch train_loss valid_loss error_rate time 0 1.128158 0.715136 0.238827 00:42 1 0.802069 0.490330 0.160980 00:42 2 0.569914 0.385769 0.135992 00:42 fine_tune() æ˜¯ fastai æä¾›çš„å¾®è°ƒæ–¹æ³•ï¼Œåˆ†ä¸¤é˜¶æ®µè‡ªåŠ¨è®­ç»ƒï¼š\n1)å†»ç»“é˜¶æ®µï¼ˆFreezeï¼‰â€‹\nä»…è®­ç»ƒæ–°å¢çš„å¤´éƒ¨å±‚â€‹ï¼ˆæ›¿æ¢åçš„æœ€åä¸€å±‚ï¼‰ï¼Œé¢„è®­ç»ƒä¸»å¹²å±‚ä¿æŒå†»ç»“ã€‚ é»˜è®¤1è½®â€‹ï¼ˆå¯é€šè¿‡ freeze_epochs ä¿®æ”¹ï¼‰ã€‚ å­¦ä¹ ç‡è‡ªåŠ¨è®¾ä¸º base_lr/10ï¼ˆè‹¥æœªæŒ‡å®š base_lrï¼Œåˆ™ç”¨ä¼ å…¥çš„ 0.01ï¼‰ã€‚\n2)è§£å†»é˜¶æ®µï¼ˆUnfreezeï¼‰â€‹\nè§£å†»æ‰€æœ‰å±‚ï¼Œå…¨éƒ¨å‚ä¸è®­ç»ƒã€‚ è®­ç»ƒå‰©ä½™è½®æ•°â€‹ï¼ˆæ­¤å¤„ 3 - 1 = 2 è½®ï¼‰ã€‚ ä½¿ç”¨ä¼ å…¥çš„å­¦ä¹ ç‡ 0.01ï¼ˆæˆ–é€šè¿‡ lr_find() ä¼˜åŒ–çš„å€¼ã€‚\nfastai çš„ vision_learner ä¼šè‡ªåŠ¨ä»æ•°æ®åŠ è½½å™¨ (dls) ä¸­æ¨æ–­è¾“å‡ºç»´åº¦\næ–°å¢çš„å¤´éƒ¨å±‚ï¼ˆNew Head Layersï¼‰â€‹ æ˜¯æŒ‡å½“ä½¿ç”¨é¢„è®­ç»ƒæ¨¡å‹ï¼ˆå¦‚ResNetã€EfficientNetç­‰ï¼‰è¿›è¡Œè¿ç§»å­¦ä¹ æ—¶ï¼Œâ€‹æ›¿æ¢æˆ–æ·»åŠ çš„æœ€åä¸€å±‚ï¼ˆæˆ–å‡ å±‚ï¼‰ç½‘ç»œç»“æ„ï¼Œç”¨äºé€‚é…å½“å‰ä»»åŠ¡çš„è¾“å‡ºéœ€æ±‚\nå°†è®­ç»ƒå¥½çš„Resnet26dåº”ç”¨åˆ°æµ‹è¯•é›†ä¸Š # tst_files = get_image_files(path/\u0026#39;test_images\u0026#39;).sorted() tst_dl = dls.test_dl(tst_files) test_dl() æ˜¯ â€‹fastai åº“ä¸­ DataLoaders å¯¹è±¡çš„ä¸€ä¸ªæ–¹æ³•ï¼Œä¸“é—¨ç”¨äºä¸ºæµ‹è¯•é›†ï¼ˆæˆ–æ¨ç†æ•°æ®ï¼‰â€‹åˆ›å»ºä¸€ä¸ªä¸è®­ç»ƒæ—¶æ•°æ®é¢„å¤„ç†ä¸€è‡´çš„æ•°æ®åŠ è½½å™¨\nprobs,_,idxs = learn.get_preds(dl=tst_dl, with_decoded=True) idxs tensor([7, 8, 4, \u0026hellip;, 8, 1, 5])\nmapping = dict(enumerate(dls.vocab)) results = pd.Series(idxs.numpy(), name=\u0026#34;idxs\u0026#34;).map(mapping) results 0 hispa 1 normal 2 brown_spot 3 blast 4 blast \u0026hellip; 3464 dead_heart 3465 hispa 3466 normal 3467 bacterial_leaf_streak 3468 dead_heart Name: idxs, Length: 3469, dtype: object\nss = pd.read_csv(path/\u0026#39;sample_submission.csv\u0026#39;) ss[\u0026#39;label\u0026#39;] = results ss.to_csv(\u0026#39;subm.csv\u0026#39;, index=False) !head subm.csv image_id,label 200001.jpg,hispa 200002.jpg,normal 200003.jpg,brown_spot 200004.jpg,blast 200005.jpg,blast 200006.jpg,brown_spot 200007.jpg,dead_heart 200008.jpg,brown_spot 200009.jpg,hispa\næ”¹è¿›ä¸€ä¸‹Resnet26d # ä¸ºäº†è®©æ¨¡å‹è®­ç»ƒçš„æ›´å¿«ï¼Œæˆ‘ä»¬å¯ä»¥å°†å›¾åƒçš„å¤§å°ç¼©å°ï¼ˆè®©åƒç´ æ•°é‡å‡å°‘4å€ï¼‰\ntrn_path = Path(\u0026#39;sml\u0026#39;) resize_images(path/\u0026#39;train_images\u0026#39;, dest=trn_path, max_size=256, recurse=True) fastai æœ‰ä¸€ä¸ªå‡½æ•°å¯ä»¥åšåˆ°è¿™ä¸€ç‚¹ï¼ŒåŒæ—¶ä¿æŒæ•°æ®çš„æ–‡ä»¶å¤¹ç»“æ„å³resize_images\ndls = ImageDataLoaders.from_folder(trn_path, valid_pct=0.2, seed=42, item_tfms=Resize((256,192))) dls.show_batch(max_n=3) å°†ä¹‹å‰è®­ç»ƒçš„æ­¥éª¤å°è£…èµ·æ¥\ndef train(arch, item, batch, epochs=5): dls = ImageDataLoaders.from_folder(trn_path, seed=42, valid_pct=0.2, item_tfms=item, batch_tfms=batch) learn = vision_learner(dls, arch, metrics=error_rate).to_fp16() learn.fine_tune(epochs, 0.01) return learn learn = train(\u0026#39;resnet26d\u0026#39;, item=Resize(192), batch=aug_transforms(size=128, min_scale=0.75)) epoch train_loss valid_loss error_rate time 0 1.942248 1.426470 0.463239 00:17 epoch train_loss valid_loss error_rate time 0 1.289961 0.999535 0.333974 00:19 1 1.018504 0.688591 0.216242 00:18 2 0.740462 0.482486 0.160019 00:18 3 0.529927 0.406155 0.124459 00:18 4 0.435775 0.372298 0.116771 00:18 å¯ä»¥çœ‹åˆ°å‡†ç¡®ç‡æ˜¯æœ‰äº†æå‡\nä½¿ç”¨ConNeXt_smallæ¨¡å‹ # å®šä¹‰convnext_small_in22kå­¦ä¹ æ¨¡å‹ # arch = \u0026#39;convnext_small_in22k\u0026#39; learn = train(arch, item=Resize(192, method=\u0026#39;squish\u0026#39;), batch=aug_transforms(size=128, min_scale=0.75)) epoch train_loss valid_loss error_rate time 0 1.245993 0.795927 0.255166 00:55 epoch train_loss valid_loss error_rate time 0 0.647190 0.434121 0.148967 00:53 1 0.477503 0.379062 0.119654 00:53 2 0.300822 0.191345 0.060548 00:52 3 0.192040 0.134807 0.039404 00:52 4 0.127018 0.125794 0.036521 00:52 æŸå¤±é™ä½äº†å¾ˆå¤šï¼ŒConvnextæ¨¡å‹åœ¨è¿™ä¸ªæ•°æ®é›†ä¸Šçš„æ•ˆæœè¦æ¯”Resnetå¥½\nå¯¹å›¾åƒè¿›è¡Œå¡«å……å¤„ç† # dls = ImageDataLoaders.from_folder(trn_path, valid_pct=0.2, seed=42, item_tfms=Resize(192, method=ResizeMethod.Pad, pad_mode=PadMode.Zeros)) dls.show_batch(max_n=3) å†æ¬¡è¿›è¡Œè®­ç»ƒ # learn = train(arch, item=Resize((256,192), method=ResizeMethod.Pad, pad_mode=PadMode.Zeros), batch=aug_transforms(size=(171,128), min_scale=0.75)) epoch train_loss valid_loss error_rate time 0 1.225350 0.838977 0.261413 00:44 epoch train_loss valid_loss error_rate time 0 0.647279 0.475882 0.153292 00:51 1 0.532679 0.375510 0.116290 00:51 2 0.348923 0.203416 0.067275 00:50 3 0.207750 0.132006 0.037001 00:50 4 0.140231 0.124632 0.035079 00:50 å¥½åƒæ•ˆæœä¹Ÿæ²¡å¾ˆå¤§çš„æå‡:(\nåº”ç”¨æµ‹è¯•æ—¶é—´å¢å¼ºTest time augmentationï¼ˆTTAï¼‰ # During inference or validation, creating multiple versions of each image, using data augmentation, and then taking the average or maximum of the predictions for each augmented version of the image. åœ¨æ¨ç†æˆ–éªŒè¯æœŸé—´ï¼Œä½¿ç”¨æ•°æ®å¢å¼ºåˆ›å»ºæ¯ä¸ªå›¾åƒçš„å¤šä¸ªç‰ˆæœ¬ï¼Œç„¶åå¯¹å›¾åƒçš„æ¯ä¸ªå¢å¼ºç‰ˆæœ¬å–é¢„æµ‹çš„å¹³å‡å€¼æˆ–æœ€å¤§å€¼ã€‚\nç”±ä¸Šé¢çš„è®­ç»ƒå¯çŸ¥åœ¨æ²¡æœ‰TTAçš„æƒ…å†µä¸‹é”™è¯¯ç‡æ˜¯ï¼š\nvalid = learn.dls.valid preds,targs = learn.get_preds(dl=valid) error_rate(preds, targs) TensorBase(0.0351)\ntta_preds,_ = learn.tta(dl=valid) error_rate(tta_preds, targs) TensorBase(0.0332)\né”™è¯¯ç‡æœ‰é™ä½ï¼\nå°†ConvNextåº”ç”¨çš„è§„æ¨¡æ‰©å¤§ # trn_path = path/\u0026#39;train_images\u0026#39; learn = train(arch, epochs=12, item=Resize((480, 360), method=ResizeMethod.Pad, pad_mode=PadMode.Zeros), batch=aug_transforms(size=(256,192), min_scale=0.75)) epoch train_loss valid_loss error_rate time 0 1.097865 0.666030 0.218645 01:10 epoch train_loss valid_loss error_rate time 0 0.530017 0.320848 0.103316 01:27 1 0.399917 0.254228 0.077367 01:28 2 0.354157 0.281102 0.087938 01:27 3 0.306803 0.235106 0.074003 01:27 4 0.222612 0.154293 0.043248 01:28 5 0.158987 0.174899 0.046612 01:27 6 0.127389 0.122164 0.035079 01:28 7 0.089526 0.120237 0.030754 01:27 8 0.070281 0.117129 0.032196 01:28 9 0.052415 0.094729 0.024507 01:27 10 0.044216 0.091565 0.024027 01:28 11 0.034039 0.091716 0.023546 01:28 åº”ç”¨tta\ntta_preds,targs = learn.tta(dl=learn.dls.valid) error_rate(tta_preds, targs) TensorBase(0.0226)\nå¯ä»¥çœ‹åˆ°æ˜¯é™ä½äº†æŸå¤±ç‡çš„\nå°†ConvNextåº”ç”¨åˆ°æµ‹è¯•é›†ä¸Š # tst_files = get_image_files(path/\u0026#39;test_images\u0026#39;).sorted() tst_dl = learn.dls.test_dl(tst_files) preds,_ = learn.tta(dl=tst_dl) idxs = preds.argmax(dim=1) ä½¿ç”¨PyTorch ä¸­çš„ argmaxæ¥é€‰å–å‡ºæœ€å¤§æ¦‚ç‡æ‰€åœ¨çš„æ ‡ç­¾ï¼Œdim=1å³æ²¿ç±»åˆ«ç»´åº¦ï¼ˆæ¯è¡Œï¼‰è®¡ç®—ï¼Œè¿”å›æ¯ä¸ªæ ·æœ¬é¢„æµ‹æ¦‚ç‡æœ€é«˜çš„ç±»åˆ«ç´¢å¼•\nvocab = np.array(learn.dls.vocab) # ä½¿ç”¨vocabæ˜ å°„ results = pd.Series(vocab[idxs], name=\u0026#34;idxs\u0026#34;) åœ¨ fastai ä¸­ï¼Œlearn.dls.vocab æ˜¯æ•°æ®åŠ è½½å™¨ (DataLoaders) çš„ç±»åˆ«æ ‡ç­¾åˆ—è¡¨ï¼Œç”¨äºå°†æ¨¡å‹è¾“å‡ºçš„é¢„æµ‹ç´¢å¼•ï¼ˆæ•°å­—ï¼‰æ˜ å°„å›å¯è¯»çš„ç±»åˆ«åç§°ï¼ˆå¦‚å­—ç¬¦ä¸²ï¼‰\nss = pd.read_csv(path/\u0026#39;sample_submission.csv\u0026#39;) ss[\u0026#39;label\u0026#39;] = results ss.to_csv(\u0026#39;subm2.csv\u0026#39;, index=False) !head subm2.csv image_id,label 200001.jpg,hispa 200002.jpg,normal 200003.jpg,blast 200004.jpg,blast 200005.jpg,blast 200006.jpg,brown_spot 200007.jpg,dead_heart 200008.jpg,brown_spot 200009.jpg,hispa\nåˆ›å»ºå¤šè¾“å‡ºçš„æ¨¡å‹ # åˆ›å»ºæ¨¡å‹å‡†å¤‡ # df = pd.read_csv(path/\u0026#39;train.csv\u0026#39;, index_col=\u0026#39;image_id\u0026#39;) df.head() label variety age image_id 100330.jpg bacterial_leaf_blight ADT45 45 100365.jpg bacterial_leaf_blight ADT45 45 100382.jpg bacterial_leaf_blight ADT45 45 100632.jpg bacterial_leaf_blight ADT45 45 101918.jpg bacterial_leaf_blight ADT45 45 æˆ‘ä»¬è®©image_idä½œä¸ºç´¢å¼•ï¼Œæ–¹ä¾¿æŸ¥æ‰¾\nDataBlockä½¿ç”¨ get_image_files æ¥è·å–è®­ç»ƒå›¾åƒåˆ—è¡¨ï¼Œè¯¥åˆ—è¡¨è¿”å› Path å¯¹è±¡ï¼Œè€Œå¦‚æœè¦æŸ¥æ‰¾æŸä¸ªé¡¹ç›®ä»¥è·å–å…¶ç§ç±»ï¼Œæˆ‘ä»¬éœ€è¦ä¼ é€’å…¶ name ã€‚è¿™æ˜¯ä¸€ä¸ªæ‰§è¡Œæ­¤æ“ä½œçš„å‡½æ•°ï¼š\ndef get_variety(p): return df.loc[p.name, \u0026#39;variety\u0026#39;] dls = DataBlock( blocks=(ImageBlock,CategoryBlock,CategoryBlock), n_inp=1, get_items=get_image_files, get_y = [parent_label,get_variety], splitter=RandomSplitter(0.2, seed=42), item_tfms=Resize(192, method=\u0026#39;squish\u0026#39;), batch_tfms=aug_transforms(size=128, min_scale=0.75) ).dataloaders(trn_path) ä½¿ç”¨ DataBlock APIï¼Œè¿™æ˜¯ä¸€ç§çµæ´»ä¸”æ–¹ä¾¿çš„æ–¹å¼ï¼Œå¯ä»¥å°†æ•°æ®å¤„ç†ç®¡é“çš„å„ä¸ªéƒ¨åˆ†è¿æ¥åœ¨ä¸€èµ· DataBlock å°†ä»æ¯ä¸ªæ–‡ä»¶ä¸­åˆ›å»º 3 ä¸ªå†…å®¹ï¼šä¸€ä¸ªå›¾åƒï¼ˆæ–‡ä»¶çš„å†…å®¹ï¼‰å’Œ 2 ä¸ªåˆ†ç±»å˜é‡ï¼ˆç–¾ç—…å’Œå“ç§ï¼‰ã€‚\ndls.show_batch(max_n=6) å®šä¹‰å¤šè¾“å‡ºçš„å­¦ä¹ æ¨¡å‹ # å¤šè¾“å‡ºçš„å…³é”®çš„åŒºåˆ«åœ¨äºï¼Œæˆ‘ä»¬çš„æŒ‡æ ‡å’ŒæŸå¤±ç°åœ¨å°†æ¥æ”¶ä¸‰ä¸ªä¸œè¥¿è€Œä¸æ˜¯ä¸¤ä¸ªï¼šæ¨¡å‹è¾“å‡ºï¼ˆå³æŒ‡æ ‡å’ŒæŸå¤±å‡½æ•°è¾“å…¥ï¼‰å’Œä¸¤ä¸ªç›®æ ‡ï¼ˆç–¾ç—…å’Œå¤šæ ·æ€§ï¼‰ã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦é‡æ–°å®šä¹‰æŒ‡æ ‡ï¼ˆ error_rate ï¼‰å’ŒæŸå¤±å‡½æ•°ï¼ˆ cross_entropy ï¼‰ï¼Œä»¥ä¼ é€’ disease ç›®æ ‡ï¼š\narch = \u0026#39;convnext_small_in22k\u0026#39; lr = 0.01 ä¸ºäº†é¢„æµ‹æ¯ç§ç–¾ç—…å’Œæ¯ç§ç–¾ç—…çš„æ¦‚ç‡ï¼Œæˆ‘ä»¬ç°åœ¨éœ€è¦æ¨¡å‹è¾“å‡ºä¸€ä¸ªé•¿åº¦ä¸º 20 çš„å¼ é‡ï¼Œå› ä¸ºæœ‰ 10 ç§å¯èƒ½çš„ç–¾ç—…å’Œ 10 ç§å¯èƒ½çš„ç–¾ç—…ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡è®¾ç½® n_out=20\nlearn = vision_learner(dls, arch, n_out=20).to_fp16() å› ä¸ºè¦é¢„æµ‹ä¸¤ä¸ªè¾“å‡ºäº†ï¼Œä¹‹å‰çš„æŸå¤±å‡½æ•°æ˜¯åªé’ˆå¯¹ç–¾ç—…çš„ï¼Œåœ¨è¿™é‡ŒæŸå¤±å‡½æ•°ä½¿ç”¨çš„æ˜¯cross_entropyå³äº¤å‰ç†µæŸå¤±å‡½æ•°\ndef disease_loss(inp,disease,variety): return F.cross_entropy(inp[:,:10],disease) def variety_loss(inp,disease,variety): return F.cross_entropy(inp[:,10:],variety) def combine_loss(inp,disease,variety):return disease_loss(inp,disease,variety)+variety_loss(inp,disease,variety) def disease_err(inp,disease,variety): return error_rate(inp[:,:10],disease) def variety_err(inp,disease,variety): return error_rate(inp[:,10:],variety) err_metrics = (disease_err,variety_err) all_metrics = err_metrics+(disease_loss,variety_loss) å¤šè¾“å‡ºæ¨¡å‹è®­ç»ƒ # learn = vision_learner(dls, arch, loss_func=combine_loss, metrics=all_metrics, n_out=20).to_fp16() learn.fine_tune(5, lr) epoch train_loss valid_loss disease_err variety_err disease_loss variety_loss time 0 2.276296 1.189668 0.257088 0.128304 0.783521 0.406147 00:51 epoch train_loss valid_loss disease_err variety_err disease_loss variety_loss time 0 1.005188 0.580068 0.127823 0.059106 0.387363 0.192705 00:54 1 0.757706 0.387292 0.094666 0.036040 0.280007 0.107285 00:53 2 0.477868 0.262185 0.061509 0.022585 0.193384 0.068801 00:54 3 0.269435 0.171966 0.040846 0.009611 0.134649 0.037317 00:54 4 0.200365 0.163008 0.037963 0.009130 0.124750 0.038258 00:53 æ·»åŠ softmaxå¹¶æŸ¥çœ‹è¾“å‡ºç»“æœ # # è·å–éªŒè¯é›†çš„é¢„æµ‹ preds, targs = learn.get_preds(dl=learn.dls.valid) print(learn.dls.vocab) print(len(learn.dls.vocab)) [[\u0026lsquo;bacterial_leaf_blight\u0026rsquo;, \u0026lsquo;bacterial_leaf_streak\u0026rsquo;, \u0026lsquo;bacterial_panicle_blight\u0026rsquo;, \u0026lsquo;blast\u0026rsquo;, \u0026lsquo;brown_spot\u0026rsquo;, \u0026lsquo;dead_heart\u0026rsquo;, \u0026lsquo;downy_mildew\u0026rsquo;, \u0026lsquo;hispa\u0026rsquo;, \u0026rsquo;normal\u0026rsquo;, \u0026rsquo;tungro\u0026rsquo;], [\u0026lsquo;ADT45\u0026rsquo;, \u0026lsquo;AndraPonni\u0026rsquo;, \u0026lsquo;AtchayaPonni\u0026rsquo;, \u0026lsquo;IR20\u0026rsquo;, \u0026lsquo;KarnatakaPonni\u0026rsquo;, \u0026lsquo;Onthanel\u0026rsquo;, \u0026lsquo;Ponni\u0026rsquo;, \u0026lsquo;RR\u0026rsquo;, \u0026lsquo;Surya\u0026rsquo;, \u0026lsquo;Zonal\u0026rsquo;]] 2\n# ç–¾ç—…ç±»åˆ«æœ‰10ä¸ªï¼Œå“ç§ç±»åˆ«ä¹Ÿæœ‰10ä¸ª num_classes_disease = len(learn.dls.vocab[0]) # 10 num_classes_variety = len(learn.dls.vocab[1]) # 10 # è·å–éªŒè¯é›†çš„é¢„æµ‹ preds, targs = learn.get_preds(dl=learn.dls.valid) # åˆ’åˆ†ç–¾ç—…å’Œå“ç§çš„é¢„æµ‹ç»“æœ disease_preds = preds[:, :num_classes_disease] # è·å–ç¬¬ä¸€éƒ¨åˆ†ï¼Œå³ç–¾ç—…çš„é¢„æµ‹ variety_preds = preds[:, num_classes_disease:] # è·å–ç¬¬äºŒéƒ¨åˆ†ï¼Œå³å“ç§çš„é¢„æµ‹ # ä½¿ç”¨ softmax è®¡ç®—æ¦‚ç‡ disease_probabilities = F.softmax(disease_preds, dim=1) variety_probabilities = F.softmax(variety_preds, dim=1) # è·å–åˆ†ç±»çš„æœ€å¤§æ¦‚ç‡å¯¹åº”çš„ç±»åˆ«ç´¢å¼• predicted_disease_classes = disease_probabilities.argmax(dim=1) # æ‰¾å‡ºç–¾ç—…ç±»åˆ«çš„é¢„æµ‹ predicted_variety_classes = variety_probabilities.argmax(dim=1) # æ‰¾å‡ºå“ç§ç±»åˆ«çš„é¢„æµ‹ # æ˜ å°„ç±»åˆ«ç´¢å¼•å›å®é™…æ ‡ç­¾ predicted_disease_labels = np.array(learn.dls.vocab[0])[predicted_disease_classes] predicted_variety_labels = np.array(learn.dls.vocab[1])[predicted_variety_classes] # æŸ¥çœ‹éƒ¨åˆ†é¢„æµ‹ç»“æœ results_df = pd.DataFrame({ \u0026#39;Predicted Disease\u0026#39;: predicted_disease_labels[:10], # å‰10ä¸ªçš„é¢„æµ‹ç–¾ç—… \u0026#39;Predicted Variety\u0026#39;: predicted_variety_labels[:10], # å‰10ä¸ªçš„é¢„æµ‹å“ç§ }) print(results_df) Predicted Disease Predicted Variety blast AndraPonni normal RR tungro ADT45 bacterial_leaf_streak KarnatakaPonni dead_heart ADT45 tungro ADT45 normal ADT45 normal ADT45 brown_spot ADT45 bacterial_leaf_blight ADT45 ","date":"27 March 2025","externalUrl":null,"permalink":"/posts/deeplearning/learning-based-paddydiseaseclassification/","section":"Posts","summary":"","title":"Learning Based Paddy_Disease_Classification","type":"posts"},{"content":"","date":"27 March 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"27 March 2025","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"27 March 2025","externalUrl":null,"permalink":"/","section":"æ˜¥æ—¥æ±€","summary":"","title":"æ˜¥æ—¥æ±€","type":"page"},{"content":"","date":"27 March 2025","externalUrl":null,"permalink":"/categories/","section":"æ–‡ç« åˆ†ç±»","summary":"","title":"æ–‡ç« åˆ†ç±»","type":"categories"},{"content":"","date":"26 March 2025","externalUrl":null,"permalink":"/series/algorithm-learing/","section":"Series","summary":"","title":"Algorithm Learing","type":"series"},{"content":"","date":"26 March 2025","externalUrl":null,"permalink":"/categories/algorithm-problems/","section":"æ–‡ç« åˆ†ç±»","summary":"","title":"Algorithm Problems","type":"categories"},{"content":" å“ˆå¸Œ # æœ¬ç³»åˆ—çš„å¤§éƒ¨åˆ†éƒ½æ˜¯å¯¹labuladongå’Œä»£ç éšæƒ³å½•ç½‘ç«™çš„é¢˜ç›®çš„ç»ƒæ‰‹æ±‡æ€»(éƒ¨åˆ†æ˜¯åšä¸»è‡ªå·±ç»“åˆleetcodeå’Œæ´›è°·é¢˜ç›®çš„è¡¥å……ï¼‰åˆè¡·æ˜¯åšä¸»è‡ªç”¨å­¦ä¹ å“’!\nè¯·æ‰€æœ‰é˜…è¯»è¿™ç³»åˆ—åšå®¢çš„å‹å‹å…ˆç§»æ­¥é˜…è§ˆä»–ä»¬çš„ç½‘ç«™ï¼Œæ²¡æœ‰è¿™äº›ä¼˜ç§€ç½‘ç«™çš„åˆ†äº«ä¸ä¼šæœ‰è¿™ç³»åˆ—çš„æ–‡ç« ï¼Œæˆ‘åªæ˜¯çŸ¥è¯†çš„æ¬è¿å·¥ï¼\nä¸¤æ•°ä¹‹å’Œ # é¢˜ç›®æè¿° # ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å€¼ targetï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡º å’Œä¸ºç›®æ ‡å€¼ target çš„é‚£ ä¸¤ä¸ª æ•´æ•°ï¼Œå¹¶è¿”å›å®ƒä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚\nä½ å¯ä»¥å‡è®¾æ¯ç§è¾“å…¥åªä¼šå¯¹åº”ä¸€ä¸ªç­”æ¡ˆï¼Œå¹¶ä¸”ä½ ä¸èƒ½ä½¿ç”¨ä¸¤æ¬¡ç›¸åŒçš„å…ƒç´ ã€‚\nä½ å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç­”æ¡ˆã€‚\nACä»£ç  # class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { unordered_map\u0026lt;int,int\u0026gt;map; for(int i=0;i\u0026lt;nums.size();i++) { int n=target-nums[i]; if(map.find(n)!=map.end())return {map.find(n)-\u0026gt;second,i}; else map.insert(pair\u0026lt;int,int\u0026gt;(nums[i],i)); } return {}; } }; P1102 A-B æ•°å¯¹ # ç»™å‡ºä¸€ä¸²æ­£æ•´æ•°æ•°åˆ—ä»¥åŠä¸€ä¸ªæ­£æ•´æ•°C, è¦æ±‚è®¡ç®—å‡ºæ‰€æœ‰æ»¡è¶³ A - B = Câ€‹ çš„æ•°å¯¹çš„ä¸ªæ•°ï¼ˆä¸åŒä½ç½®çš„æ•°å­—ä¸€æ ·çš„æ•°å¯¹ç®—ä¸åŒçš„æ•°å¯¹ï¼‰ã€‚\nè¾“å…¥æ ¼å¼ # è¾“å…¥å…±ä¸¤è¡Œã€‚\nç¬¬ä¸€è¡Œï¼Œä¸¤ä¸ªæ­£æ•´æ•° N,Cã€‚\nç¬¬äºŒè¡Œï¼ŒN ä¸ªæ­£æ•´æ•°ï¼Œä½œä¸ºè¦æ±‚å¤„ç†çš„é‚£ä¸²æ•°ã€‚\nè¾“å‡ºæ ¼å¼ # ä¸€è¡Œï¼Œè¡¨ç¤ºè¯¥ä¸²æ­£æ•´æ•°ä¸­åŒ…å«çš„æ»¡è¶³ A - B = Câ€‹ çš„æ•°å¯¹çš„ä¸ªæ•°ã€‚\nè¾“å…¥ # 4 1 1 1 2 3\nè¾“å‡º # 3\nè¯´æ˜/æç¤º # å¯¹äº 75%â€‹ çš„æ•°æ®ï¼Œâ€‹1\u0026lt; N \u0026lt; 2000â€‹ã€‚\nå¯¹äº100%çš„æ•°æ®ï¼Œ1 \u0026lt; N \u0026lt; 2Ã—10^5â€‹ï¼Œ0 \u0026lt; a_i \u0026lt; 2^30â€‹ï¼Œ1 \u0026lt; C \u0026lt; 2^30â€‹ã€‚\nACä»£ç  # #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; int main(){ int N, C; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; C; vector\u0026lt;int\u0026gt; nums(N); unordered_map\u0026lt;int, int\u0026gt; freq; // ä½¿ç”¨ int ä½œä¸ºé¢‘æ¬¡ç±»å‹ for(int i=0;i\u0026lt;N;i++){ int x; cin \u0026gt;\u0026gt; x; nums[i]=x; freq[x]++; } ll res = 0;//æ³¨æ„ç»“æœæ˜¯long long å› ä¸ºresä¼šç´¯åŠ  for(const int \u0026amp;x : nums){ int target = x + C; if(freq.find(target) != freq.end()){ res += freq[target]; } } cout \u0026lt;\u0026lt; res; } ","date":"26 March 2025","externalUrl":null,"permalink":"/posts/algorithm/%E5%93%88%E5%B8%8C/","section":"Posts","summary":"","title":"å“ˆå¸Œ","type":"posts"},{"content":" å›æº¯ # æœ¬ç³»åˆ—çš„å¤§éƒ¨åˆ†éƒ½æ˜¯å¯¹labuladongå’Œä»£ç éšæƒ³å½•ç½‘ç«™çš„é¢˜ç›®çš„ç»ƒæ‰‹æ±‡æ€»(éƒ¨åˆ†æ˜¯åšä¸»è‡ªå·±ç»“åˆleetcodeå’Œæ´›è°·é¢˜ç›®çš„è¡¥å……ï¼‰åˆè¡·æ˜¯åšä¸»è‡ªç”¨å­¦ä¹ å“’!\nè¯·æ‰€æœ‰é˜…è¯»è¿™ç³»åˆ—åšå®¢çš„å‹å‹å…ˆç§»æ­¥é˜…è§ˆä»–ä»¬çš„ç½‘ç«™ï¼Œæ²¡æœ‰è¿™äº›ä¼˜ç§€ç½‘ç«™çš„åˆ†äº«ä¸ä¼šæœ‰è¿™ç³»åˆ—çš„æ–‡ç« ï¼Œæˆ‘åªæ˜¯çŸ¥è¯†çš„æ¬è¿å·¥ï¼\nå›æº¯ä¸‰éƒ¨æ›²\n1)ç¡®å®šå›æº¯å‡½æ•°çš„è¿”å›å€¼åŠå‚æ•°\næ¯æ¬¡å›æº¯æ—¶è¦æ›´æ–°ä»€ä¹ˆï¼Œè¦è¿”å›ä»€ä¹ˆ\n2ï¼‰å›æº¯å‡½æ•°çš„ç»ˆæ­¢æ¡ä»¶\n3ï¼‰å›æº¯æœç´¢çš„éå†è¿‡ç¨‹\nvector\u0026lt;vector\u0026gt; result\nvector path\nP4913 ã€æ·±åŸº16.ä¾‹3ã€‘äºŒå‰æ ‘æ·±åº¦ # é¢˜ç›®æè¿° # æœ‰ä¸€ä¸ª n(n\u0026lt;10^6)â€‹ ä¸ªç»“ç‚¹çš„äºŒå‰æ ‘ã€‚ç»™å‡ºæ¯ä¸ªç»“ç‚¹çš„ä¸¤ä¸ªå­ç»“ç‚¹ç¼–å·ï¼ˆå‡ä¸è¶…è¿‡ nï¼‰ï¼Œå»ºç«‹ä¸€æ£µäºŒå‰æ ‘ï¼ˆæ ¹èŠ‚ç‚¹çš„ç¼–å·ä¸º 1â€‹ï¼‰ï¼Œå¦‚æœæ˜¯å¶å­ç»“ç‚¹ï¼Œåˆ™è¾“å…¥ 0 0ã€‚\nå»ºå¥½è¿™æ£µäºŒå‰æ ‘ä¹‹åï¼Œè¯·æ±‚å‡ºå®ƒçš„æ·±åº¦ã€‚äºŒå‰æ ‘çš„æ·±åº¦æ˜¯æŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­ç»“ç‚¹æ—¶ï¼Œæœ€å¤šç»è¿‡äº†å‡ å±‚ã€‚\nè¾“å…¥æ ¼å¼ # ç¬¬ä¸€è¡Œä¸€ä¸ªæ•´æ•° nâ€‹ï¼Œè¡¨ç¤ºç»“ç‚¹æ•°ã€‚\nä¹‹å nè¡Œï¼Œç¬¬ i è¡Œä¸¤ä¸ªæ•´æ•° lã€rï¼Œåˆ†åˆ«è¡¨ç¤ºç»“ç‚¹ i çš„å·¦å³å­ç»“ç‚¹ç¼–å·ã€‚è‹¥ l=0 åˆ™è¡¨ç¤ºæ— å·¦å­ç»“ç‚¹ï¼Œr=0 åŒç†ã€‚\nè¾“å‡ºæ ¼å¼ # ä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºæœ€å¤§ç»“ç‚¹æ·±åº¦ã€‚\nè¾“å…¥ # 7 2 7 3 6 4 5 0 0 0 0 0 0 0 0 è¾“å‡º # 4 ACä»£ç  # #include \u0026lt;iostream\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include\u0026lt;math.h\u0026gt; using namespace std; unordered_map\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt; tree; int maxDepth = 0; void traverse(int node, int currentDepth) { int left = tree[node].first; int right = tree[node].second; maxDepth = max(maxDepth,currentDepth); // éå†å·¦å­æ ‘ if (left != 0) { traverse(left, currentDepth + 1); } // éå†å³å­æ ‘ if (right != 0) { traverse(right, currentDepth + 1); } } int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; tree[i] = {l, r}; } traverse(1, 1); cout \u0026lt;\u0026lt; maxDepth \u0026lt;\u0026lt; endl; return 0; } P1025 [NOIP 2001 æé«˜ç»„] æ•°çš„åˆ’åˆ† # é¢˜ç›®æè¿° # å°†æ•´æ•° n åˆ†æˆ kä»½ï¼Œä¸”æ¯ä»½ä¸èƒ½ä¸ºç©ºï¼Œä»»æ„ä¸¤ä¸ªæ–¹æ¡ˆä¸ç›¸åŒï¼ˆä¸è€ƒè™‘é¡ºåºï¼‰ã€‚\nä¾‹å¦‚ï¼šn=7â€‹ï¼Œk=3ï¼Œä¸‹é¢ä¸‰ç§åˆ†æ³•è¢«è®¤ä¸ºæ˜¯ç›¸åŒçš„ã€‚\n1,1,5â€‹;\n1,5,1â€‹;\nâ€‹5,1,1.\né—®æœ‰å¤šå°‘ç§ä¸åŒçš„åˆ†æ³•ã€‚\nè¾“å…¥æ ¼å¼ # n,kï¼ˆ6\u0026lt;n\u0026lt; 200,2 \u0026lt;k \u0026lt;6ï¼‰\nè¾“å‡ºæ ¼å¼ # 1 ä¸ªæ•´æ•°ï¼Œå³ä¸åŒçš„åˆ†æ³•ã€‚\nè¾“å…¥ # 7 3\nè¾“å‡º # 4\nè¯´æ˜/æç¤º # å››ç§åˆ†æ³•ä¸ºï¼š\n1,1,5;\n1,2,4;\n1,3,3;\n2,2,3.\nACä»£ç  # #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, k, res = 0; stack\u0026lt;int\u0026gt; path; // å›æº¯å‡½æ•° void backtrack(int start, int sum) { // å¦‚æœå·²ç»é€‰æ‹©äº†kä¸ªæ•° if (path.size() == k) { if (sum == n) { res++; } return; } // è®¡ç®—å½“å‰æ•°æœ€å¤§å¯ä»¥æ˜¯å¤šå°‘ï¼Œé¿å…æ— æ•ˆé€’å½’ int remaining = k - path.size(); int max_i = (n - sum) / remaining; for(int i = start; i \u0026lt;= max_i; i++) { path.push(i); backtrack(i, sum + i); // ä¸‹ä¸€è½®èµ·å§‹å€¼è‡³å°‘ä¸ºiï¼Œç¡®ä¿éé€’å‡!!!å› ä¸ºå¥½å‡ ç§ç®—é‡å¤ path.pop(); } } int main(){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; backtrack(1, 0); cout \u0026lt;\u0026lt; res; return 0; } æœªåŠ å…¥è®°å¿†æ•°ç»„ï¼Œçº¯é€’å½’ï¼Œè¶…æ—¶ï¼š\n#include \u0026lt;iostream\u0026gt; using namespace std; int count(int num) { if (num == 0) return 0; int res = 1; // åŒ…æ‹¬è‡ªèº«ä½œä¸ºä¸€ä¸ªæ•°åˆ—çš„æƒ…å†µ for (int i = 1; i \u0026lt;= num / 2; ++i) { res += count(i); } return res; } int main() { int n; cin \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; count(n) \u0026lt;\u0026lt; endl; return 0; } æ”¹è¿›ï¼š\n#include \u0026lt;iostream\u0026gt; using namespace std; int dp[100001] = {0}; // è®°å¿†åŒ–æ•°ç»„ int count(int num) { if (num == 0) return 0; if (dp[num] != 0) return dp[num]; // å·²è®¡ç®—è¿‡åˆ™ç›´æ¥è¿”å› dp[num] = 1; // åˆå§‹åŒ–ä¸º1ï¼ˆè‡ªèº«ï¼‰ for (int i = 1; i \u0026lt;= num / 2; ++i) { dp[num] += count(i); } return dp[num]; } int main() { int n; cin \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; count(n) \u0026lt;\u0026lt; endl; return 0; } #include \u0026lt;iostream\u0026gt; using namespace std; const int MAX_N = 100000; // æ ¹æ®é¢˜ç›®çº¦æŸè°ƒæ•´æœ€å¤§å€¼ int dp[MAX_N + 1]; int main() { int n; cin \u0026gt;\u0026gt; n; dp[0] = 0; dp[1] = 1; for (int num = 2; num \u0026lt;= n; ++num) { dp[num] = 1; // è‡³å°‘åŒ…å«è‡ªå·± for (int i = 1; i \u0026lt;= num / 2; ++i) { dp[num] += dp[i]; //æ±‚å’Œè¿‡ç¨‹ } } cout \u0026lt;\u0026lt; dp[n] \u0026lt;\u0026lt; endl; return 0; } ã€è“æ¡¥æ¯é¢˜åº“ã€‘81305. å°é½çš„å­—æ¯æ–¹å—æ‹¼å†™ # é—®é¢˜æè¿° # å°é½æœ‰å››ä¸ªæœ¨å—ï¼Œæ¯ä¸ªæœ¨å—æ˜¯ä¸€ä¸ªç«‹æ–¹ä½“ï¼Œä¸Šé¢åˆ†åˆ«å†™æœ‰å­—æ¯è¡¨çš„å¤§å†™å­—æ¯ã€‚å¥¹æƒ³é€šè¿‡æ’åˆ—è¿™äº›æœ¨å—ï¼Œæ‹¼å‡ºä¸€äº›å•è¯ã€‚\nç»™å®šæ¯ä¸ªæœ¨å—ä¸Šçš„å­—æ¯å’Œå°é½æƒ³æ‹¼å‡ºçš„å•è¯åˆ—è¡¨ï¼Œè¯·ç¡®å®šå¥¹èƒ½æˆåŠŸæ‹¼å‡ºå“ªäº›å•è¯ã€‚\nè¾“å…¥æ ¼å¼ # ç¬¬ä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•° Nï¼Œè¡¨ç¤ºå°é½æƒ³æ‹¼å‡ºçš„å•è¯æ•°é‡ã€‚\næ¥ä¸‹æ¥çš„å››è¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºä¸€ä¸ªæœ¨å—ä¸Šå…­ä¸ªå¤§å†™å­—æ¯ã€‚\næ¥ä¸‹æ¥çš„ Nè¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸€ä¸ªå°å†™å­—æ¯æ•°é‡åœ¨ 1 åˆ° 4 ä¹‹é—´çš„å¤§å†™å­—æ¯å•è¯ã€‚\nè¾“å‡ºæ ¼å¼ # å¯¹äºå°é½æƒ³æ‹¼å‡ºçš„æ¯ä¸ªå•è¯ï¼Œå¦‚æœå¥¹èƒ½æˆåŠŸæ‹¼å‡ºï¼Œè¾“å‡º YESï¼Œå¦åˆ™è¾“å‡º NOã€‚\næ ·ä¾‹è¾“å…¥ # 6 MOOOOO OOOOOO ABCDEF UVWXYZ COW MOO ZOO MOVE CODE FARM æ ·ä¾‹è¾“å‡º # YES NO YES YES NO NO è¯„æµ‹æ•°æ®è§„æ¨¡ # 1â‰¤Nâ‰¤10ã€‚\nACä»£ç  # #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; vector\u0026lt;string\u0026gt; table; vector\u0026lt;string\u0026gt; words; bool canSpell(const string\u0026amp; word, vector\u0026lt;bool\u0026gt;\u0026amp; used, int index) { if (index == word.size()) return true; for (int i = 0; i \u0026lt; 4; i++) { if (!used[i] \u0026amp;\u0026amp; table[i].find(word[index]) != string::npos) { //æ³¨æ„stringä¹Ÿæœ‰findæ–¹æ³• != string::npos å’Œ unordered_map != map.end() æœ‰ç‚¹ç±»ä¼¼ used[i] = true; if (canSpell(word, used, index + 1)) return true; used[i] = false; } } return false; } int main() { int n; cin \u0026gt;\u0026gt; n; table.resize(4); words.resize(n); for (int i = 0; i \u0026lt; 4; i++)cin \u0026gt;\u0026gt; table[i]; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; words[i]; for (int i = 0; i \u0026lt; n; i++) { vector\u0026lt;bool\u0026gt; used(4, false); if (canSpell(words[i], used, 0)) { cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } ","date":"26 March 2025","externalUrl":null,"permalink":"/posts/algorithm/%E5%9B%9E%E6%BA%AF/","section":"Posts","summary":"","title":"å›æº¯","type":"posts"},{"content":" å¹¶æŸ¥é›† # æœ¬ç³»åˆ—çš„å¤§éƒ¨åˆ†éƒ½æ˜¯å¯¹labuladongå’Œä»£ç éšæƒ³å½•ç½‘ç«™çš„é¢˜ç›®çš„ç»ƒæ‰‹æ±‡æ€»(éƒ¨åˆ†æ˜¯åšä¸»è‡ªå·±ç»“åˆleetcodeå’Œæ´›è°·é¢˜ç›®çš„è¡¥å……ï¼‰åˆè¡·æ˜¯åšä¸»è‡ªç”¨å­¦ä¹ å“’!\nè¯·æ‰€æœ‰é˜…è¯»è¿™ç³»åˆ—åšå®¢çš„å‹å‹å…ˆç§»æ­¥é˜…è§ˆä»–ä»¬çš„ç½‘ç«™ï¼Œæ²¡æœ‰è¿™äº›ä¼˜ç§€ç½‘ç«™çš„åˆ†äº«ä¸ä¼šæœ‰è¿™ç³»åˆ—çš„æ–‡ç« ï¼Œæˆ‘åªæ˜¯çŸ¥è¯†çš„æ¬è¿å·¥ï¼\nâ€œå¹¶æŸ¥é›†ç”¨äºè§£å†³è¿é€šæ€§é—®é¢˜â€\ntemplate\njoinå‡½æ•°ä¸€å®šè¦å…ˆé€šè¿‡findå‡½æ•°å¯»æ ¹å†è¿›è¡Œå…³è”\nint n = 1005; // næ ¹æ®é¢˜ç›®ä¸­èŠ‚ç‚¹æ•°é‡è€Œå®šï¼Œä¸€èˆ¬æ¯”èŠ‚ç‚¹æ•°é‡å¤§ä¸€ç‚¹å°±å¥½ vector\u0026lt;int\u0026gt; father (n, 0); // å¹¶æŸ¥é›†åˆå§‹åŒ– void init() { for (int i = 0; i \u0026lt; n; ++i) { father[i] = i; } } // å¹¶æŸ¥é›†é‡Œå¯»æ ¹çš„è¿‡ç¨‹ int find(int u) { return u == father[u] ? u : father[u] = find(father[u]); // è·¯å¾„å‹ç¼©,å°†å¤šå±‚å‹ç¼©ä¸ºä¸¤å±‚ï¼Œåªæœ‰ç¬¬ä¸€å±‚æ˜¯æ ¹èŠ‚ç‚¹ } // åˆ¤æ–­ u å’Œ væ˜¯å¦æ‰¾åˆ°åŒä¸€ä¸ªæ ¹ bool isSame(int u, int v) { u = find(u); v = find(v); return u == v; } // å°†v-\u0026gt;u è¿™æ¡è¾¹åŠ å…¥å¹¶æŸ¥é›† void join(int u, int v) { u = find(u); // å¯»æ‰¾uçš„æ ¹ v = find(v); // å¯»æ‰¾vçš„æ ¹ if (u == v) return ; // å¦‚æœå‘ç°æ ¹ç›¸åŒï¼Œåˆ™è¯´æ˜åœ¨ä¸€ä¸ªé›†åˆï¼Œä¸ç”¨ä¸¤ä¸ªèŠ‚ç‚¹ç›¸è¿ç›´æ¥è¿”å› father[v] = u; } åˆ é™¤å†—ä½™è¾¹â…¡ï¼ˆæœ‰å‘å›¾ï¼‰ # æœ‰ä¸€ç§æœ‰å‘æ ‘,è¯¥æ ‘åªæœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œæ‰€æœ‰å…¶ä»–èŠ‚ç‚¹éƒ½æ˜¯è¯¥æ ¹èŠ‚ç‚¹çš„åç»§ã€‚è¯¥æ ‘é™¤äº†æ ¹èŠ‚ç‚¹ä¹‹å¤–çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸”åªæœ‰ä¸€ä¸ªçˆ¶èŠ‚ç‚¹ï¼Œè€Œæ ¹èŠ‚ç‚¹æ²¡æœ‰çˆ¶èŠ‚ç‚¹ã€‚æœ‰å‘æ ‘æ‹¥æœ‰ n ä¸ªèŠ‚ç‚¹å’Œ n - 1 æ¡è¾¹ã€‚è¾“å…¥ä¸€ä¸ªæœ‰å‘å›¾ï¼Œè¯¥å›¾ç”±ä¸€ä¸ªæœ‰ç€ n ä¸ªèŠ‚ç‚¹(èŠ‚ç‚¹ç¼–å· ä» 1 åˆ° n)ï¼Œn æ¡è¾¹ï¼Œè¯·è¿”å›ä¸€æ¡å¯ä»¥åˆ é™¤çš„è¾¹ï¼Œä½¿å¾—åˆ é™¤è¯¥æ¡è¾¹ä¹‹åè¯¥æœ‰å‘å›¾å¯ä»¥è¢«å½“ä½œä¸€é¢—æœ‰å‘æ ‘ã€‚\nè¾“å…¥æè¿°\nç¬¬ä¸€è¡Œè¾“å…¥ä¸€ä¸ªæ•´æ•° Nï¼Œè¡¨ç¤ºæœ‰å‘å›¾ä¸­èŠ‚ç‚¹å’Œè¾¹çš„ä¸ªæ•°ã€‚\nåç»­ N è¡Œï¼Œæ¯è¡Œè¾“å…¥ä¸¤ä¸ªæ•´æ•° s å’Œ tï¼Œä»£è¡¨è¿™æ˜¯ s èŠ‚ç‚¹è¿æ¥å¹¶æŒ‡å‘ t èŠ‚ç‚¹çš„å•å‘è¾¹\nè¾“å‡ºæè¿°\nè¾“å‡ºä¸€æ¡å¯ä»¥åˆ é™¤çš„è¾¹ï¼Œè‹¥æœ‰å¤šæ¡è¾¹å¯ä»¥åˆ é™¤ï¼Œè¯·è¾“å‡ºæ ‡å‡†è¾“å…¥ä¸­æœ€åå‡ºç°çš„ä¸€æ¡è¾¹ã€‚\nè¾“å…¥ç¤ºä¾‹\n3 1 2 1 3 2 3 è¾“å‡ºç¤ºä¾‹\n2 3\né¢˜ç›®åˆ†æ # å¦‚æœå‘ç°å…¥åº¦ä¸º2çš„èŠ‚ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦åˆ¤æ–­ åˆ é™¤å“ªä¸€æ¡è¾¹ï¼Œåˆ é™¤åæœ¬å›¾èƒ½æˆä¸ºæœ‰å‘æ ‘ã€‚å¦‚æœæ˜¯åˆ å“ªä¸ªéƒ½å¯ä»¥ï¼Œä¼˜å…ˆåˆ é¡ºåºé åçš„è¾¹ã€‚æƒ…å†µä¸‰ï¼š å¦‚æœæ²¡æœ‰å…¥åº¦ä¸º2çš„ç‚¹ï¼Œè¯´æ˜ å›¾ä¸­æœ‰ç¯äº†ï¼ˆæ³¨æ„æ˜¯æœ‰å‘ç¯ï¼‰ã€‚\nisTreeAfterRemoveEdge() åˆ¤æ–­åˆ ä¸€ä¸ªè¾¹ä¹‹åæ˜¯ä¸æ˜¯æœ‰å‘æ ‘ï¼š å°†æ‰€æœ‰è¾¹çš„ä¸¤ç«¯èŠ‚ç‚¹åˆ†åˆ«åŠ å…¥å¹¶æŸ¥é›†ï¼Œé‡åˆ°è¦ è¦åˆ é™¤çš„è¾¹åˆ™è·³è¿‡ï¼Œå¦‚æœé‡åˆ°å³å°†åŠ å…¥å¹¶æŸ¥é›†çš„è¾¹çš„ä¸¤ç«¯èŠ‚ç‚¹ æœ¬æ¥å°±åœ¨å¹¶æŸ¥é›†äº†ï¼Œè¯´æ˜æ„æˆäº†ç¯ã€‚\nå¦‚æœé¡ºåˆ©å°†æ‰€æœ‰è¾¹çš„ä¸¤ç«¯èŠ‚ç‚¹ï¼ˆé™¤äº†è¦åˆ é™¤çš„è¾¹ï¼‰åŠ å…¥äº†å¹¶æŸ¥é›†ï¼Œåˆ™è¯´æ˜ åˆ é™¤è¯¥æ¡è¾¹ è¿˜æ˜¯ä¸€ä¸ªæœ‰å‘æ ‘\ngetRemoveEdge()ç¡®å®šå›¾ä¸­ä¸€å®šæœ‰äº†æœ‰å‘ç¯ï¼Œé‚£ä¹ˆè¦æ‰¾åˆ°éœ€è¦åˆ é™¤çš„é‚£æ¡è¾¹ï¼š å°†æ‰€æœ‰è¾¹çš„ä¸¤ç«¯èŠ‚ç‚¹åˆ†åˆ«åŠ å…¥å¹¶æŸ¥é›†ï¼Œå¦‚æœé‡åˆ°å³å°†åŠ å…¥å¹¶æŸ¥é›†çš„è¾¹çš„ä¸¤ç«¯èŠ‚ç‚¹ æœ¬æ¥å°±åœ¨å¹¶æŸ¥é›†äº†ï¼Œè¯´æ˜æ„æˆäº†ç¯ã€‚\nACä»£ç  # #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int n; vector\u0026lt;int\u0026gt; father (1001, 0); // å¹¶æŸ¥é›†åˆå§‹åŒ– void init() { for (int i = 1; i \u0026lt;= n; ++i) { father[i] = i; } } // å¹¶æŸ¥é›†é‡Œå¯»æ ¹çš„è¿‡ç¨‹ int find(int u) { return u == father[u] ? u : father[u] = find(father[u]); } // å°†v-\u0026gt;u è¿™æ¡è¾¹åŠ å…¥å¹¶æŸ¥é›† void join(int u, int v) { u = find(u); v = find(v); if (u == v) return ; father[v] = u; } // åˆ¤æ–­ u å’Œ væ˜¯å¦æ‰¾åˆ°åŒä¸€ä¸ªæ ¹ bool same(int u, int v) { u = find(u); v = find(v); return u == v; } // åœ¨æœ‰å‘å›¾é‡Œæ‰¾åˆ°åˆ é™¤çš„é‚£æ¡è¾¹ï¼Œä½¿å…¶å˜æˆæ ‘ void getRemoveEdge(const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { init(); // åˆå§‹åŒ–å¹¶æŸ¥é›† for (int i = 0; i \u0026lt; n; i++) { // éå†æ‰€æœ‰çš„è¾¹ if (same(edges[i][0], edges[i][1])) { // æ„æˆæœ‰å‘ç¯äº†ï¼Œå°±æ˜¯è¦åˆ é™¤çš„è¾¹ cout \u0026lt;\u0026lt; edges[i][0] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; edges[i][1]; return; } else { join(edges[i][0], edges[i][1]); } } } // åˆ ä¸€æ¡è¾¹ä¹‹ååˆ¤æ–­æ˜¯ä¸æ˜¯æ ‘ bool isTreeAfterRemoveEdge(const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges, int deleteEdge) { init(); // åˆå§‹åŒ–å¹¶æŸ¥é›† for (int i = 0; i \u0026lt; n; i++) { if (i == deleteEdge) continue; if (same(edges[i][0], edges[i][1])) { // æ„æˆæœ‰å‘ç¯äº†ï¼Œä¸€å®šä¸æ˜¯æ ‘ return false; } join(edges[i][0], edges[i][1]); } return true; } int main() { int s, t; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; edges; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; inDegree(n + 1, 0); // è®°å½•èŠ‚ç‚¹å…¥åº¦ for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; inDegree[t]++; edges.push_back({s, t}); } vector\u0026lt;int\u0026gt; vec; // è®°å½•å…¥åº¦ä¸º2çš„è¾¹ï¼ˆå¦‚æœæœ‰çš„è¯å°±ä¸¤æ¡è¾¹ï¼‰ // æ‰¾å…¥åº¦ä¸º2çš„èŠ‚ç‚¹æ‰€å¯¹åº”çš„è¾¹ï¼Œæ³¨æ„è¦å€’åºï¼Œå› ä¸ºä¼˜å…ˆåˆ é™¤æœ€åå‡ºç°çš„ä¸€æ¡è¾¹ for (int i = n - 1; i \u0026gt;= 0; i--) { if (inDegree[edges[i][1]] == 2) { vec.push_back(i); } } // æƒ…å†µä¸€ã€æƒ…å†µäºŒ if (vec.size() \u0026gt; 0) { // æ”¾åœ¨vecé‡Œçš„è¾¹å·²ç»æŒ‰ç…§å€’å™æ”¾çš„ï¼Œæ‰€ä»¥è¿™é‡Œå°±ä¼˜å…ˆåˆ vec[0]è¿™æ¡è¾¹ if (isTreeAfterRemoveEdge(edges, vec[0])) { cout \u0026lt;\u0026lt; edges[vec[0]][0] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; edges[vec[0]][1]; } else { cout \u0026lt;\u0026lt; edges[vec[1]][0] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; edges[vec[1]][1]; } return 0; } // å¤„ç†æƒ…å†µä¸‰ // æ˜ç¡®æ²¡æœ‰å…¥åº¦ä¸º2çš„æƒ…å†µï¼Œé‚£ä¹ˆä¸€å®šæœ‰æœ‰å‘ç¯ï¼Œæ‰¾åˆ°æ„æˆç¯çš„è¾¹è¿”å›å°±å¯ä»¥äº† getRemoveEdge(edges); } ä¹°äº‘æœµï¼ˆ01èƒŒåŒ…+å¹¶æŸ¥é›†ï¼‰ # é¢˜ç›®æè¿° # Joeè§‰å¾—äº‘æœµå¾ˆç¾ï¼Œå†³å®šå»å±±ä¸Šçš„å•†åº—ä¹°ä¸€äº›äº‘æœµã€‚å•†åº—é‡Œæœ‰næœµäº‘ï¼Œäº‘æœµè¢«ç¼–å·ä¸º1ï¼Œ2ï¼Œâ€¦ï¼Œnï¼Œå¹¶ä¸”æ¯æœµäº‘éƒ½æœ‰ä¸€ä¸ªä»·å€¼ã€‚ä½†æ˜¯å•†åº—è€æ¿è·Ÿä»–è¯´ï¼Œä¸€äº›äº‘æœµè¦æ­é…æ¥ä¹°æ‰å¥½ï¼Œæ‰€ä»¥ä¹°ä¸€æœµäº‘åˆ™ä¸è¿™æœµäº‘æœ‰æ­é…çš„äº‘éƒ½è¦ä¹°ã€‚\nä½†æ˜¯Joeçš„é’±æœ‰é™ï¼Œæ‰€ä»¥ä»–å¸Œæœ›ä¹°çš„ä»·å€¼è¶Šå¤šè¶Šå¥½ã€‚\nè¾“å…¥æ ¼å¼ # ç¬¬1è¡Œnï¼Œmï¼Œwï¼Œè¡¨ç¤ºnæœµäº‘ï¼Œmä¸ªæ­é…ï¼ŒJoeæœ‰wçš„é’±ã€‚\nç¬¬ 2-n+1 è¡Œï¼Œæ¯è¡Œ ciï¼Œdi è¡¨ç¤ºiæœµäº‘çš„ä»·é’±å’Œä»·å€¼ã€‚\nç¬¬n+2-n+1+mè¡Œï¼Œæ¯è¡Œ uiï¼Œviï¼Œè¡¨ç¤ºä¹°uiå°±å¿…é¡»ä¹°viï¼ŒåŒç†ï¼Œå¦‚æœä¹°viå°±å¿…é¡»ä¹°uiã€‚\nè¾“å‡ºæ ¼å¼ # ä¸€è¡Œï¼Œè¡¨ç¤ºå¯ä»¥è·å¾—çš„æœ€å¤§ä»·å€¼ã€‚\nè¾“å…¥æ ·ä¾‹ # 5 3 10 3 10 3 10 3 10 5 100 10 1 1 3 3 2 4 2\nè¾“å‡ºæ ·ä¾‹ # 1\nã€æç¤ºã€‘ ã€æ•°æ®èŒƒå›´ã€‘\n30%çš„æ•°æ®ä¿è¯ï¼šnâ‰¤100ï¼›\n50%çš„æ•°æ®ä¿è¯ï¼šnâ‰¤1,000ï¼›mâ‰¤100ï¼›wâ‰¤1,000ï¼›\n100%çš„æ•°æ®ä¿è¯ï¼šnâ‰¤10,000ï¼›0â‰¤mâ‰¤5000ï¼›wâ‰¤10,000ã€‚\nACä»£ç  # #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MAXN = 10010; int dp[MAXN]; // DPæ•°ç»„ï¼Œè¡¨ç¤ºåœ¨é’±ä¸ºjæ—¶çš„æœ€å¤§ä»·å€¼ int father[MAXN]; // å¹¶æŸ¥é›†çˆ¶èŠ‚ç‚¹ int cost[MAXN]; // æ¯ç»„çš„æˆæœ¬ int value[MAXN]; // æ¯ç»„çš„ä»·å€¼ vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; grid; // å­˜å‚¨æ¯æœµäº‘çš„æˆæœ¬å’Œä»·å€¼ // åˆå§‹åŒ–å¹¶æŸ¥é›† void init(int n) { for (int i = 1; i \u0026lt;= n; i++) { father[i] = i; cost[i] = grid[i].first; value[i] = grid[i].second; } } // æŸ¥æ‰¾å¹¶æŸ¥é›†çš„æ ¹èŠ‚ç‚¹ int find(int x) { return x == father[x] ? x : father[x] = find(father[x]); } // åˆå¹¶ä¸¤ä¸ªäº‘æœµçš„ç»„ void join(int u, int v) { u = find(u); v = find(v); if (u == v) return; // å·²ç»åœ¨åŒä¸€ç»„ father[v] = u; // åˆå¹¶ cost[u] += cost[v]; // åˆå¹¶æˆæœ¬ value[u] += value[v]; // åˆå¹¶ä»·å€¼ } int main() { int n, m, w; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; w; grid.resize(n + 1); // è°ƒæ•´å¤§å° for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; grid[i].first \u0026gt;\u0026gt; grid[i].second; } init(n); // åˆå§‹åŒ–å¹¶æŸ¥é›† // å¤„ç†æ­é…å…³ç³» for (int i = 1; i \u0026lt;= m; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; join(u, v); // åˆå¹¶äº‘æœµçš„ç»„ } // åŠ¨æ€è§„åˆ’æ±‚è§£ for (int i = 1; i \u0026lt;= n; i++) { if (father[i] == i) { // åªå¤„ç†æ ¹èŠ‚ç‚¹ for (int j = w; j \u0026gt;= cost[i]; j--) { dp[j] = max(dp[j], dp[j - cost[i]] + value[i]); } } } // è¾“å‡ºæœ€å¤§ä»·å€¼ cout \u0026lt;\u0026lt; dp[w] \u0026lt;\u0026lt; endl; return 0; } å°é½çš„å›¾è®ºä¹‹æ—… # é—®é¢˜æè¿° # å°é½æ­£åœ¨å­¦ä¹ å›¾è®ºè¯¾ç¨‹ï¼Œå¹¶é‡åˆ°äº†ä»¥ä¸‹é—®é¢˜ï¼Œå¥¹æ„Ÿåˆ°æœ‰äº›å›°æƒ‘ã€‚è¯·ä½ å¸®åŠ©å¥¹è§£å†³è¿™ä¸ªé—®é¢˜ï¼\nç»™å®šä¸€ä¸ªè¿é€šçš„æ— å‘å›¾ï¼Œå›¾ä¸­çš„é¡¶ç‚¹æ ‡å·ä¸º 1â€¦Nï¼Œè¾¹æ ‡å·ä¸º 1â€¦Mã€‚å¯¹äºå›¾ä¸­çš„æ¯ä¸ªé¡¶ç‚¹ vï¼Œæ‰§è¡Œä»¥ä¸‹è¿‡ç¨‹ï¼š\nä»¤ S=v ä¸” h=0ã€‚\nå½“ âˆ£Sâˆ£\u0026lt;N æ—¶ï¼š\nä»æ‰€æœ‰ä¸ S ä¸­æŸä¸€ç«¯ç‚¹ç›¸è¿çš„è¾¹ä¸­ï¼Œé€‰æ‹©æ ‡å·æœ€å°çš„è¾¹ eã€‚å°† e çš„å¦ä¸€ç«¯ç‚¹åŠ å…¥ Sã€‚\næ›´æ–°h=10Ã—h+eã€‚\nè¿”å› h mod 10^9+7ã€‚\næ±‚è§£è¯¥è¿‡ç¨‹çš„æ‰€æœ‰è¿”å›å€¼ã€‚\nè¾“å…¥æ ¼å¼ # ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° N å’Œ Mã€‚\næ¥ä¸‹æ¥æœ‰Mè¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸€æ¡è¾¹ (a_e,b_e) çš„ä¸¤ä¸ªç«¯ç‚¹ï¼Œè¡¨ç¤ºå›¾ä¸­çš„ä¸€æ¡è¾¹ï¼ˆ1â‰¤a_e\u0026lt;b_eâ‰¤N )ã€‚ä¿è¯è¿™äº›è¾¹æ„æˆä¸€æ£µè¿é€šæ ‘ï¼Œä¸”æ¯ä¸€å¯¹é¡¶ç‚¹ä¹‹é—´æœ€å¤šåªæœ‰ä¸€æ¡è¾¹ã€‚\nè¾“å‡ºæ ¼å¼ # è¾“å‡º N è¡Œï¼Œå…¶ä¸­ç¬¬ i è¡Œåº”åŒ…å«ä»é¡¶ç‚¹ i å¼€å§‹æ‰§è¡Œè¿‡ç¨‹æ—¶çš„è¿”å›å€¼ã€‚\næ ·ä¾‹è¾“å…¥ # 3 2 1 2 2 3 æ ·ä¾‹è¾“å‡º # 12 12 21 è¯„æµ‹æ•°æ®è§„æ¨¡\n2â‰¤Nâ‰¤2Ã—10^5ï¼Œ Nâˆ’1â‰¤Mâ‰¤4Ã—10^5ã€‚\nTLEä»£ç  # //TLEäº†ï¼Œä»…ä½œæ€è·¯å€Ÿé‰´ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MOD = 1e9 + 7; struct Edge { int l, r; int val; }; struct CompareEdge { bool operator()(const Edge\u0026amp; a, const Edge\u0026amp; b) { return a.val \u0026gt; b.val; } }; int main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;Edge\u0026gt; edges(m + 1, {0, 0, 0}); vector\u0026lt;vector\u0026lt;Edge\u0026gt;\u0026gt; adj(n + 1); for (int i = 1; i \u0026lt;= m; i++) { cin \u0026gt;\u0026gt; edges[i].l \u0026gt;\u0026gt; edges[i].r; edges[i].val = i; adj[edges[i].l].push_back(edges[i]); adj[edges[i].r].push_back(edges[i]); } vector\u0026lt;long long\u0026gt; result(n + 1, 0); for (int start = 1; start \u0026lt;= n; start++) { vector\u0026lt;bool\u0026gt; isinS(n + 1, false); isinS[start] = true; priority_queue\u0026lt;Edge, vector\u0026lt;Edge\u0026gt;, CompareEdge\u0026gt; pq; for (Edge\u0026amp; edge : adj[start]) { pq.push(edge); } int count = 1; long long h = 0; while (count \u0026lt; n \u0026amp;\u0026amp; !pq.empty()) { Edge edge = pq.top(); pq.pop(); int next = (isinS[edge.l]) ? edge.r : edge.l; if (isinS[next]) continue; isinS[next] = true; count++; h = (10 * h + edge.val) % MOD; for (Edge\u0026amp; edge : adj[next]) { if (!isinS[edge.l] || !isinS[edge.r]) { pq.push(edge); } } } result[start] = h; } for (int i = 1; i \u0026lt;= n; i++) { cout \u0026lt;\u0026lt; result[i] \u0026lt;\u0026lt; endl; } return 0; } ","date":"26 March 2025","externalUrl":null,"permalink":"/posts/algorithm/%E5%B9%B6%E6%9F%A5%E9%9B%86/","section":"Posts","summary":"","title":"å¹¶æŸ¥é›†","type":"posts"},{"content":" è“æ¡¥æ¯C++é¢˜åº“2023-1 # åšä¸»éACMerï¼Œé¢˜ç›®ä»£ç åˆ†æå¯èƒ½ä¼šæœ‰åé¢‡ï¼Œå»ºè®®è°¨æ…å‚è€ƒåšä¸»çš„ACä»£ç ã€‚åˆ†å¸ƒè¿™ç³»åˆ—çš„å¸–å­çš„åˆè¡·æ˜¯åˆ†äº«å®˜æ–¹çš„é¢˜åº“ï¼Œä»¥æ–¹ä¾¿å‹å‹ä»¬å¤‡èµ›:)\nå¶ä¸² # å°è“ç‰¹åˆ«å–œæ¬¢å¶æ•°ï¼Œå½“ä»–çœ‹åˆ°å­—ç¬¦ä¸²æ—¶ï¼Œä»–æ€»æ•°è¦æ£€æŸ¥ä¸€ä¸‹æ˜¯ä¸æ˜¯æ¯ç§å­—ç¬¦éƒ½æ˜¯å‡ºç°å¶æ•°æ¬¡ã€‚ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¯·å¸®åŠ©å°è“æ£€æŸ¥ä¸€ä¸‹è¯¥å­—ç¬¦ä¸²æ˜¯å¦æ»¡è¶³è¦æ±‚ã€‚\nè¾“å…¥æè¿° # è¾“å…¥ä¸€è¡ŒåŒ…å«ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆã€‚\nè¾“å‡ºæè¿° # å¦‚æœå­—ç¬¦ä¸²ä¸­çš„æ¯ç§å­—ç¬¦éƒ½æ˜¯å‡ºç°å¶æ•°æ¬¡ï¼Œè¾“å‡ºå¤§å†™è‹±æ–‡å•è¯ YES ï¼Œå¦åˆ™è¾“å‡ºå¤§å†™è‹±æ–‡å•è¯ NOã€‚\næ ·ä¾‹è¾“å…¥ # banana æ ·ä¾‹è¾“å‡º # NO è¯„æµ‹ç”¨ä¾‹è§„æ¨¡ # å¯¹äº 50%çš„è¯„æµ‹ç”¨ä¾‹ï¼Œ 1â‰¤ å­—ç¬¦ä¸²é•¿åº¦ â‰¤1000ï¼›\nå¯¹äºæ‰€æœ‰è¯„æµ‹ç”¨ä¾‹ï¼Œ1â‰¤ å­—ç¬¦ä¸²é•¿åº¦ â‰¤10^6 ã€‚\nACä»£ç  # åšä¸»ç¬¬ä¸€ååº”å°±æ˜¯unordered_mapï¼Œä¹Ÿå°±ç”¨å®ƒåšå‡ºæ¥äº†\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { unordered_map\u0026lt;char, int\u0026gt; map; string s; cin \u0026gt;\u0026gt; s; for (int i = 0; i \u0026lt; s.size(); i++) { map[s[i]]++; } for (auto\u0026amp; pair : map) { if (pair.second % 2 != 0) { cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34;; return 0; } } cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34;; return 0; } åˆ’åˆ† # é—®é¢˜æè¿° # ç»™å®š 40ä¸ªæ•°ï¼Œè¯·å°†å…¶ä»»æ„åˆ’åˆ†æˆä¸¤ç»„ï¼Œæ¯ç»„è‡³å°‘ä¸€ä¸ªå…ƒç´ ã€‚æ¯ç»„çš„æƒå€¼ä¸ºç»„å†…æ‰€æœ‰å…ƒç´ çš„å’Œã€‚åˆ’åˆ†çš„æƒå€¼ä¸ºä¸¤ç»„æƒå€¼çš„ä¹˜ç§¯ã€‚è¯·é—®å¯¹äºä»¥ä¸‹ 40 ä¸ªæ•°ï¼Œåˆ’åˆ†çš„æƒå€¼æœ€å¤§ä¸ºå¤šå°‘ã€‚\né—®é¢˜åˆ†æ # è¿™ä¸ªé¢˜å…ˆä»äºŒç»´æ•°ç»„åˆ†æï¼Œåšä¸»ç®€å•çš„ç”»äº†ä¸ªå›¾ï¼Œé€šè¿‡åˆ†æå¯ä»¥çœ‹å‡ºdp[i] [j] æ˜¯ç”±â€‹ dp[i-1] [j] â€‹å’Œ dp[i] [j-nums [i]] å…±åŒå½±å“çš„ã€‚\nç„¶åå†å‹ç¼©ä¸ºä¸€ç»´æ•°ç»„è§£å†³ã€‚\nå…·ä½“æ€è·¯å¯å‚è€ƒä»£ç éšæƒ³å½•çš„0-1èƒŒåŒ…åŸºç¡€ç†è®º2,è™½ç„¶æ˜¯ä»¥0-1èƒŒåŒ…ä¸¾ä¾‹ä½†æ˜¯å°†äºŒç»´æ•°ç»„å‹ç¼©ä¸ºä¸€ç»´æ•°ç»„çš„æ€è·¯å’Œæ³¨æ„çš„åœ°æ–¹å¯ä»¥å€Ÿé‰´ã€‚\nACä»£ç  # ç›´è§‰å°±æ˜¯åˆ†æˆä¸¤ç»„å’Œå·®ä¸å¤šçš„ä¸¤éƒ¨åˆ†ï¼Œè¿™æ ·ä¹˜ç§¯æœ€å¤§ã€‚ä¹Ÿå°±æ˜¯è¯´ä¸¤éƒ¨åˆ†çš„å’Œå°½é‡é è¿‘sum/2\né‡‡ç”¨åŠ¨æ€è§„åˆ’ï¼Œå®šä¹‰å¸ƒå°”æ•°ç»„dp[ i ] [ j ]ï¼Œè¡¨ç¤ºåœ¨å‰ç´¢å¼•ä¸º0-iä¸ªæ•°ä¸­ï¼Œæ˜¯å¦å­˜åœ¨å’Œä¸º j çš„ç»„åˆ\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { int nums[40] = {5160, 9191, 6410, 4657, 7492, 1531, 8854, 1253, 4520, 9231, 1266, 4801, 3484, 4323, 5070, 1789, 2744, 5959, 9426, 4433, 4404, 5291, 2470, 8533, 7608, 2935, 8922, 5273, 8364, 8819, 7374, 8077, 5336, 8495, 5602, 6553, 3548, 5267, 9150, 3309}; int total_sum = 0; for (int i = 0; i \u0026lt; 40; i++) { total_sum += nums[i]; } vector\u0026lt;bool\u0026gt; dp(total_sum / 2 + 1, false); dp[0] = true; for (int i = 0; i \u0026lt; 40; i++) { for (int j = total_sum / 2; j \u0026gt;= nums[i]; j--) { if (dp[j - nums[i]]) { dp[j] = true; } } } long long max_product = 0; for (int i = total_sum / 2; i \u0026gt;= 0; i--) { if (dp[i]) { max_product = (long long)i * (total_sum - i); break; } } cout \u0026lt;\u0026lt; max_product \u0026lt;\u0026lt; endl; return 0; } ç³–æœåˆ†é… # é—®é¢˜æè¿° # ä¸¤ç§ç³–æœåˆ†åˆ«æœ‰9ä¸ªå’Œ 16 ä¸ªï¼Œè¦å…¨éƒ¨åˆ†ç»™ 7 ä¸ªå°æœ‹å‹ï¼Œæ¯ä¸ªå°æœ‹å‹å¾—åˆ°çš„ç³–æœæ€»æ•°æœ€å°‘ä¸º 2 ä¸ªæœ€å¤šä¸º 5 ä¸ªï¼Œé—®æœ‰å¤šå°‘ç§ä¸åŒçš„åˆ†æ³•ã€‚ç³–æœå¿…é¡»å…¨éƒ¨åˆ†å®Œã€‚\nåªè¦æœ‰å…¶ä¸­ä¸€ä¸ªå°æœ‹å‹åœ¨ä¸¤ç§æ–¹æ¡ˆä¸­åˆ†åˆ°çš„ç³–æœä¸å®Œå…¨ç›¸åŒï¼Œè¿™ä¸¤ç§æ–¹æ¡ˆå°±ç®—ä½œä¸åŒçš„æ–¹æ¡ˆã€‚\nACä»£ç  # #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int res=0; void dfs(int idx, int a_size, int b_size) { if (idx == 7) { if(a_size == 0 \u0026amp;\u0026amp; b_size == 0)res++; return; } for (int i = 0; i \u0026lt;= a_size; i++) { for (int j = 0; j \u0026lt;= b_size; j++) { if (i + j \u0026gt;= 2 \u0026amp;\u0026amp; i + j \u0026lt;= 5) { dfs(idx + 1, a_size - i, b_size - j); } } } } int main() { int a = 16, b = 9; dfs(0, a, b); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return 0; } æ··ä¹˜æ•°å­— # é—®é¢˜æè¿° # æ··ä¹˜æ•°å­—çš„å®šä¹‰å¦‚ä¸‹: å¯¹äºä¸€ä¸ªæ­£æ•´æ•° ğ‘›ï¼Œå¦‚æœå­˜åœ¨æ­£æ•´æ•° ğ‘,ğ‘ï¼Œä½¿å¾—ğ‘›=ğ‘Ã—ğ‘ï¼Œè€Œä¸” ğ‘å’Œ ğ‘çš„åè¿›åˆ¶æ•°ä½ä¸­æ¯ä¸ªæ•°å­—å‡ºç°çš„æ¬¡æ•°ä¹‹å’Œä¸ ğ‘›ä¸­å¯¹åº”æ•°å­—å‡ºç°æ¬¡æ•°ç›¸åŒï¼Œåˆ™ç§° ğ‘›ä¸ºæ··ä¹˜æ•°å­—ã€‚ä¾‹å¦‚ï¼Œå¯¹äºæ­£æ•´æ•° ğ‘›=126ï¼Œå­˜åœ¨ ğ‘=6, ğ‘=21æ»¡è¶³æ¡ä»¶ï¼Œå› æ­¤126æ˜¯ä¸€ä¸ªæ··ä¹˜æ•°å­—ã€‚åˆå¦‚ï¼Œå¯¹äºæ­£æ•´æ•° ğ‘›=180225ï¼Œå­˜åœ¨ ğ‘=225, ğ‘=801 æ»¡è¶³æ¡ä»¶ï¼Œå› æ­¤ 180225 æ˜¯ä¸€ä¸ªæ··ä¹˜æ•°å­—ã€‚è¯·ä½ å¸®åŠ©è®¡ç®—å‡ºï¼Œ1âˆ¼1000000(å«)ä¹‹é—´ä¸€å…±æœ‰å¤šå°‘ä¸ªæ•°å­—æ˜¯æ··ä¹˜æ•°å­—ã€‚\nACä»£ç  # #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; bool judge(int a, int b, int c, int* valid) { fill(valid, valid+10, 0); while(a){valid[a%10]++;a/=10;} while(b){valid[b%10]++;b/=10;} while(c){valid[c%10]--;c/=10;} for(int i=0;i\u0026lt;10;i++) if(valid[i]!=0) return false; return true; } int main() { const int n = 1e6; vector\u0026lt;bool\u0026gt; nums(n+1, false); int res = 0; for(int i=1; i\u0026lt;=n; i++){ for(int j=1; j\u0026lt;=i \u0026amp;\u0026amp; i*j\u0026lt;=n; j++){ int valid[10]={0}; if(judge(i,j,i*j,valid) \u0026amp;\u0026amp; !nums[i*j]){ nums[i*j] = true; //æ³¨æ„ï¼ä¸€å¼€å§‹æ²¡åŠ boolç±»å‹çš„numsæ•°ç»„ï¼Œå…¶å®næ˜¯å¯èƒ½é‡å¤è®¡æ•°çš„ res++; } } } cout \u0026lt;\u0026lt; res; return 0; } ä¿é™©ç®± # é—®é¢˜æè¿° # å°è“æœ‰ä¸€ä¸ªä¿é™©ç®±ï¼Œä¿é™©ç®±ä¸Šå…±æœ‰ n ä½æ•°å­—ã€‚å°è“å¯ä»¥ä»»æ„è°ƒæ•´ä¿é™©ç®±ä¸Šçš„æ¯ä¸ªæ•°å­—ï¼Œæ¯ä¸€æ¬¡æ“ä½œå¯ä»¥å°†å…¶ä¸­ä¸€ä½å¢åŠ  1 æˆ–å‡å°‘ 1ã€‚å½“æŸä½åŸæœ¬ä¸º 9 æˆ– 0 æ—¶å¯èƒ½ä¼šå‘å‰ï¼ˆå·¦è¾¹ï¼‰è¿›ä½/é€€ä½ï¼Œå½“æœ€é«˜ä½ï¼ˆå·¦è¾¹ç¬¬ä¸€ä½ï¼‰ä¸Šçš„æ•°å­—å˜åŒ–æ—¶å‘å‰çš„è¿›ä½æˆ–é€€ä½å¿½ç•¥ã€‚\nç¤ºä¾‹ï¼š\n00000 çš„ç¬¬ 5 ä½å‡ 1 å˜ä¸º 99999ï¼› 99999 çš„ç¬¬ 5 ä½å‡ 1 å˜ä¸º 99998ï¼› 00000 çš„ç¬¬ 4 ä½å‡ 1 å˜ä¸º 99990ï¼› 97993 çš„ç¬¬ 4 ä½åŠ  1 å˜ä¸º 98003ï¼› 99909 çš„ç¬¬ 3 ä½åŠ  1 å˜ä¸º 00009ã€‚ ä¿é™©ç®±ä¸Šä¸€å¼€å§‹æœ‰ä¸€ä¸ªæ•°å­— xï¼Œå°è“å¸Œæœ›æŠŠå®ƒå˜æˆ yï¼Œè¿™æ ·æ‰èƒ½æ‰“å¼€å®ƒã€‚é—®å°è“æœ€å°‘éœ€è¦æ“ä½œçš„æ¬¡æ•°ã€‚\nè¾“å…¥æ ¼å¼ # ç¬¬ä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•° nã€‚ ç¬¬äºŒè¡ŒåŒ…å«ä¸€ä¸ª n ä½æ•´æ•° xã€‚ ç¬¬ä¸‰è¡ŒåŒ…å«ä¸€ä¸ª n ä½æ•´æ•° yã€‚ è¾“å‡ºæ ¼å¼ # è¾“å‡ºä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•°è¡¨ç¤ºç­”æ¡ˆã€‚\næ ·ä¾‹è¾“å…¥ # 5\n12349\n54321\næ ·ä¾‹è¾“å‡º # 11\nå¯¹äº 30% çš„è¯„æµ‹ç”¨ä¾‹ï¼Œ1 â‰¤ n â‰¤ 300ï¼› å¯¹äº 60% çš„è¯„æµ‹ç”¨ä¾‹ï¼Œ1 â‰¤ n â‰¤ 3000ï¼› å¯¹äºæ‰€æœ‰è¯„æµ‹ç”¨ä¾‹ï¼Œ1 â‰¤ n â‰¤ 1e5ï¼Œx å’Œ y ä¸­ä»…åŒ…å«æ•°å­— 0 è‡³ 9ï¼Œå¯èƒ½æœ‰å‰å¯¼é›¶ã€‚ ACä»£ç  # è¿™ä¸ªçŠ¶æ€æ–¹ç¨‹æ²¡æƒ³å‡ºæ¥:(\nå®šä¹‰åŠ¨æ€è§„åˆ’çŠ¶æ€ dp[i][j]ï¼Œå…¶ä¸­ï¼š\ni è¡¨ç¤ºå½“å‰å¤„ç†åˆ°æ•°å­—çš„ç¬¬ i ä½ï¼ˆä»ä½ä½åˆ°é«˜ä½ï¼Œå³ä»å³åˆ°å·¦ï¼‰ã€‚ j è¡¨ç¤ºå½“å‰ä½çš„è¿›ä½/é€€ä½çŠ¶æ€ï¼š j = 0ï¼šç¬¬ i ä½æ—¢æ²¡æœ‰è¿›ä½ä¹Ÿæ²¡æœ‰é€€ä½çš„æ“ä½œæ•°ã€‚ j = 1ï¼šç¬¬ i ä½è¿›è¡Œäº†è¿›ä½ï¼ˆå³å½“å‰ä½æ•°å­— +1 åå½±å“äº†é«˜ä½ï¼‰çš„æ“ä½œæ•°ã€‚ j = 2ï¼šç¬¬ i ä½è¿›è¡Œäº†é€€ä½ï¼ˆå³å½“å‰ä½æ•°å­— -1 åå½±å“äº†é«˜ä½ï¼‰çš„æ“ä½œæ•°ã€‚ #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt;xv(n,0),yv(n,0); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;dp(n,vector\u0026lt;int\u0026gt;(3,0)); string x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; reverse(x.begin(),x.end()); reverse(y.begin(),y.end()); for(int i=0;i\u0026lt;n;i++) { xv[i]=x[i]-\u0026#39;0\u0026#39;; yv[i]=y[i]-\u0026#39;0\u0026#39;; } for(int i=0;i\u0026lt;n;i++) { if(i==0) { dp[i][0]=abs(xv[i]-yv[i]); dp[i][1]=yv[i]-xv[i]+10; dp[i][2]=xv[i]-yv[i]+10; } else { dp[i][0]=min({dp[i-1][0]+abs(yv[i]-xv[i]), dp[i-1][1]+abs(xv[i]+1-yv[i]), dp[i-1][2]+abs(xv[i]-1-yv[i])}); dp[i][1]=min({dp[i-1][0]+(10+yv[i]-xv[i]), dp[i-1][1]+(10+yv[i]-(xv[i]+1)), //ä¸Šä¸€ä½å› ä¸ºè¿›ä½ï¼Œå› æ­¤xv[i]+1ã€‚åˆå› ä¸ºè¿™ä¸€ä½è¦é€šè¿‡è¿›ä½åŒ¹é…ï¼Œæ‰€ä»¥åŠ ä¸Š10 dp[i-1][2]+(10+yv[i]-(xv[i]-1))}); //ä»¥æ­¤ç±»æ¨ dp[i][2]=min({dp[i-1][0]+(10+xv[i]-yv[i]), dp[i-1][1]+(10+xv[i]+1-yv[i]), dp[i-1][2]+(10+xv[i]-1-yv[i])}); } } cout\u0026lt;\u0026lt;min({dp[n-1][0],dp[n-1][1],dp[n-1][2]}); return 0; } ç®¡é“ # é—®é¢˜æè¿° # æœ‰ä¸€æ ¹é•¿åº¦ä¸º len çš„æ¨ªå‘ç®¡é“ï¼Œè¯¥ç®¡é“æŒ‰ç…§å•ä½é•¿åº¦åˆ†ä¸º len æ®µï¼Œæ¯ä¸€æ®µçš„ä¸­å¤®æœ‰ä¸€ä¸ªå¯å¼€å…³çš„é˜€é—¨å’Œä¸€ä¸ªæ£€æµ‹æ°´æµçš„ä¼ æ„Ÿå™¨ã€‚\nä¸€å¼€å§‹ç®¡é“æ˜¯ç©ºçš„ï¼Œä½äº Li çš„é˜€é—¨ä¼šåœ¨ Si æ—¶åˆ»æ‰“å¼€ï¼Œå¹¶ä¸æ–­è®©æ°´æµå…¥ç®¡é“ã€‚\nå¯¹äºä½äº Li çš„é˜€é—¨ï¼Œå®ƒæµå…¥çš„æ°´åœ¨ Ti æ—¶åˆ»ï¼ˆTi \u0026gt;= Siï¼‰ä¼šä½¿å¾—ä»ç¬¬ Li - (Ti - Si) æ®µåˆ°ç¬¬ Li + (Ti - Si) æ®µçš„ä¼ æ„Ÿå™¨æ£€æµ‹åˆ°æ°´æµã€‚\næ±‚ç®¡é“ä¸­æ¯ä¸€æ®µä¸­é—´çš„ä¼ æ„Ÿå™¨éƒ½æ£€æµ‹åˆ°æœ‰æ°´æµçš„æœ€æ—©æ—¶é—´ã€‚\nè¾“å…¥æ ¼å¼ # è¾“å…¥çš„ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° n, lenï¼Œç”¨ä¸€ä¸ªç©ºæ ¼åˆ†éš”ï¼Œåˆ†åˆ«è¡¨ç¤ºä¼šæ‰“å¼€çš„é˜€é—¨æ•°å’Œç®¡é“é•¿åº¦ã€‚\næ¥ä¸‹æ¥ n è¡Œæ¯è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° Li, Siï¼Œç”¨ä¸€ä¸ªç©ºæ ¼åˆ†éš”ï¼Œè¡¨ç¤ºä½äºç¬¬ Li æ®µç®¡é“ä¸­å¤®çš„é˜€é—¨ä¼šåœ¨ Si æ—¶åˆ»æ‰“å¼€ã€‚\nè¾“å‡ºæ ¼å¼ # è¾“å‡ºä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•°è¡¨ç¤ºç­”æ¡ˆã€‚\næ ·ä¾‹è¾“å…¥ # 3 10 1 1 6 5 10 2 æ ·ä¾‹è¾“å‡º # 5 å¯¹äº 30% çš„è¯„æµ‹ç”¨ä¾‹ï¼Œn \u0026lt;= 200ï¼ŒSi, len \u0026lt;= 3000ï¼› å¯¹äº 70% çš„è¯„æµ‹ç”¨ä¾‹ï¼Œn \u0026lt;= 5000ï¼ŒSi, len \u0026lt;= 10^5ï¼› å¯¹äºæ‰€æœ‰è¯„æµ‹ç”¨ä¾‹ï¼Œ1 \u0026lt;= n \u0026lt;= 10^5ï¼Œ1 \u0026lt;= Si, len \u0026lt;= 10^9ï¼Œ1 \u0026lt;= Li \u0026lt;= lenï¼ŒLi-1 \u0026lt; Liã€‚ TLEä»£ç  # ï¼ˆåªé€šè¿‡äº†ç™¾åˆ†ä¹‹60ï¼Œæ²¡é‡‡ç”¨ç»å…¸çš„åŒºé—´è¦†ç›–å¥—è·¯ï¼‰\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; bool judgeisfill(long long time, const vector\u0026lt;pair\u0026lt;long, long\u0026gt;\u0026gt;\u0026amp; water, long long len) { vector\u0026lt;bool\u0026gt; covered(len + 1, false); // ç”¨äºæ ‡è®°æ¯ä¸€æ®µæ˜¯å¦è¢«è¦†ç›– for (int i = 0; i \u0026lt; water.size(); i++) { if (time \u0026gt;= water[i].second) { long long left = max(1LL, water[i].first - (time - water[i].second)); long long right = min(len, water[i].first + (time - water[i].second)); for (long long j = left; j \u0026lt;= right; j++) { covered[j] = true; // æ ‡è®°è¦†ç›–èŒƒå›´ } } } for (int i = 1; i \u0026lt;= len; i++) { if (!covered[i]) return false; } return true; } int main() { int n; long long len; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; len; vector\u0026lt;pair\u0026lt;long, long\u0026gt;\u0026gt; water(n, {0, 0}); vector\u0026lt;bool\u0026gt; pipe(n, false); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; water[i].first \u0026gt;\u0026gt; water[i].second; } long long s = 1e9; long long l = 1, r = s; while (l \u0026lt; r) { long long mid = (l + r) \u0026gt;\u0026gt; 1; if (judgeisfill(mid, water, len)) { r = mid; } else { l = mid + 1; } } cout \u0026lt;\u0026lt; l; return 0; } ACä»£ç  # #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; bool judgeisfill(long long time, const vector\u0026lt;pair\u0026lt;long, long\u0026gt;\u0026gt;\u0026amp; water, long long len) { vector\u0026lt;pair\u0026lt;long long ,long long\u0026gt;\u0026gt; intervals; for (const auto\u0026amp; valve : water) { if (time \u0026gt;= valve.second) { // å¦‚æœå½“å‰æ—¶é—´å¤§äºç­‰äºé˜€é—¨æ‰“å¼€çš„æ—¶é—´ long long left = max(1LL, valve.first - (time - valve.second)); // è®¡ç®—å·¦è¾¹ç•Œ long long right = min(len, valve.first + (time - valve.second)); // è®¡ç®—å³è¾¹ç•Œ intervals.push_back({left, right}); } } if (intervals.empty()) return false; // å¦‚æœæ²¡æœ‰åŒºé—´ï¼Œç›´æ¥è¿”å› false // æŒ‰å·¦ç«¯ç‚¹æ’åº sort(intervals.begin(), intervals.end()); // æ£€æŸ¥è¦†ç›–èŒƒå›´ long long r = intervals[0].second; // åˆå§‹æœ€è¿œå³ç«¯ç‚¹ if (intervals[0].first \u0026gt; 1) return false; // å¦‚æœç¬¬ä¸€ä¸ªåŒºé—´çš„å·¦ç«¯ç‚¹å¤§äº 1ï¼Œç›´æ¥è¿”å› false for (size_t i = 1; i \u0026lt; intervals.size(); i++) { if (intervals[i].first \u0026gt; r + 1) return false; // å¦‚æœå½“å‰åŒºé—´ä¸ r ä¸ç›¸é‚»ï¼Œè¿”å› false r = max(r, intervals[i].second); // æ›´æ–°æœ€è¿œå³ç«¯ç‚¹ } return r \u0026gt;= len; // å¦‚æœ r å¤§äºç­‰äº lenï¼Œè¿”å› true } int main() { int n; long long len; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; len; vector\u0026lt;pair\u0026lt;long, long\u0026gt;\u0026gt; water(n); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; water[i].first \u0026gt;\u0026gt; water[i].second; } long long l = 0, r = 1e18; // è®¾ç½®ä¸€ä¸ªè¾ƒå¤§çš„ä¸Šç•Œ while (l \u0026lt; r) { long long mid = (l + r) \u0026gt;\u0026gt; 1; if (judgeisfill(mid, water, len)) { r = mid; } else { l = mid + 1; } } cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; endl; return 0; } åŒºé—´è¦†ç›–æ˜¯ä¸€ä¸ªç»å…¸é—®é¢˜ã€‚æˆ‘ä»¬å¯ä»¥æŒ‰åŒºé—´çš„å·¦ç«¯ç‚¹æ¥æ’åºè¿™äº›åŒºé—´ã€‚æˆ‘ä»¬æ£€æŸ¥è¿™äº›åŒºé—´æ˜¯å¦è¦†ç›–äº†æ•´ä¸ªç®¡é“ã€‚å¦‚æœç¬¬ä¸€ä¸ªåŒºé—´çš„å·¦ç«¯ç‚¹å¤§äº 1ï¼Œé‚£ä¹ˆè¡¨ç¤ºç®¡é“çš„å¼€å§‹éƒ¨åˆ†æ²¡æœ‰è¢«è¦†ç›–ï¼Œç›´æ¥è¿”å› falseã€‚å¦åˆ™æˆ‘ä»¬è®¾ä¸€ä¸ªå˜é‡ r è¡¨ç¤ºå¯åˆ°è¾¾çš„æœ€è¿œè·ç¦»ï¼Œrçš„åˆå§‹å€¼ä¸ºç¬¬ä¸€ä¸ªåŒºé—´çš„å³ç«¯ç‚¹ã€‚æˆ‘ä»¬æ¥ç€æ£€æŸ¥å…¶ä»–åŒºé—´æ˜¯å¦ä¸ rç›¸é‚»æˆ–é‡å ã€‚å¦‚æœå½“å‰åŒºé—´å’Œ r ç›¸é‚»æˆ–é‡å ï¼Œæˆ‘ä»¬å°†å½“å‰åŒºé—´çš„å³ç«¯ç‚¹å’Œ rå–æœ€å¤§å€¼ã€‚æœ€åå¦‚æœ râ‰¥lenåˆ™è¯´æ˜æˆåŠŸè¦†ç›–æ‰€æœ‰åŒºé—´ï¼Œå¦åˆ™è¯´æ˜æ²¡æœ‰ã€‚\n","date":"26 March 2025","externalUrl":null,"permalink":"/posts/lanqiaocup/lanqiaocup2023-1/","section":"Posts","summary":"","title":"Lanqiaocup2023-1","type":"posts"},{"content":"","date":"26 March 2025","externalUrl":null,"permalink":"/series/%E8%93%9D%E6%A1%A5%E6%9D%AF%E9%A2%98%E5%BA%93/","section":"Series","summary":"","title":"è“æ¡¥æ¯é¢˜åº“","type":"series"},{"content":" Titanic ç®€æ´çš„ç¥ç»ç½‘ç»œå¤ç° # æœ¬æ–‡å¤ç°çš„æ˜¯fastaiçš„å®˜æ–¹è§†é¢‘æ•™ç¨‹ ç‚¹å‡»æ­¤å¤„è·³è½¬\nå…¶å®˜æ–¹kaggleç¬”è®°æœ¬ ç‚¹å‡»æ­¤å¤„è·³è½¬\næœ¬ç¯‡åšå®¢æ˜¯åœ¨fastaiè¯¾ç¨‹åŸºç¡€ä¸Šè¿›è¡Œæ€»ç»“ï¼Œå…ˆå¤ç°åªæœ‰ä¸€å±‚éšè—å±‚çš„ç¥ç»ç½‘ç»œï¼Œæ¥ç€åœ¨æ­¤åŸºç¡€ä¸Šå¤ç°æ·±åº¦å­¦ä¹ ç®€æ˜“æ¡†æ¶\nimport torch import numpy as np import pandas as pd df = pd.read_csv(\u0026#34;./train.csv\u0026#34;) df.head() å¤„ç†ç¼ºå¤±å€¼ï¼ˆä½¿ç”¨ä¼—æ•°ï¼‰ # df.isna().sum() ##OUTPUT PassengerId 0 Survived 0 Pclass 0 Name 0 Sex 0 Age 177 SibSp 0 Parch 0 Ticket 0 Fare 0 Cabin 687 Embarked 2 dtype: int64 modes = df.mode().iloc[0] #iloc[0]æ˜¯æŒ‡çš„æ˜¯é€‰æ‹©ç¬¬ä¸€ä¸ªä¼—æ•°ï¼ˆå³ç¬¬ä¸€è¡Œï¼‰ï¼Œå¹¶å°†å…¶èµ‹å€¼ç»™ modes df.fillna(modes,inplace=True) df.head() å¤„ç†æ•°å€¼å˜é‡ï¼ˆé•¿å°¾æ•ˆåº”ï¼‰ # df.isna().sum() ##OUTPUT PassengerId 0 Survived 0 Pclass 0 Name 0 Sex 0 Age 0 SibSp 0 Parch 0 Ticket 0 Fare 0 Cabin 0 Embarked 0 dtype: int64 df.describe() PassengerId Survived Pclass Age SibSp Parch Fare count 891.000000 891.000000 891.000000 891.000000 891.000000 891.000000 891.000000 mean 446.000000 0.383838 2.308642 28.566970 0.523008 0.381594 32.204208 std 257.353842 0.486592 0.836071 13.199572 1.102743 0.806057 49.693429 min 1.000000 0.000000 1.000000 0.420000 0.000000 0.000000 0.000000 25% 223.500000 0.000000\u003e 2.000000 22.000000 0.000000 0.000000 7.910400 50% 446.000000 0.000000 3.000000 24.000000 0.000000 0.000000 14.454200 75% 668.500000 1.000000 3.000000 35.000000 1.000000 0.000000 31.000000 max 891.000000 1.000000 3.000000 80.000000 8.000000 6.000000 512.329200 df[\u0026#34;Fare\u0026#34;]=np.log(df[\u0026#34;Fare\u0026#34;]+1) å¤„ç†æ–‡æœ¬å˜é‡ # df.describe(include=[object]) Name Sex Ticket Cabin Embarked count 891 891 891 891 891 unique 891 2 681 147 3 top Dooley, Mr. Patrick male 1601 B96 B98 S freq 1 577 7 691 646 df = pd.get_dummies(df, columns=[\u0026#34;Sex\u0026#34;, \u0026#34;Pclass\u0026#34;, \u0026#34;Embarked\u0026#34;], dtype=int) df.columns ##OUTPUT Index([\u0026#39;PassengerId\u0026#39;, \u0026#39;Survived\u0026#39;, \u0026#39;Name\u0026#39;, \u0026#39;Age\u0026#39;, \u0026#39;SibSp\u0026#39;, \u0026#39;Parch\u0026#39;, \u0026#39;Ticket\u0026#39;, \u0026#39;Fare\u0026#39;, \u0026#39;Cabin\u0026#39;, \u0026#39;Sex_female\u0026#39;, \u0026#39;Sex_male\u0026#39;, \u0026#39;Pclass_1\u0026#39;, \u0026#39;Pclass_2\u0026#39;, \u0026#39;Pclass_3\u0026#39;, \u0026#39;Embarked_C\u0026#39;, \u0026#39;Embarked_Q\u0026#39;, \u0026#39;Embarked_S\u0026#39;], dtype=\u0026#39;object\u0026#39;) df.head() added_cols =[\u0026#34;Sex_male\u0026#34;,\u0026#34;Sex_female\u0026#34;,\u0026#34;Pclass_1\u0026#34;,\u0026#34;Pclass_2\u0026#34;,\u0026#34;Pclass_3\u0026#34;,\u0026#34;Embarked_C\u0026#34;,\u0026#34;Embarked_Q\u0026#34;,\u0026#34;Embarked_S\u0026#34;] df[added_cols].head( ) Sex_male Sex_female Pclass_1 Pclass_2 Pclass_3 Embarked_C Embarked_Q Embarked_S 0 1 0 0 0 1 0 0 1 1 0 1 1 0 0 1 0 0 2 0 1 0 0 1 0 0 1 3 0 1 1 0 0 0 0 1 4 1 0 0 0 1 0 0 1 åˆ’åˆ†æ•°æ®é›† # from torch import tensor indep_cols=[\u0026#34;Age\u0026#34;,\u0026#34;SibSp\u0026#34;,\u0026#34;Parch\u0026#34;,\u0026#34;Fare\u0026#34;]+added_cols t_dep = tensor(df.Survived) t_indep = tensor(df[indep_cols].values, dtype=torch.float) t_dep.shape torch.Size([891])\nt_indep.shape torch.Size([891, 12])\nt_indep ##OUTPUT tensor([[22., 1., 0., ..., 0., 0., 1.], [38., 1., 0., ..., 1., 0., 0.], [26., 0., 0., ..., 0., 0., 1.], ..., [24., 1., 2., ..., 0., 0., 1.], [26., 0., 0., ..., 1., 0., 0.], [32., 0., 0., ..., 0., 1., 0.]]) from fastai.data.transforms import RandomSplitter trn_split,val_split = RandomSplitter(seed=42)(df) trn_indep = t_indep[trn_split] val_indep = t_indep[val_split] trn_dep = t_dep[trn_split] val_dep = t_dep[val_split] len(trn_dep) 713\nlen(val_dep) 178\ntrn_dep = trn_dep[:,None] #å‡ç»´ï¼Œè½¬æˆçŸ©é˜µ vla_dep = trn_dep[:,None] å®šä¹‰è®­ç»ƒå‡½æ•°å’ŒéªŒè¯å‡½æ•° # è®­ç»ƒæ¨¡å‹ # def train_model(epochs=30,lr=1.4): torch.manual_seed(442) #èƒ½å¤ç°è®­ç»ƒè¿‡ç¨‹ coeffs = init_coeffs() for i in range(epochs): one_epoch(coeffs,lr=lr) return coeffs def init_coeffs(n_hidden=20): layer1=(torch.rand(n_coeffs,n_hidden)-0.5)/n_hidden layer2=torch.rand(n_hidden,1)-0.3 const=torch.rand(1)[0] #[0]çš„ä½œç”¨æ˜¯åœ¨å¼ é‡ä¸­å–æ ‡é‡ return layer1.requires_grad_(),layer2.requires_grad_(),const.requires_grad_() def one_epoch(coeffs,lr): loss = calc_loss(coeffs,trn_indep,trn_dep) loss.backward() with torch.no_grad():update_coeffs(coeffs,lr) print(f\u0026#34;{loss:.3f}\u0026#34;,end=\u0026#34;; \u0026#34;) def update_coeffs(coeffs,lr): for layer in coeffs: layer.sub_(layer.grad*lr) layer.grad.zero_() def calc_loss(coeffs,indeps,deps): return torch.abs(calc_preds(coeffs,indeps)-deps).mean() import torch.nn.functional as F def calc_preds(coeffs, indeps): l1,l2,const = coeffs res = F.relu(indeps@l1) res = res@l2 + const return torch.sigmoid(res) éªŒè¯æ¨¡å‹ # def acc(coeffs): return(val_dep.bool()==(calc_preds(coeffs,val_indep)\u0026gt;0.5)).float().mean() å¼€å§‹è®­ç»ƒ # n_coeffs = trn_indep.shape[1] coeffs = train_model(lr=2.4) 0.579; 0.370; 0.369; 0.369; 0.368; 0.368; 0.367; 0.366; 0.366; 0.365; 0.365; 0.364; 0.363; 0.363; 0.362; 0.361; 0.361; 0.360; 0.359; 0.358; 0.357; 0.357; 0.356; 0.355; 0.354; 0.352; 0.351; 0.349; 0.347; 0.344;\nacc(coeffs) tensor(0.5322)\ncoeffs = train_model(lr=1.2) 0.579; 0.377; 0.370; 0.369; 0.369; 0.369; 0.368; 0.368; 0.368; 0.367; 0.367; 0.366; 0.366; 0.366; 0.365; 0.365; 0.365; 0.364; 0.364; 0.364; 0.363; 0.363; 0.363; 0.362; 0.362; 0.361; 0.361; 0.361; 0.360; 0.360;\nacc(coeffs) tensor(0.5869)\næ·±åº¦å­¦ä¹  # def init_coeffs(): hiddens = [10, 10] sizes = [n_coeffs] + hiddens + [1] n = len(sizes) layers = [(torch.rand(sizes[i], sizes[i+1])-0.3)/sizes[i+1]*4 for i in range(n-1)] consts = [(torch.rand(1)[0]-0.5)*0.1 for i in range(n-1)] for l in layers+consts: l.requires_grad_() return layers,consts import torch.nn.functional as F def calc_preds(coeffs, indeps): layers,consts = coeffs n = len(layers) res = indeps for i,l in enumerate(layers): res = res@l + consts[i] if i!=n-1: res = F.relu(res) return torch.sigmoid(res) def update_coeffs(coeffs, lr): layers,consts = coeffs for layer in layers+consts: layer.sub_(layer.grad * lr) layer.grad.zero_() n_coeffs = trn_indep.shape[1] coeffs = train_model(lr=4) 0.373; 0.377; 0.377; 0.375; 0.371; 0.368; 0.365; 0.361; 0.357; 0.357; 0.356; 0.350; 0.344; 0.619; 0.340; 0.621; 0.621; 0.620; 0.618; 0.613; 0.569; 0.379; 0.379; 0.379; 0.379; 0.379; 0.379; 0.379; 0.379; 0.379;\nacc(coeffs) tensor(0.5955)\n","date":"24 March 2025","externalUrl":null,"permalink":"/posts/deeplearning/create-neural-net-from-scratch/","section":"Posts","summary":"","title":"Create Neural Net From Scratch","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]